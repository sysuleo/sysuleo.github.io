<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-uUIis3aZOy">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="整数溢出# c语言中，32位机器的int 长度为32 位，表示的范围: [-2147483648, 2147483647], 超过这个范围就会溢出了。 由于整数溢出现象的存在，程序员需要结合业务场景，谨慎选择数据类型。 而在python中，就没有整数溢出的烦恼。 Python 可以计算十的一百次方，这在其他语言是不可想象的： 12&gt;&gt;&gt; 10 ** 100100000">
<meta property="og:type" content="article">
<meta property="og:title" content="[python源码分析] 4.不溢出的整数int">
<meta property="og:url" content="http://yoursite.com/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/index.html">
<meta property="og:site_name" content="LiuWen&#39;s Blogs">
<meta property="og:description" content="整数溢出# c语言中，32位机器的int 长度为32 位，表示的范围: [-2147483648, 2147483647], 超过这个范围就会溢出了。 由于整数溢出现象的存在，程序员需要结合业务场景，谨慎选择数据类型。 而在python中，就没有整数溢出的烦恼。 Python 可以计算十的一百次方，这在其他语言是不可想象的： 12&gt;&gt;&gt; 10 ** 100100000">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/PyIntObject.jpg">
<meta property="og:image" content="http://yoursite.com/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/bigInt.jpg">
<meta property="og:image" content="http://yoursite.com/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/IntOp.jpg">
<meta property="article:published_time" content="2020-11-14T08:05:47.000Z">
<meta property="article:modified_time" content="2024-10-13T03:36:19.914Z">
<meta property="article:author" content="Liu Wen">
<meta property="article:tag" content="python源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/PyIntObject.jpg">

<link rel="canonical" href="http://yoursite.com/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>[python源码分析] 4.不溢出的整数int | LiuWen's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LiuWen's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [python源码分析] 4.不溢出的整数int
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-14 16:05:47" itemprop="dateCreated datePublished" datetime="2020-11-14T16:05:47+08:00">2020-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">python源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1><span id="zheng-shu-yi-chu">整数溢出</span><a href="#zheng-shu-yi-chu" class="header-anchor">#</a></h1>
<p>c语言中，32位机器的int 长度为32 位，表示的范围: [-2147483648,
2147483647], 超过这个范围就会溢出了。
由于整数溢出现象的存在，程序员需要结合业务场景，<strong>谨慎选择数据类型</strong>。</p>
<p>而在python中，就没有整数溢出的烦恼。 Python
可以计算十的一百次方，这在其他语言是不可想象的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 ** 100</span><br><span class="line">10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>
也许我们过去都接触过
<strong>c语言大整数的实现</strong>，接下来我们来看看python如何实现大整数。</p>
<h1><span id="int-dui-xiang">int 对象</span><a href="#int-dui-xiang" class="header-anchor">#</a></h1>
<p>int 对象在 Include/longobject.h 头文件中定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _longobject PyLongObject; &#x2F;* Revealed in longintrepr.h *&#x2F;</span><br></pre></td></tr></table></figure>
顺着注释去 Include/longintrepr.h 中，找到了实现 int 对象的结构体：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct _longobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD        &#x2F;*可变长对象都具有的公共头部*&#x2F;</span><br><span class="line">    digit ob_digit[1];     &#x2F;*这里存储int的整数值*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在 Include/longintrepr.h 头文件，可以找到 <strong>digit</strong>
字段的定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PYLONG_BITS_IN_DIGIT &#x3D;&#x3D; 30</span><br><span class="line">typedef uint32_t digit;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">#elif PYLONG_BITS_IN_DIGIT &#x3D;&#x3D; 15</span><br><span class="line">typedef unsigned short digit;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
由此可知<strong>digit 就是一个 C 语言整数</strong>，因此 <strong>int
对象是通过整数数组来实现大整数的</strong>。至于整数数组用什么整数类型来实现，
Python 提供了两个版本，一个是 <strong>32 位的 uint32_t ，一个是 16 位的
unsigned short</strong> ，编译 Python 解析器时可以
<strong>通过宏定义指定选用的版本</strong>。</p>
<p>Python 作者为什么要这样设计呢？这主要是
<strong>出于内存方面的考量：对于范围不大的整数，用 16
位整数表示即可</strong>，用 32 位就有点浪费。</p>
<p>整数对象| 对象大小（16位）| 对象大小（32位） -:-|-:-|-:- 1|24 + 2 * 1
= 26|24 + 4 * 1 = 28 1000000 |24 + 2 * 2 = 28|24 + 4 * 1 = 28
10000000000 |24 + 2 * 3 = 30|24 + 4 * 2 = 32</p>
<hr>
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/PyIntObject.jpg" class title="PyIntObject图">
</div>
<h5><span id="q-ob-digit-shu-zu-chang-du-ke-neng-da-yu-1-er-wei-shi-me-zai-jie-gou-ti-ding-yi-zhong-ob-digit-shu-zu-chang-du-que-gu-ding-wei-1">Q：ob_digit
数组长度可能大于1，而为什么在结构体定义中， ob_digit 数组长度却固定为
1？</span><a href="#q-ob-digit-shu-zu-chang-du-ke-neng-da-yu-1-er-wei-shi-me-zai-jie-gou-ti-ding-yi-zhong-ob-digit-shu-zu-chang-du-que-gu-ding-wei-1" class="header-anchor">#</a></h5>
<p>由于 C 语言中 <strong>数组长度不是类型信息</strong>，我们可以
<strong>根据实际需要为 ob_digit 数组分配足够的内存，并将其当成长度为 n
的数组</strong>操作。这也是 C 语言中一个常用的编程技巧。长度信息在
<strong>PyVarObject(PyVarObject比PyObjcet多了个ob_size字段，详细定义可以看<a target="_blank" rel="noopener" href="http://liuw.tech/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%AF%B9%E8%B1%A1/" title="[python源码分析] 1.对象">[python源码分析]
1.对象</a>)中的ob_size中</strong>。</p>
<h1><span id="shi-xian-da-zheng-shu">实现大整数</span><a href="#shi-xian-da-zheng-shu" class="header-anchor">#</a></h1>
<p>整数分为 <strong>正数 、 负数 和 零</strong> ， Python 规定不同整数在
int 对象中的存储方式，要点可以总结为 3 条：</p>
<p>整数 <strong>绝对值</strong> 根据实际情况分为若干部分，保存于
ob_digit 数组中； <strong>ob_digit 数组长度 保存于 ob_size
字段</strong>，对于 <strong>负整数 的情况，ob_size
为负</strong>（这里可以说就很精妙了）； 整数 <strong>零 以 ob_size 等于
0 来表示</strong>，<strong>ob_digit 数组为空</strong>； 接下来，我们以 5
个典型的例子详细介绍这几条规则：</p>
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/bigInt.jpg" class title="bigInt图">
</div>
<ol type="1">
<li>对于整数 0 ， ob_size 字段等于 0 ， ob_digit
数组为空，无需分配。</li>
<li>对于整数 10 ，其绝对值保存于 ob_digit 数组中，数组长度为 1 ，
ob_size 字段等于 1 。</li>
<li>对于整数 -10 ，其绝对值同样保存于 ob_digit 数组中，但由于 -10
为负数， <strong>ob_size 字段等于 -1</strong> 。</li>
<li>对于整数 1073741824 ( 2 的 30 次方)，由于 <strong>Python 只使用 32
整数的后 30 位</strong>，因此
<strong>需要另一个整数才能存储</strong>，整数数组长度为 2
。绝对值这样计算：<span class="math inline">\(2^{30}*1+2^0*0=10737418242\)</span></li>
<li>对于整数 -4294967297 (负的 2 的 32 次方加 1 )，同样要长度为 2 的
ob_digit 数组，但 ob_size 字段为负。绝对值这样计算：<span class="math inline">\(2^{30}*4+2^0*1=42949672972\)</span></li>
</ol>
<h3><span id="wei-shi-me-python-zhi-yong-ob-digit-shu-zu-zheng-shu-de-hou-30-wei">为什么 Python
只用 ob_digit 数组整数的后 30 位？</span><a href="#wei-shi-me-python-zhi-yong-ob-digit-shu-zu-zheng-shu-de-hou-30-wei" class="header-anchor">#</a></h3>
<p>这跟 <strong>加法进位有关</strong>。如果全部 32
位都用来保存绝对值，那么为了保证加法不溢出(产生进位)，需要先强制转换成
64 位类型后在进行计算。但 <strong>牺牲最高 1
位后，加法运算便不用担心进位溢出了</strong>。那么，为什么 Python
牺牲最高 2 位呢？应该是 <strong>为了和 16 位整数方案统一起来：如果选用
16 位整数作为数组， Python 则只使用其中 15 位</strong>。</p>
<h1><span id="xiao-zheng-shu-jing-tai-dui-xiang-chi">小整数静态对象池</span><a href="#xiao-zheng-shu-jing-tai-dui-xiang-chi" class="header-anchor">#</a></h1>
<p>小整数对象池在 Objects/longobject.c 中实现，关键代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*小整数池的范围通过宏来定义的, 默认是-5-257,我们可以通过修改此处的宏来调整小整数池的大小, 但是需要对python进行重新编译*&#x2F;</span><br><span class="line">#ifndef NSMALLPOSINTS</span><br><span class="line">#define NSMALLPOSINTS           257   &#x2F;*该宏规定了对象池 正数个数 (从 0 开始，包括 0 )，默认 257 个*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#ifndef NSMALLNEGINTS</span><br><span class="line">#define NSMALLNEGINTS           5     &#x2F;*该宏规定了对象池 负数个数 ，默认 5 个*&#x2F;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];  &#x2F;*一个整数对象数组，保存预先创建好的小整数对象*&#x2F;</span><br></pre></td></tr></table></figure></p>
<p>如果在[-5,
257)范围内，会直接返回存于small_ints的对象，所以小整数只会存在一个实例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; longobject.c</span><br><span class="line">static PyObject * </span><br><span class="line">get_small_int(sdigit ival)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    assert(-NSMALLNEGINTS &lt;&#x3D; ival &amp;&amp; ival &lt; NSMALLPOSINTS);</span><br><span class="line">    v &#x3D; (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">#ifdef COUNT_ALLOCS</span><br><span class="line">    if (ival &gt;&#x3D; 0)</span><br><span class="line">        quick_int_allocs++;</span><br><span class="line">    else</span><br><span class="line">        quick_neg_int_allocs++;</span><br><span class="line">#endif</span><br><span class="line">    return v;</span><br></pre></td></tr></table></figure></p>
<p>至于为什么选择静态缓存从 <strong>-5 到 256</strong>
之间的小整数，主要是出于某种 权衡 ：<strong>这个范围内的整数使用
频率很高 ，而缓存这些小整数的 内存开销相对可控</strong>
。很多程序开发场景都没有固定的正确答案，需要根据实际情况平衡利弊。</p>
<p>理解了静态对象池，如下现象就很好理解了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1 + 0</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1 * 1</span><br><span class="line">&gt;&gt;&gt; id(a), id(b)</span><br><span class="line">(4408209536, 4408209536)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c &#x3D; 1000 + 0</span><br><span class="line">&gt;&gt;&gt; d &#x3D; 1000 * 1</span><br><span class="line">&gt;&gt;&gt; id(c), id(d)</span><br><span class="line">(4410298224, 4410298160)</span><br></pre></td></tr></table></figure></p>
<p>由于整数对象是 <strong>不可变对象</strong>
，任何<strong>整数运算结果都以新对象返回</strong>，而<strong>对象创建销毁开销却不小</strong>。为了优化整数对象的性能，
Python 在启动时将使用 频率较高 的小整数预先创建好，这就是
<strong>小整数缓存池</strong> 。默认情况下，小整数缓存池缓存 <strong>从
-5 到 256 之间的整数</strong>。</p>
<h1><span id="shu-xue-yun-suan">数学运算</span><a href="#shu-xue-yun-suan" class="header-anchor">#</a></h1>
根据我们在 PyTypeObject 中学到的知识，对象的行为由对象的 类型
决定。因此，整数对象
<strong>数学运算的秘密藏在整数类型对象中</strong>。在
<strong>Objects/longobject.c</strong> 中找到整数类型对象( PyLong_Type
)，其定义如下所示：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;int&quot;,                                      &#x2F;* tp_name *&#x2F;</span><br><span class="line">    offsetof(PyLongObject, ob_digit),           &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    sizeof(digit),                              &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_vectorcall_offset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_getattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_async *&#x2F;</span><br><span class="line">    long_to_decimal_string,                     &#x2F;* tp_repr *&#x2F;</span><br><span class="line">    &amp;long_as_number,                            &#x2F;* tp_as_number *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc)long_hash,                        &#x2F;* tp_hash *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_call *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_str *&#x2F;</span><br><span class="line">    PyObject_GenericGetAttr,                    &#x2F;* tp_getattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_buffer *&#x2F;</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               &#x2F;* tp_flags *&#x2F;</span><br><span class="line">    long_doc,                                   &#x2F;* tp_doc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_traverse *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_clear *&#x2F;</span><br><span class="line">    long_richcompare,                           &#x2F;* tp_richcompare *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_weaklistoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iter *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iternext *&#x2F;</span><br><span class="line">    long_methods,                               &#x2F;* tp_methods *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_members *&#x2F;</span><br><span class="line">    long_getset,                                &#x2F;* tp_getset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_base *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dict *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_get *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_set *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dictoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_init *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_alloc *&#x2F;</span><br><span class="line">    long_new,                                   &#x2F;* tp_new *&#x2F;</span><br><span class="line">    PyObject_Del,                               &#x2F;* tp_free *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
类型对象中， <strong>tp_as_number 是一个关键字段。该字段指向一个
PyNumberMethods 结构体</strong>，结构体保存了 <strong>各种数学运算的
函数指针 </strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static PyNumberMethods long_as_number &#x3D; &#123;</span><br><span class="line">    (binaryfunc)long_add,       &#x2F;*nb_add*&#x2F;</span><br><span class="line">    (binaryfunc)long_sub,       &#x2F;*nb_subtract*&#x2F;</span><br><span class="line">    (binaryfunc)long_mul,       &#x2F;*nb_multiply*&#x2F;</span><br><span class="line">    long_mod,                   &#x2F;*nb_remainder*&#x2F;</span><br><span class="line">    long_divmod,                &#x2F;*nb_divmod*&#x2F;</span><br><span class="line">    long_pow,                   &#x2F;*nb_power*&#x2F;</span><br><span class="line">    (unaryfunc)long_neg,        &#x2F;*nb_negative*&#x2F;</span><br><span class="line">    (unaryfunc)long_long,       &#x2F;*tp_positive*&#x2F;</span><br><span class="line">    (unaryfunc)long_abs,        &#x2F;*tp_absolute*&#x2F;</span><br><span class="line">    (inquiry)long_bool,         &#x2F;*tp_bool*&#x2F;</span><br><span class="line">    (unaryfunc)long_invert,     &#x2F;*nb_invert*&#x2F;</span><br><span class="line">    long_lshift,                &#x2F;*nb_lshift*&#x2F;</span><br><span class="line">    (binaryfunc)long_rshift,    &#x2F;*nb_rshift*&#x2F;</span><br><span class="line">    long_and,                   &#x2F;*nb_and*&#x2F;</span><br><span class="line">    long_xor,                   &#x2F;*nb_xor*&#x2F;</span><br><span class="line">    long_or,                    &#x2F;*nb_or*&#x2F;</span><br><span class="line">    long_long,                  &#x2F;*nb_int*&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
下图展示了 <strong>整数对象 、 整数类型对象 以及
整数数学运算处理函数</strong> 之间的关系：
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/IntOp.jpg" class title="IntOp图">
</div>
<h3><span id="jia-fa">加法</span><a href="#jia-fa" class="header-anchor">#</a></h3>
<p>如何为一个由数组表示的大整数实现加法？问题答案得在 long_add
函数中找，该函数是整数对象 加法处理函数 。我们再接再厉，扒开 long_add
函数看个究竟(同样位于 Objects/longobject.c )：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">long_add(PyLongObject *a, PyLongObject *b)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;*定义变量 z 用于临时保存计算结果*&#x2F;</span><br><span class="line">    PyLongObject *z;  </span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    如果参与运算的整数对象底层数组长度均不超过 1 ，直接用 MEDIUM_VALUE 宏将整数对象转化成 C 整数类型进行运算，</span><br><span class="line">    性能损耗极小。满足这个条件的整数范围在 -1073741823~1073741823 之间，足以覆盖程序运行时的绝大部分运算场景</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (Py_ABS(Py_SIZE(a)) &lt;&#x3D; 1 &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;&#x3D; 1) &#123;</span><br><span class="line">        return PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    if (Py_SIZE(a) &lt; 0) &#123;</span><br><span class="line">        if (Py_SIZE(b) &lt; 0) &#123;</span><br><span class="line">          &#x2F;*如果两个整数均为 负数 ，调用 x_add 计算两者绝对值之和，再将结果符号设置为负( 16 行处)*&#x2F;</span><br><span class="line">            z &#x3D; x_add(a, b);</span><br><span class="line">            if (z !&#x3D; NULL) &#123;</span><br><span class="line">                assert(Py_REFCNT(z) &#x3D;&#x3D; 1);</span><br><span class="line">                Py_SIZE(z) &#x3D; -(Py_SIZE(z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;*如果 a 为负数， b 为正数，调用 x_sub 计算 b 和 a 的绝对值之差即为最终结果*&#x2F;</span><br><span class="line">        else</span><br><span class="line">            z &#x3D; x_sub(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (Py_SIZE(b) &lt; 0)</span><br><span class="line">            z &#x3D; x_sub(a, b);</span><br><span class="line">        else</span><br><span class="line">        &#x2F;*如果两个整数均为正数，调用 x_add 计算两个绝对值之和即为最终结果*&#x2F;</span><br><span class="line">            z &#x3D; x_add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    return (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### x_add x_add 用于计算两个整数对象绝对值之和，源码同样位于
Objects/longobject.c ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static PyLongObject *</span><br><span class="line">x_add(PyLongObject *a, PyLongObject *b)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;*取ob_size的绝对值*&#x2F;</span><br><span class="line">    Py_ssize_t size_a &#x3D; Py_ABS(Py_SIZE(a)), size_b &#x3D; Py_ABS(Py_SIZE(b));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*用变量z 临时存储计算结果*&#x2F;</span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    &#x2F;*临时进位*&#x2F;</span><br><span class="line">    digit carry &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ensure a is the larger of the two: *&#x2F;</span><br><span class="line">    if (size_a &lt; size_b) &#123;</span><br><span class="line">     &#x2F;*如果 a 数组长度比较小，将 a 、 b 交换，数组长度较大的那个在前面*&#x2F;</span><br><span class="line">        &#123; PyLongObject *temp &#x3D; a; a &#x3D; b; b &#x3D; temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp &#x3D; size_a;</span><br><span class="line">            size_a &#x3D; size_b;</span><br><span class="line">            size_b &#x3D; size_temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*创建新整数对象，用于保存计算结果（注意到长度必须比 a 和 b 都大一，因为可能有进位）*&#x2F;</span><br><span class="line">    z &#x3D; _PyLong_New(size_a+1);</span><br><span class="line"></span><br><span class="line">    if (z &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    &#x2F;*遍历 b 底层数组，与 a 对应部分相加并保存到 z 中，需要特别注意进位计算*&#x2F;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; ++i) &#123;</span><br><span class="line">        carry +&#x3D; a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] &#x3D; carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;&#x3D; PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*遍历 a 底层数组剩余部分，与进位相加后保存到 z 中，同样需要特别注意进位计算*&#x2F;</span><br><span class="line">    for (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        carry +&#x3D; a-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] &#x3D; carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;&#x3D; PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*将进位写入 z 底层数组最高位单元中*&#x2F;</span><br><span class="line">    z-&gt;ob_digit[i] &#x3D; carry;</span><br><span class="line">    &#x2F;*去除计算结果 z 底层数组中前面多余的零，因为最后的进位可能为零*&#x2F;</span><br><span class="line">    return long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/read/76/article/1903" title="Python 源码深度剖析/07 int 对象，永不溢出的整数">Python
源码深度剖析/07 int 对象，永不溢出的整数</a></li>
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/read/76/article/1904" title="Python 源码深度剖析/08 int 源码解析：如何实现大整数运算？">Python
源码深度剖析/08 int 源码解析：如何实现大整数运算？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34174132/article/details/89699621?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" title="Python3源码—整数对象">Python3源码—整数对象</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># python源码分析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/12/linux-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" rel="prev" title="[linux] 1.常用指令">
      <i class="fa fa-chevron-left"></i> [linux] 1.常用指令
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/15/TCP-IP%E5%8D%B7%E4%B8%80-1-Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/" rel="next" title="[TCP/IP卷一]1.Internet地址结构">
      [TCP/IP卷一]1.Internet地址结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">整数溢出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">int 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.0.0.1.</span> <span class="nav-text">Q：ob_digit
数组长度可能大于1，而为什么在结构体定义中， ob_digit 数组长度却固定为
1？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">实现大整数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.0.1.</span> <span class="nav-text">为什么 Python
只用 ob_digit 数组整数的后 30 位？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">小整数静态对象池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">数学运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">5.0.1.</span> <span class="nav-text">加法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liu Wen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sysuleo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sysuleo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/leo666-40" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;leo666-40" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>zhihu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Wen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'e06a4b8906757c42331f',
      clientSecret: '5b0fe4dc7f1d7b47ea86f07155d29e5824e5dc9a',
      repo        : 'mygitalk',
      owner       : 'sysuleo',
      admin       : ['sysuleo'],
      id          : 'fef7bfb545d8eb1ee3a8d4a145c2048a',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
