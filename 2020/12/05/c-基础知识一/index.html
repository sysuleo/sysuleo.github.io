<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-uUIis3aZOy">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="构造函数#  函数名与类名相同 不能定义返回值，也不能有return语句 可以有形式参数，也可以没有 可以是内联函数 可以重载 可以带默认参数值 对象被创建时自动调用 如果不定义构造函数，编译器编译阶段会生成默认构造函数 如果此时希望编译器隐含生成默认构造函数，只需加上&#x3D;default  123456789101112131415161718class Clock &amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="[c++]基础知识一">
<meta property="og:url" content="http://yoursite.com/2020/12/05/c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/index.html">
<meta property="og:site_name" content="LiuWen&#39;s Blogs">
<meta property="og:description" content="构造函数#  函数名与类名相同 不能定义返回值，也不能有return语句 可以有形式参数，也可以没有 可以是内联函数 可以重载 可以带默认参数值 对象被创建时自动调用 如果不定义构造函数，编译器编译阶段会生成默认构造函数 如果此时希望编译器隐含生成默认构造函数，只需加上&#x3D;default  123456789101112131415161718class Clock &amp;#12">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-12-05T03:22:17.000Z">
<meta property="article:modified_time" content="2024-10-13T03:36:19.906Z">
<meta property="article:author" content="Liu Wen">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/12/05/c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>[c++]基础知识一 | LiuWen's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LiuWen's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/05/c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [c++]基础知识一
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-05 11:22:17" itemprop="dateCreated datePublished" datetime="2020-12-05T11:22:17+08:00">2020-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2><span id="gou-zao-han-shu">构造函数</span><a href="#gou-zao-han-shu" class="header-anchor">#</a></h2>
<ol type="1">
<li>函数名与类名相同</li>
<li>不能定义返回值，也不能有return语句</li>
<li>可以有形式参数，也可以没有</li>
<li>可以是内联函数</li>
<li>可以重载</li>
<li>可以带默认参数值</li>
<li>对象被创建时自动调用</li>
<li>如果不定义构造函数，编译器编译阶段会生成默认构造函数</li>
<li>如果此时希望编译器隐含生成默认构造函数，只需加上=default</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Clock &#123;</span><br><span class="line">public:</span><br><span class="line">    Clock(int h, int m, int s);</span><br><span class="line">   Clock(); &#x2F;&#x2F;默认构造函数</span><br><span class="line">   void setTime(int h, int m, int s);</span><br><span class="line">    void showTime();</span><br><span class="line">private:</span><br><span class="line">    int hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock() : hour(0), minute(0), second(0) &#123;&#125;&#x2F;&#x2F;默认构造函数，用初始化列表，但是没用形参</span><br><span class="line">Clock::Clock(int h,int m,int s):hour(h),minute(m),second(s)&#123;&#125; </span><br><span class="line">&#x2F;&#x2F;用初始列表初始化hour，minute，second三个成员变量，效率高，简单初始化无需写在结构体里面</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  Clock c1(0,1,8); &#x2F;&#x2F;调用构造函数</span><br><span class="line">   Clock c2; &#x2F;&#x2F;调用无参构造函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="wei-tuo-gou-zao-han-shu">委托构造函数</span><a href="#wei-tuo-gou-zao-han-shu" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock::Clock(int h,int m,int s):hour(h),minute(m),second(s)&#123;&#125; </span><br><span class="line">Clock::Clock() : hour(0), minute(0), second(0) &#123;&#125;&#x2F;&#x2F;默认构造函数，用初始化列表，但是没用形参</span><br><span class="line"></span><br><span class="line">委托构造函数不仅可以简洁，而且保证代码一致性</span><br><span class="line">Clock::Clock():Clock(0,0,0)&#123;&#125;  &#x2F;&#x2F;默认构造函数用委托构造函数构造</span><br></pre></td></tr></table></figure>
<h3><span id="kao-bei-gou-zao-han-shu">拷贝构造函数</span><a href="#kao-bei-gou-zao-han-shu" class="header-anchor">#</a></h3>
<p>特殊的构造函数，其<strong>形参为本类对象的引用</strong>,
<strong>用一个已存在的对象去初始化同类型的新对象</strong> 1.
定义一个对象，以本类
<strong>另一个对象作为初始值，发送拷贝构造函数</strong> 2.
如果函数的形参时类的对象，调用函数时，将使用实参对象初始化形参对象 3.
如果函数的
<strong>返回值是类的对象，函数执行完返回主调函数时，将使用return语句中的对象初始化一个临时无名对象</strong>，传递给主调i函数
4. C++11用"=delete"指示编译器不生成默认复制构造函数<strong> 5.
</strong>拷贝构造函数是一种特殊的构造函数<strong>，具有
</strong>单个形参<strong>，该形参（常用const修饰）是
</strong>对该类类型的引用<strong>。 6.
当定义一个新对象并用一个同类型的对象对它进行初始化时，将
</strong>显示使用拷贝构造函数<strong>。当该类型的对象传递给函数或从函数返回该类型的对象时，将
</strong>隐式调用拷贝构造函数**。</p>
<p>C++支持两种初始化形式：复制初始化（int a = 5;）和直接初始化（int
a(5);）对于类
<strong>类型直接初始化直接调用实参匹配的构造函数</strong>，<strong>复制初始化总是调用拷贝构造函数</strong>，也就是说：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A x(2);　　&#x2F;&#x2F;直接初始化，调用构造函数</span><br><span class="line">A y &#x3D; x;　　&#x2F;&#x2F;复制初始化，调用拷贝构造函数</span><br></pre></td></tr></table></figure></p>
<p>下面使用上面定义的类对象来说明各个构造函数的用法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 1 void main()</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     &#x2F;&#x2F; 调用了无参构造函数，数据成员初值被赋为0.0</span><br><span class="line"> 4     Complex c1，c2;</span><br><span class="line"> 5  </span><br><span class="line"> 6     &#x2F;&#x2F; 调用一般构造函数，数据成员初值被赋为指定值</span><br><span class="line"> 7     Complex c3(1.0,2.5);</span><br><span class="line"> 8     &#x2F;&#x2F; 也可以使用下面的形式</span><br><span class="line"> 9     Complex c3 &#x3D; Complex(1.0,2.5);</span><br><span class="line">10          </span><br><span class="line">11     &#x2F;&#x2F; 把c3的数据成员的值赋值给c1</span><br><span class="line">12     &#x2F;&#x2F; 由于c1已经事先被创建，故此处不会调用任何构造函数</span><br><span class="line">13     &#x2F;&#x2F; 只会调用 &#x3D; 号运算符重载函数</span><br><span class="line">14     c1 &#x3D; c3;</span><br><span class="line">15          </span><br><span class="line">16     &#x2F;&#x2F; 调用类型转换构造函数</span><br><span class="line">17     &#x2F;&#x2F; 系统首先调用类型转换构造函数，将5.2创建为一个本类的临时对象，然后调用等号运算符重载，将该临时对象赋值给c1</span><br><span class="line">18     c2 &#x3D; 5.2;</span><br><span class="line">19        </span><br><span class="line">20     &#x2F;&#x2F; 调用拷贝构造函数( 有下面两种调用方式) </span><br><span class="line">21     Complex c5(c2);</span><br><span class="line">22     Complex c4 &#x3D; c2;  &#x2F;&#x2F; 注意和 &#x3D; 运算符重载区分,这里等号左边的对象不是事先已经创建，故需要调用拷贝构造函数，参数为c2       </span><br><span class="line">23          </span><br><span class="line">24 &#125;</span><br></pre></td></tr></table></figure>
参考：http://www.cnblogs.com/xkfz007/archive/2012/05/11/2496447.html</p>
<h2><span id="shen-kao-bei-he-qian-kao-bei">深拷贝和浅拷贝：</span><a href="#shen-kao-bei-he-qian-kao-bei" class="header-anchor">#</a></h2>
<ol type="1">
<li><p>所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。</p></li>
<li><p>在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间</p></li>
</ol>
<p>如果一个类拥有资源，当这个<strong>类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝</strong></p>
<p>上面提到，如果没有自定义拷贝构造函数，则系统会创建默认的拷贝构造函数，但系统创建的
<strong>默认拷贝构造函数只会执行“浅拷贝”</strong>，即将被拷贝对象的数据成员的值一一赋值给新创建的对象，若该类的数据成员中
<strong>有指针成员，则会使得新的对象的指针所指向的地址与被拷贝对象的指针所指向的地址相同，delete该指针时则会导致两次重复delete而出错</strong>。下面是示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include &lt;iostream.h&gt;</span><br><span class="line"> 2 #include &lt;string.h&gt;</span><br><span class="line"> 3 class Person </span><br><span class="line"> 4 &#123;</span><br><span class="line"> 5 public :</span><br><span class="line"> 6          </span><br><span class="line"> 7     &#x2F;&#x2F; 构造函数</span><br><span class="line"> 8     Person(char * pN)</span><br><span class="line"> 9     &#123;</span><br><span class="line">10         cout &lt;&lt; &quot;一般构造函数被调用 !\n&quot;;</span><br><span class="line">11         m_pName &#x3D; new char[strlen(pN) + 1];</span><br><span class="line">12         &#x2F;&#x2F;在堆中开辟一个内存块存放pN所指的字符串</span><br><span class="line">13         if(m_pName !&#x3D; NULL) </span><br><span class="line">14         &#123;</span><br><span class="line">15            &#x2F;&#x2F;如果m_pName不是空指针，则把形参指针pN所指的字符串复制给它</span><br><span class="line">16              strcpy(m_pName ,pN);</span><br><span class="line">17         &#125;</span><br><span class="line">18     &#125;        </span><br><span class="line">19        </span><br><span class="line">20     &#x2F;&#x2F; 系统创建的默认复制构造函数，只做位模式拷贝</span><br><span class="line">21     Person(Person &amp; p)    </span><br><span class="line">22     &#123; </span><br><span class="line">23         &#x2F;&#x2F;使两个字符串指针指向同一地址位置         </span><br><span class="line">24         m_pName &#x3D; p.m_pName;         </span><br><span class="line">25     &#125;</span><br><span class="line">26  </span><br><span class="line">27     ~Person( )</span><br><span class="line">28     &#123;</span><br><span class="line">29         delete m_pName;</span><br><span class="line">30     &#125;</span><br><span class="line">31          </span><br><span class="line">32 private :</span><br><span class="line">33     char * m_pName;</span><br><span class="line">34 &#125;;</span><br><span class="line">35  </span><br><span class="line">36 void main( )</span><br><span class="line">37 &#123; </span><br><span class="line">38     Person man(&quot;lujun&quot;);</span><br><span class="line">39     Person woman(man); </span><br><span class="line">40      </span><br><span class="line">41     &#x2F;&#x2F; 结果导致   man 和    woman 的指针都指向了同一个地址</span><br><span class="line">42      </span><br><span class="line">43     &#x2F;&#x2F; 函数结束析构时</span><br><span class="line">44     &#x2F;&#x2F; 同一个地址被delete两次</span><br><span class="line">45 &#125;</span><br><span class="line">46  </span><br><span class="line">47  </span><br><span class="line">48 &#x2F;&#x2F; 下面自己设计复制构造函数，实现“深拷贝”，即不让指针指向同一地址，而是重新申请一块内存给新的对象的指针数据成员</span><br><span class="line">49 Person(Person &amp; chs);</span><br><span class="line">50 &#123;</span><br><span class="line">51      &#x2F;&#x2F; 用运算符new为新对象的指针数据成员分配空间</span><br><span class="line">52      m_pName&#x3D;new char[strlen(p.m_pName)+ 1];</span><br><span class="line">53  </span><br><span class="line">54      if(m_pName)         </span><br><span class="line">55      &#123;</span><br><span class="line">56              &#x2F;&#x2F; 复制内容</span><br><span class="line">57             strcpy(m_pName ,chs.m_pName);</span><br><span class="line">58      &#125;</span><br><span class="line">59    </span><br><span class="line">60     &#x2F;&#x2F; 则新创建的对象的m_pName与原对象chs的m_pName不再指向同一地址了</span><br><span class="line">61 &#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="yi-ge-kong-de-class-lei-li-you-shi-me">一个空的class类里有什么?</span><a href="#yi-ge-kong-de-class-lei-li-you-shi-me" class="header-anchor">#</a></h2>
<p>定义一个空类
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
默认会生成以下几个函数 1. 无参的构造函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
2. 拷贝构造函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty(const Empty&amp; copy)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
3. 赋值运算符
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty&amp; operator &#x3D; (const Empty&amp; copy)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
4. 析构函数（非虚）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~Empty()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这些函数只有在第一次使用它们的时候才会生成，他们都是inline并且public的。如果想禁止生成这些函数，可以将它们定义成private函数，如果有很多类都有这种需求，那么可以定义一个基类，然后让其他类继承这个类。
### 空class用法</p>
<p>先假设我们有个很傲娇的类，它不希望通过构造函数生成，也不希望别的对象对它赋值。
然而更加高级的做法是定义一个空类，将空类的复制构造函数和赋值操作符声明为私有，然后让SomeClass继承它。像这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    Empty()&#123;&#125;                    &#x2F;&#x2F;允许derived class调用</span><br><span class="line">    ~Empty()&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    Empty(const Empty&amp;);            &#x2F;&#x2F;阻止了copying</span><br><span class="line">    Empty&amp; operator &#x3D; (const Empty&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SomeClass: private Empty</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这些函数只有在第一次使用它们的时候才会生成，他们都是inline并且public的。如果想禁止生成这些函数，可以将它们定义成private函数，如果有很多类都有这种需求，那么可以定义一个基类，然后让其他类继承这个类。</p>
<h2><span id="xu-han-shu-de-zuo-yong-yi-ji-shi-xian-yuan-li">虚函数的作用以及实现原理</span><a href="#xu-han-shu-de-zuo-yong-yi-ji-shi-xian-yuan-li" class="header-anchor">#</a></h2>
<p>链接：https://www.nowcoder.com/questionTerminal/1f67d4e2b6134c298e993e622181b333
#### 虚函数的作用：简单讲即实现多态。
基类定义了虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，且这样的函数调用是无法在编译器期间确认的，而是在运行期确认，也叫做迟绑定。</p>
<p>对于虚函数的支持则分两步完成：</p>
<p><strong>1.每一个class产生一堆指向虚函数的指针，放在表格之中。这个表格称之为虚函数表（virtual
table，vtbl）。</strong></p>
<p><strong>2.每一个对象被添加了一个指针，指向相关的虚函数表vtbl。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的构造函数，析构函数和拷贝赋值运算符自动完成。</strong></p>
<p>另外，虚函数表地址的前面设置了一个指向type_info的指针，RTTI（Run Time
Type
Identification）运行时类型识别是有编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI是为多态而生成的信息，所以只有具有虚函数的对象在会生成。</p>
<p><strong><em>C++中虚函数使用虚函数表和
虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地
址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的
虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处），
它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应
不同基类的虚函数表。</em></strong></p>
<p>简单来讲是多态，也就是允许派生类对象指向基类指针在运行时调用调用派生类的同名函数。
原理：含有虚函数的类对象，在啊创建时会再头部创建一个指针，指向一个虚表，虚表内保存着虚函数的地址，当调用虚函数时，调用指针指向虚表，子啊虚表中找到虚函数的地址。从而实现运行时多态，普通的成员函数地址是固定的，直接调用即可。</p>
<h2><span id="overload-overwrite-ji-override-de-qu-bie">Overload、Overwrite及Override的区别</span><a href="#overload-overwrite-ji-override-de-qu-bie" class="header-anchor">#</a></h2>
<p>Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。
1. 相同的范围（在同一个类中）； 2. 函数名字相同； 3. 参数不同； 4.
virtual 关键字可有可无。</p>
<p>Override(覆盖)：是指派生类函数覆盖基类函数，特征是： 1.
不同的范围（分别位于派生类与基类）； 2. 函数名字相同； 3. 参数相同； 4.
基类函数必须有virtual 关键字。</p>
<p>Overwrite(重写)：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
1.
如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
2.
如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> void F()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;Parent.F()&#x2F;n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void G()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;Parent.G()&#x2F;n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int Add(int x, int y)</span><br><span class="line"> &#123;</span><br><span class="line">        return x + y;</span><br><span class="line"> &#125;</span><br><span class="line">    &#x2F;&#x2F;重载(overload)Add函数</span><br><span class="line"> float Add(float x, float y)</span><br><span class="line">   &#123;</span><br><span class="line">        return x + y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ChildOne:Parent</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;重写(overwrite)父类函数</span><br><span class="line"> void F()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;ChildOne.F()&#x2F;n&quot;); </span><br><span class="line"> &#125;</span><br><span class="line">    &#x2F;&#x2F;覆写(override)父类虚函数,主要实现多态</span><br><span class="line">  void G()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;ChildOne.G()&#x2F;n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> ChildOne childOne;&#x2F;&#x2F; &#x3D; new ChildOne();</span><br><span class="line"> Parent* p &#x3D; (Parent*)&amp;childOne;</span><br><span class="line">  &#x2F;&#x2F;调用Parent.F()</span><br><span class="line">  p-&gt;F();</span><br><span class="line">    &#x2F;&#x2F;实现多态</span><br><span class="line">  p-&gt;G();</span><br><span class="line">    Parent* p2 &#x3D; new Parent();</span><br><span class="line">   &#x2F;&#x2F;重载(overload)</span><br><span class="line">  printf(&quot;%d&#x2F;n&quot;,p2-&gt;Add(1, 2));</span><br><span class="line">   printf(&quot;%f&#x2F;n&quot;,p2-&gt;Add(3.4f, 4.5f));</span><br><span class="line"> delete p2;</span><br><span class="line">    system(&quot;PAUSE&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="overload-de-hua-zhi-you-han-shu-fan-hui-zhi-lei-xing-bu-tong-hui-chong-zai-ma">overload的话，只有函数返回值类型不同，会重载吗?</span><a href="#overload-de-hua-zhi-you-han-shu-fan-hui-zhi-lei-xing-bu-tong-hui-chong-zai-ma" class="header-anchor">#</a></h2>
<ol type="1">
<li><p>在使用重载时只能通过<strong>不同的参数样式</strong>。例如，<strong>不同的参数类型，不同的参数个数，不同的参数顺序</strong>（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,
float)， 但是不能为fun(int, int)）；</p></li>
<li><p>不能通过访问权限、返回类型、抛出的异常进行重载；</p></li>
<li><p>方法的异常类型和数目不会对重载造成影响；</p></li>
<li><p>对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p></li>
</ol>
<h2><span id="yi-ge-jie-gou-ti-zhong-you-yi-ge-int-yi-ge-char-yi-ge-static-int-wen-zhe-ge-jie-gou-ti-zhan-duo-shao-nei-cun">一个结构体中有一个int，一个char，一个static
int，问这个结构体占多少内存</span><a href="#yi-ge-jie-gou-ti-zhong-you-yi-ge-int-yi-ge-char-yi-ge-static-int-wen-zhe-ge-jie-gou-ti-zhan-duo-shao-nei-cun" class="header-anchor">#</a></h2>
<p>结构体 <strong>内存对齐规则</strong> 结构体所占用的内存
<strong>与其成员在结构体中的声明顺序有关</strong>，其成员的内存对齐规则如下：</p>
<ol type="1">
<li><p>每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。</p></li>
<li><p>复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，可以最小化长度。</p></li>
<li><p>结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。</p></li>
<li><p>计算结构体的内存大小时，应该列出每个成员的偏移地址，则其长度=最后一个成员的偏移地址+最后一个成员数的长度+最后一个成员的调整参数</p></li>
</ol>
<h2><span id="stl-zhong-you-shi-me-lei">STL中有什么类</span><a href="#stl-zhong-you-shi-me-lei" class="header-anchor">#</a></h2>
<p>https://blog.csdn.net/chuanzhouxiao/article/details/51902786
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector 向量 </span><br><span class="line">string 字符串</span><br><span class="line">list 列表</span><br><span class="line">queue 队列</span><br><span class="line">map 映射</span><br><span class="line">set 集合</span><br><span class="line">stack 栈</span><br><span class="line"></span><br><span class="line">map，vector和unordered_map区别及实现原理 </span><br><span class="line">红黑树 hash表 </span><br><span class="line">mysql索引 </span><br><span class="line">tcp三次握手 重传机制 </span><br></pre></td></tr></table></figure>
## 进程数据栈堆</p>
<h3><span id="1-jin-cheng-he-xian-cheng-de-ding-yi">1.进程和线程的定义</span><a href="#1-jin-cheng-he-xian-cheng-de-ding-yi" class="header-anchor">#</a></h3>
<ol type="1">
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</li>
<li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</li>
</ol>
<h3><span id="2-jin-cheng-he-xian-cheng-de-qu-bie">2.进程和线程的区别</span><a href="#2-jin-cheng-he-xian-cheng-de-qu-bie" class="header-anchor">#</a></h3>
<ol type="1">
<li>进程在执行过程中拥有独立的内存单元，而该进程的多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
<li>在很多现代操作系统中，一个进程的（虚）地址空间大小为4G，分为系统（内核？）空间和用户空间两部分，系统空间为所有进程共享，而用户空间是独立的，一般WINDOWS进程的用户空间为2G。</li>
<li>一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)，Windows线程的缺省堆栈大小为1M。堆(heap)的分配与栈有所不同，一般是一个进程有一个C运行时堆，这个堆为本进程中所有线程共享，windows进程还有所谓进程默认堆，用户也可以创建自己的堆。
用操作系统术语，线程切换的时候实际上切换的是一个可以称之为线程控制块的结构（TCB?）,里面保存所有将来用于恢复线程环境必须的信息，包括所有必须保存的寄存器集，线程的状态等。</li>
</ol>
<h3><span id="3-duo-xian-cheng-de-gua-yong-chang-jing-shi-shi-me-wei-sha-yao-yong-duo-xian-cheng">3.多线程的适用场景是什么？为啥要用多线程？</span><a href="#3-duo-xian-cheng-de-gua-yong-chang-jing-shi-shi-me-wei-sha-yao-yong-duo-xian-cheng" class="header-anchor">#</a></h3>
<p>使用多线程是为了
<strong>提高程序运行的效率</strong>。假如有一个程序，要求用户输入多个算式，计算出结果，并分别打印到屏幕上。如果用户一直没有输入，那么无法计算，更无法打印。如果用户输入了，必须要全部输入完，才能计算出结果，再打印到屏幕。
使用线程的话，一个线程用来等待用户输入，一个用来计算结果，一个用来打印。用户在输入算式3的时候，计算线程在计算算式2，打印线程在打印算式1，三个线程同时进行，减少了等待，这样就提高了运行效率</p>
<h3><span id="4-dui-he-zhan">4.堆和栈</span><a href="#4-dui-he-zhan" class="header-anchor">#</a></h3>
<p><strong>堆</strong>：是
<strong>共有的空间，分全局堆和局部堆</strong>。全局堆就是
<strong>所有没有分配的空间</strong>，局部堆就是
<strong>用户分配的空间</strong>。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得
<strong>用完了要还给操作系统，要不然就是内存泄漏</strong>。</p>
<p><strong>栈</strong>：是个
<strong>线程独有的</strong>，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread
safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。
函数调用栈堆</p>
<p>Top N排序 拷贝构造函数 复制构造函数 static 关键字</p>
<h2><span id="yuan-wen-jian-cpp-dao-ke-zhi-xing-wen-jian-exe-de-guo-cheng">源文件cpp到可执行文件exe的过程</span><a href="#yuan-wen-jian-cpp-dao-ke-zhi-xing-wen-jian-exe-de-guo-cheng" class="header-anchor">#</a></h2>
<p>从一个cpp文件到一个exe文件，大概经历了以下过程：</p>
<ol type="1">
<li><p>预处理（preprocessor）
根据预处理命令组装成新的C/C++程序，常以i为扩展名。这个过程包括：宏的替换、删除注释、处理预处理指令（如#include、#ifdef）。</p></li>
<li><p>编译（complier） 将得到的i文件翻译成汇编代码，即.s文件。</p></li>
<li><p>汇编（assembler）
将汇编文件翻译成机器指令，并打包成可重定位目标程序的o文件。该文件是二进制文件，字节编码是机器指令。编译器把一个cpp编译汇编得到目标文件时，除了要在目标文件里写入cpp里包含的数据和代码，还要至少提供3个表：</p></li>
</ol>
<ul>
<li>未解决符号表（unresolved symbol
table）：提供所有在编译单元里引用但定义不在本编译单元里的符号及其出现的地址；</li>
<li>导出符号表（export symbol
table）：提供本编译单元具有定义，且愿意提供给其它编译单元使用的符号及其地址（全局作用域）；</li>
<li>地址重定向表（address redirect
table）：提供本编译单元所有对自身地址的引用的记录。</li>
</ul>
<ol start="4" type="1">
<li>链接（linker）
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或函数调用）或程序中可能调用了某个库文件中的函数。将引用的其它o文件并入到我们程序所在的o文件中并进行处理，方可得到最终的可执行文件。
链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定向表，对其中记录的地址进行重定向（即加上该编译单元实际在可执行文件里的起始地址）。然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上填写实际的地址（也要加上拥有该符号定义的编译单元实际在可执行文件里的起始地址）。最后把所有的目标文件的内容写在各自的位置上，再做一些别的工作，即得到一个可执行文件。
PS：实际链接的时候更为复杂，因为实际的目标文件里把数据或代码分为好几个区，重定向等要按区进行，但原理一样。</li>
</ol>
<ul>
<li>内部链接：一个名称对编译单元（cpp文件）来说是局部的，在链接的时候其它的编译单元无法链接到它；</li>
<li>外部链接：一个名称对编译单元来说不是局部的，在链接的时候其它的编译单元可以访问它，即它可以和别的编译单元交互。</li>
</ul>
<h2><span id="const-he-define">const和define</span><a href="#const-he-define" class="header-anchor">#</a></h2>
<p>const定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量，存放在静态区)，而#define定义的宏常量在内存中有若干个拷贝。
#define宏是在预编译阶段进行替换，而const修饰的只读变量是在编译的时候确定其值。
#define宏没有类型，而const修饰的只读变量具有特定的类型
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int *p;   &#x2F;&#x2F;p可变，p指向的对象不可变</span><br><span class="line">int const*p;  &#x2F;&#x2F;p可变，p指向的对象不可变</span><br><span class="line">int *const p;  &#x2F;&#x2F;p不可变，p指向的对象可变</span><br><span class="line">const int *const p;  &#x2F;&#x2F;指针p和p指向的对象都不可变</span><br></pre></td></tr></table></figure>
总的来说： const：有数据类型，编译进行安全检查，可调试
define:宏，不考虑数据类型，没有安检，不能调试</p>
<p>这里有一个记忆和理解的方法：
先忽略类型名(编译器解析的时候也是忽略类型名)，我们看const离哪个近。"近水楼台先得月"，离谁近就修饰谁。
判断时忽略括号中的类型
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const (int) *p;   &#x2F;&#x2F;const修饰*p，*p是指针指向的对象，不可变</span><br><span class="line">(int) const *p；  &#x2F;&#x2F;const修饰*p，*p是指针指向的对象，不可变</span><br><span class="line">(int)*const p;   &#x2F;&#x2F;const修饰p，p不可变，p指向的对象可变</span><br><span class="line">const (int) *const p;  &#x2F;&#x2F;前一个const修饰*p，后一个const修饰p，指针p和p指向的对象都不可变</span><br></pre></td></tr></table></figure>
## C++ 异常机制分析 http://www.cnblogs.com/QG-whz/p/5136883.html</p>
<h2><span id="new-he-malloc-de-qu-bie">new和malloc的区别</span><a href="#new-he-malloc-de-qu-bie" class="header-anchor">#</a></h2>
<p>https://www.cnblogs.com/engraver-lxw/p/8600816.html 1.
申请的内存所在位置 　　new操作符从自由存储区（free
store）上为对象动态分配内存空间，而malloc函数从<strong>堆上动态分配内存</strong>。
2. 返回类型安全性
　　new操作符内存分配成功时，<strong>返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符</strong>。而malloc内存分配成功则是**返回void
* ，需要通过强制类型转换将void*指针转换成我们需要的类型**。</p>
<ol start="3" type="1">
<li>内存分配失败时的返回值
　　new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</li>
</ol>
<p>在使用C语言时，我们习惯
<strong>在malloc分配内存后判断分配是否成功</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int *a  &#x3D; (int *)malloc ( sizeof (int ));</span><br><span class="line">if(NULL &#x3D;&#x3D; a)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
但是
<strong>对于new实际上这样做一点意义也没有</strong>，因为new根本不会返回NULL，而且
<strong>程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    int *a &#x3D; new int();</span><br><span class="line">&#125;</span><br><span class="line">catch (bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li>是否需要指定内存大小 使用
<strong>new操作符申请内存分配时无须指定内存块的大小</strong>，编译器会根据类型信息自行计算，而
<strong>malloc则需要显式地指出所需内存的尺寸</strong>。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;...&#125;</span><br><span class="line">A * ptr &#x3D; new A;</span><br><span class="line">A * ptr &#x3D; (A *)malloc(sizeof(A)); &#x2F;&#x2F;需要显式指定所需内存大小sizeof(A);</span><br></pre></td></tr></table></figure></li>
<li>是否调用构造函数/析构函数
使用new操作符来分配对象内存时会经历三个步骤：</li>
</ol>
<ul>
<li>第一步：调用operator new 函数（对于数组是operator
new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li>
<li>第二步：编译器运行
<strong>相应的构造函数以构造对象，并为其传入初值</strong>。</li>
<li>第三步：对象构造完成后，<strong>返回一个指向该对象的指针</strong>。</li>
</ul>
<p>使用delete操作符来释放对象内存时会经历两个步骤： - 第一步：调用
<strong>对象的析构函数</strong>。 - 第二步：编译器 <strong>调用operator
delete(或operator delete[])函数释放内存空间</strong>。</p>
<p>总之来说，<strong>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构</strong>。而
<strong>malloc则不会</strong>。</p>
<ol start="6" type="1">
<li>对数组的处理 C++提供了new[]与delete[]来专门处理数组类型:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A * ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个A对象</span><br></pre></td></tr></table></figure>
使用new[]分配的内存必须使用delete[]进行释放：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] ptr;</span><br></pre></td></tr></table></figure>
new对数组的支持体现在它会<strong>分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏</strong>。至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * ptr &#x3D; (int *) malloc( sizeof(int)* 10 );&#x2F;&#x2F;分配一个10个int元素的数组</span><br></pre></td></tr></table></figure></li>
<li>new与malloc是否可以相互调用 operator new /operator
delete的实现可以基于malloc，而
<strong>malloc的实现不可以去调用new</strong>。下面是编写operator new
/operator delete 的一种简单方式，其他版本也与之类似：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> void * operator new (sieze_t size)</span><br><span class="line"> &#123;</span><br><span class="line">     if(void * mem &#x3D; malloc(size)</span><br><span class="line">         return mem;</span><br><span class="line">     else</span><br><span class="line">         throw bad_alloc();</span><br><span class="line"> &#125;</span><br><span class="line"> void operator delete(void *mem) noexcept</span><br><span class="line"> &#123;</span><br><span class="line">    free(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="zhi-zhen-dui-qi">指针对齐</span><a href="#zhi-zhen-dui-qi" class="header-anchor">#</a></h2>
<p>以下代码打印的结果是（假设运行在 64 位计算机上）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct st_t &#123;</span><br><span class="line">    int status;</span><br><span class="line">    short *pdata;</span><br><span class="line">    char errstr[32]; </span><br><span class="line">&#125;;</span><br><span class="line">st_t st[16];</span><br><span class="line">char *p&#x3D;(char *)(st[2].esstr+32);</span><br><span class="line">printf(“%d”,(p-(char *)(st)));</span><br></pre></td></tr></table></figure></p>
<p>根据字节对齐，在64位系统下struct st_t 结构体占用的字节为48个。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct st_t &#123; </span><br><span class="line">int status;  &#x2F;&#x2F;占用8个（后面的4个为对齐位） </span><br><span class="line">short *pdata;&#x2F;&#x2F;占用8个 </span><br><span class="line">char errstr[32];&#x2F;&#x2F;占用32个 </span><br><span class="line">&#125;; </span><br><span class="line">char *p&#x3D;(char *)(st[2].esstr+32)，p实际指向了st[3] </span><br><span class="line">则p-(char *)(st))，即为&amp;st[3]-&amp;st[0],占用空间为3个结构体的大小，即3*48&#x3D;144</span><br></pre></td></tr></table></figure></p>
<h2><span id="kong-lei-de-sizeof-da-xiao-you-yi-ge-xu-han-shu-de-lei-de-sizeof">空类的sizeof大小，有一个虚函数的类的sizeof</span><a href="#kong-lei-de-sizeof-da-xiao-you-yi-ge-xu-han-shu-de-lei-de-sizeof" class="header-anchor">#</a></h2>
<p>https://blog.csdn.net/foreverhuylee/article/details/39320977
题目（二）：运行下面的代码，输出是什么？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        B() &#123;&#125;</span><br><span class="line">~B() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        C() &#123;&#125;</span><br><span class="line">        virtual ~C() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d, %d, %d\n&quot;, sizeof(A), sizeof(B), sizeof(C));</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><p>答案是1, 1, 4。class
A是一个空类型，它的实例不包含任何信息，本来求sizeof应该是0。但当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual
Studio 2008中每个空类型的实例占用一个byte的空间。</p></li>
<li><p>class B在class
A的基础上添加了构造函数和析构函数。由于构造函数和析构函数的调用与类型的实例无关（调用它们只需要知道函数地址即可），在它的实例中不需要增加任何信息。所以sizeof(B)和sizeof(A)一样，在Visual
Studio 2008中都是1。</p></li>
<li><p>class C在class
B的基础上把析构函数标注为虚拟函数。C++的编译器一旦发现一个类型中有虚拟函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4个字节的空间，因此sizeof(C)是4。</p></li>
</ol>
<h2><span id="zhi-chuan-di-yin-yong-chuan-di">值传递，引用传递</span><a href="#zhi-chuan-di-yin-yong-chuan-di" class="header-anchor">#</a></h2>
<p>值传递---单向传递 swap(int a,int b) 引用传递 ----双向传递 swap(int
&amp;a,int &amp;b)<br>
<strong>引用即别名，必须初始化</strong></p>
<h2><span id="nei-lian-han-shu-inline">内联函数 inline</span><a href="#nei-lian-han-shu-inline" class="header-anchor">#</a></h2>
<p>作用：可避免函数调用的开销
注：<strong>内联函数只是对编译器发送一个请求，编译器可以忽略该请求</strong>
一般用于<strong>优化规模小，流程直接，频繁调用的函数</strong></p>
<ol type="1">
<li>内联函数体内不能有循环语句和switch语句</li>
<li>内联函数定义必须在内联函数第一次调用之前</li>
<li>对内联函数不能进行异常接口声明</li>
</ol>
<h2><span id="constexpr-han-shu">constexpr函数</span><a href="#constexpr-han-shu" class="header-anchor">#</a></h2>
<p>指能用于常量表达式的函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constexpr int getsize() &#123;</span><br><span class="line">  return 20;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"> constexpr int foo &#x3D; getsize(); &#x2F;&#x2F;foo是常量表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## 常量表达式 值不会改变并且编译过程就能得到计算结果的表达式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int max_files&#x3D;20; &#x2F;&#x2F;常量表达式</span><br><span class="line">const int limit&#x3D;max_files+1; &#x2F;&#x2F;常量表达式</span><br><span class="line">int staff_size&#x3D;27; &#x2F;&#x2F;不是常量表达式</span><br></pre></td></tr></table></figure></p>
<h2><span id="mo-ren-can-shu-zhi">默认参数值</span><a href="#mo-ren-can-shu-zhi" class="header-anchor">#</a></h2>
<p>有默认参数的形参必须<strong>列在函数形参列表的最右端</strong>
调用实参与形参结合的次序是<strong>从左到右</strong>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int add(int x,int y&#x3D;5,int z&#x3D;6);&#x2F;&#x2F;正确</span><br><span class="line">add(1)&#x3D;12;</span><br><span class="line">add(1,2)&#x3D;9;</span><br><span class="line"></span><br><span class="line">int add(int x&#x3D;1,int y&#x3D;5,int z);&#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/02/%E8%AE%A1%E7%BD%91-http%E4%B9%8BGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/" rel="prev" title="[计网]http之GET和POST区别">
      <i class="fa fa-chevron-left"></i> [计网]http之GET和POST区别
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/" rel="next" title="[python源码分析] 5.bytes">
      [python源码分析] 5.bytes <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">拷贝构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">深拷贝和浅拷贝：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">一个空的class类里有什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">虚函数的作用以及实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">Overload、Overwrite及Override的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">overload的话，只有函数返回值类型不同，会重载吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">一个结构体中有一个int，一个char，一个static
int，问这个结构体占多少内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">8.</span> <span class="nav-text">STL中有什么类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">8.1.</span> <span class="nav-text">1.进程和线程的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">8.2.</span> <span class="nav-text">2.进程和线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">8.3.</span> <span class="nav-text">3.多线程的适用场景是什么？为啥要用多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">8.4.</span> <span class="nav-text">4.堆和栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">9.</span> <span class="nav-text">源文件cpp到可执行文件exe的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">10.</span> <span class="nav-text">const和define</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">11.</span> <span class="nav-text">new和malloc的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">12.</span> <span class="nav-text">指针对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">13.</span> <span class="nav-text">空类的sizeof大小，有一个虚函数的类的sizeof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">14.</span> <span class="nav-text">值传递，引用传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">15.</span> <span class="nav-text">内联函数 inline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">16.</span> <span class="nav-text">constexpr函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">17.</span> <span class="nav-text">默认参数值</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liu Wen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sysuleo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sysuleo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/leo666-40" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;leo666-40" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>zhihu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Wen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'e06a4b8906757c42331f',
      clientSecret: '5b0fe4dc7f1d7b47ea86f07155d29e5824e5dc9a',
      repo        : 'mygitalk',
      owner       : 'sysuleo',
      admin       : ['sysuleo'],
      id          : 'a9c0680ed8083d24d783724ec194b973',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
