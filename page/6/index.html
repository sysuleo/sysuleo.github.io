<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-uUIis3aZOy">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LiuWen&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="LiuWen&#39;s Blogs">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liu Wen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>LiuWen's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LiuWen's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/" class="post-title-link" itemprop="url">[python源码分析] 5.bytes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-06 10:35:41" itemprop="dateCreated datePublished" datetime="2020-12-06T10:35:41+08:00">2020-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">python源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于一个字节8bit最多只能表示 <strong>256
种字符</strong>，用来表示英文字符绰绰有余，想覆盖非英文字符便捉襟见肘了。为了表示众多的非英文字符(比如汉字)，计算机先驱们发明了
<strong>多字节编码</strong> ——通过
<strong>多个字节来表示一个字符</strong>。由于
<strong>原始字节序列不维护编码信息</strong>，操作不慎便导致各种乱码现象。</p>
<p>Python 提供的解决方案是 <strong>Unicode 字符串 ( str )对象</strong>，
Unicode
可以表示各种字符，无需关心编码。然而存储或者网络通讯时，字符串对象不可避免要
<strong>序列化 成字节序列</strong>。为此， Python 额外提供了
<strong>字节序列对象—— bytes</strong> 。</p>
<div style="width:100%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/str_and_bytes.jpg" class title="str_and_bytes图">
</div>
<p>如上图， str 对象统一表示一个 <strong>字符串</strong>
，不需要关心编码；计算机通过 <strong>字节序列
与存储介质和网络介质打交道</strong>，字节序列由 <strong>bytes
对象</strong>表示；存储或传输 str 对象时，需要将其
<strong>序列化</strong> 成字节序列，序列化过程也是 <strong>编码</strong>
的过程。</p>
<h2><span id="dui-xiang-jie-gou">对象结构</span><a href="#dui-xiang-jie-gou" class="header-anchor">#</a></h2>
<p>bytes 对象用于表示由若干字节组成的 字节序列 以及相关的 操作
，并不关心字节序列的 含义 。因此， bytes 应该一种 <strong>变长 、
不可变</strong> 对象 ，内部由 <strong>C 数组</strong> 实现。如下图:</p>
<div style="width:100%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/bytes_head.png" class title="bytes_head图">
</div>
<ol type="1">
<li><p>ob_sval 字节序列对象 PyBytesObject 中，确实藏着一个字符数组
ob_sval 。注意到 <strong>ob_sval 数组长度定义为 1</strong> ，这是 C
语言中定义 <strong>变长数组</strong>
的技巧（ob_sval存储的是地址）。</p></li>
<li><p>ob_snash <strong>ob_shash</strong> ，它用于保存字节序列的 哈希值
。 由于计算 <strong>bytes
对象哈希值需要遍历其内部的字符数组</strong>，开销相对较大。因此， Python
<strong>第一次计算</strong> 哈希值时，选择 将哈希值缓存到
<strong>ob_shash字段</strong>中，以
<strong>空间换时间</strong>，避免重复计算。</p></li>
<li><p>ob_size 每个PyVarObject内部都有个
<strong>ob_size</strong>字段，PyBytesObject使用此字段存储大小信息以
<strong>保持len（）操作的O（1）时间复杂度</strong>，并跟踪非ascii字符串的大小（内部可以为空字符）</p></li>
</ol>
<h3><span id="kong-dui-xiang-yang-li">空对象样例</span><a href="#kong-dui-xiang-yang-li" class="header-anchor">#</a></h3>
<div style="width:100%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/bytes_empty.png" class title="bytes_empty图">
</div>
<p>Python 为待存储的字节序列 <strong>额外分配一个字节，用于在末尾处保存
\0 ，以便兼容 C 字符串</strong>。从上图可以看出，就算空 bytes 对象( b''
)也是要占用内存空间的，至少变长对象 公共头部 是少不了的。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sys.getsizeof(b&#39;&#39;)</span><br><span class="line">33</span><br></pre></td></tr></table></figure></p>
<p>bytes 对象占用的内存空间可分为以下个部分进行计算：</p>
<ul>
<li>PyVarObject公共头部 24 字节，ob_refcnt 、 ob_type 、 ob_size
每个字段各占用 8 字节；</li>
<li>哈希值 ob_shash 占用 8 字节；</li>
<li>字节序列本身，假设是 n 字节；</li>
<li>额外 1 字节用于存储末尾处的 \0 ；</li>
</ul>
<p>因此，bytes 对象空间计算公式为 24+8+n+124+8+n+1，即 33+n33+n，其中 n
为字节序列长度(也是len的取值)。 经过上面的学习，我们可以知道
<strong>len(byte对象) = n</strong>，len显示的只是
<strong>ob_size字段</strong>的值，而bytes对象真实占用内存量还
<strong>需要加 33</strong>.</p>
<h3><span id="ascii-yang-li">ascii样例</span><a href="#ascii-yang-li" class="header-anchor">#</a></h3>
<div style="width:100%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/bytes_ascii.png" class title="bytes_ascii图">
</div>
<h2><span id="dui-xiang-xing-wei">对象行为</span><a href="#dui-xiang-xing-wei" class="header-anchor">#</a></h2>
<p>对象的行为由对象的 <strong>类型</strong> 决定，因而我们需要到 bytes
类型对象(PyBytes_Type)中寻找答案。在
<strong>Objects/bytesobject.c</strong> 源码文件中，我们找到 bytes
类型对象 的定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyBytes_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;bytes&quot;,</span><br><span class="line">    PyBytesObject_SIZE,</span><br><span class="line">    sizeof(char),</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &amp;bytes_as_number,                           &#x2F;* tp_as_number 保存着 数值运算 处理函数的指针*&#x2F;</span><br><span class="line">    &amp;bytes_as_sequence,                         &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    &amp;bytes_as_mapping,                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc)bytes_hash,                       &#x2F;* tp_hash *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
bytes 对象居然支持数据操作？bytes_as_number 结构体中只定义了一个操作——
模运算 ( % )：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static PyNumberMethods bytes_as_number &#x3D; &#123;</span><br><span class="line">    0,              &#x2F;*nb_add*&#x2F;</span><br><span class="line">    0,              &#x2F;*nb_subtract*&#x2F;</span><br><span class="line">    0,              &#x2F;*nb_multiply*&#x2F;</span><br><span class="line">    bytes_mod,      &#x2F;*nb_remainder*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">static PyObject *</span><br><span class="line">bytes_mod(PyObject *self, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    if (!PyBytes_Check(self)) &#123;</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;实现字符串格式化</span><br><span class="line">    return _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),</span><br><span class="line">                             arg, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由此可见， bytes 对象只是 <strong>借用 %
运算符实现字符串格式化</strong>，谈不上支持数值运算，虚惊一场：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;msg: a&#x3D;%d b&#x3D;%d&#39; % (1, 2)</span><br><span class="line">b&#39;msg: a&#x3D;1 b&#x3D;2&#39;</span><br></pre></td></tr></table></figure></p>
<h2><span id="xu-lie-xing-cao-zuo">序列型操作</span><a href="#xu-lie-xing-cao-zuo" class="header-anchor">#</a></h2>
<p>众所周知， <strong>bytes 是 序列型对象</strong>
，序列型操作才是研究重点。我们在 bytes_as_sequence
结构体中找到相关定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static PySequenceMethods bytes_as_sequence &#x3D; &#123;</span><br><span class="line">    (lenfunc)bytes_length, &#x2F;*sq_length*&#x2F;</span><br><span class="line">    (binaryfunc)bytes_concat, &#x2F;*sq_concat*&#x2F;</span><br><span class="line">    (ssizeargfunc)bytes_repeat, &#x2F;*sq_repeat*&#x2F;</span><br><span class="line">    (ssizeargfunc)bytes_item, &#x2F;*sq_item*&#x2F;</span><br><span class="line">    0,                  &#x2F;*sq_slice*&#x2F;</span><br><span class="line">    0,                  &#x2F;*sq_ass_item*&#x2F;</span><br><span class="line">    0,                  &#x2F;*sq_ass_slice*&#x2F;</span><br><span class="line">    (objobjproc)bytes_contains &#x2F;*sq_contains*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
由此可见， bytes 支持的 序列型操作 包括以下 5 个： - sq_length
，查询序列长度； - sq_concat ，将两个序列合并为一个； - sq_repeat
，将序列重复多次； - sq_item ，取出给定下标序列元素； -
sq_contains，包含关系判断；</p>
<h3><span id="chang-du">长度</span><a href="#chang-du" class="header-anchor">#</a></h3>
<p>最简单的序列型操作是 长度查询 ，直接返回 ob_size 字段即可：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static Py_ssize_t</span><br><span class="line">bytes_length(PyBytesObject *a)</span><br><span class="line">&#123;</span><br><span class="line">    return Py_SIZE(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="he-bing">合并</span><a href="#he-bing" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;abc&#39; + b&#39;cba&#39;</span><br><span class="line">b&#39;abccba&#39;</span><br></pre></td></tr></table></figure>
<p>合并操作将两个 bytes 对象拼接成一个，由 bytes_concat 函数处理：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">bytes_concat(PyObject *a, PyObject *b)</span><br><span class="line">&#123;</span><br><span class="line">    Py_buffer va, vb;   &#x2F;&#x2F;定义局部变量 va 、 vb 用于维护缓冲区</span><br><span class="line">    PyObject *result &#x3D; NULL;  &#x2F;&#x2F;新建临时变量，保存合并结果</span><br><span class="line"></span><br><span class="line">    va.len &#x3D; -1;</span><br><span class="line">    vb.len &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F;获取字节序列所在缓冲区</span><br><span class="line">    if (PyObject_GetBuffer(a, &amp;va, PyBUF_SIMPLE) !&#x3D; 0 ||</span><br><span class="line">        PyObject_GetBuffer(b, &amp;vb, PyBUF_SIMPLE) !&#x3D; 0) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError, &quot;can&#39;t concat %.100s to %.100s&quot;,</span><br><span class="line">                     Py_TYPE(b)-&gt;tp_name, Py_TYPE(a)-&gt;tp_name);</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Optimize end cases *&#x2F;</span><br><span class="line">    if (va.len &#x3D;&#x3D; 0 &amp;&amp; PyBytes_CheckExact(b)) &#123;  &#x2F;&#x2F;如果第一个对象长度为 0 ，第二个对象就是结果</span><br><span class="line">        result &#x3D; b;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line">    if (vb.len &#x3D;&#x3D; 0 &amp;&amp; PyBytes_CheckExact(a)) &#123;    &#x2F;&#x2F;第二个对象长度为 0 ，第一个对象就是结果</span><br><span class="line">        result &#x3D; a;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (va.len &gt; PY_SSIZE_T_MAX - vb.len) &#123;   &#x2F;&#x2F;长度超过限制则报错</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result &#x3D; PyBytes_FromStringAndSize(NULL, va.len + vb.len);  &#x2F;&#x2F;临时 bytes 对象用于保存合并结果，长度为待合并对象长度之和</span><br><span class="line">    if (result !&#x3D; NULL) &#123;</span><br><span class="line">        memcpy(PyBytes_AS_STRING(result), va.buf, va.len);</span><br><span class="line">        memcpy(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    if (va.len !&#x3D; -1)</span><br><span class="line">        PyBuffer_Release(&amp;va);</span><br><span class="line">    if (vb.len !&#x3D; -1)</span><br><span class="line">        PyBuffer_Release(&amp;vb);</span><br><span class="line">    return result;  &#x2F;&#x2F;返回结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
bytes_concat 函数逻辑很直白，<strong>将两个 bytes
对象的缓冲区</strong>拷贝到一起形成新 bytes 对象。</p>
<h3><span id="shu-ju-kao-bei-de-xian-jing">数据拷贝的陷阱</span><a href="#shu-ju-kao-bei-de-xian-jing" class="header-anchor">#</a></h3>
<p>考察以下表达式——合并 3 个 bytes 对象：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; result &#x3D; a + b + c</span><br></pre></td></tr></table></figure>
这个语句执行时，分成两步进行合并：先将 a 和 b 合并，得到临时结果 t
，再将 t 和 c 合并得到最终结果 result ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; a + b</span><br><span class="line">&gt;&gt;&gt; result &#x3D; t + c</span><br></pre></td></tr></table></figure>
这个过程中，<strong>a 和 b 的数据需要被拷贝两遍</strong>！</p>
<div style="width:100%;margin:auto">

</div>
<p>合并 <strong>n 个 bytes 对象，头两个对象需要拷贝 n-1</strong>
次，只有最后一个对象不需要重复拷贝。平均下来，每个对象大约要拷贝
<strong>n/2</strong> 次！</p>
<h3><span id="nei-jian-fang-fa-join">内建方法 join</span><a href="#nei-jian-fang-fa-join" class="header-anchor">#</a></h3>
bytes 对象提供了一个内建方法 join ，可高效合并多个 bytes 对象：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; result &#x3D; b&#39;&#39;.join(segments)</span><br></pre></td></tr></table></figure>
join
方法对数据拷贝进行了优化：<strong>先遍历待合并对象</strong>，<strong>计算总长度</strong>；然后根据总长度
<strong>创建目标对象</strong>；最后再
<strong>遍历待合并对象</strong>，逐一拷贝数据。这样一来，每个对象均只需拷贝一次，解决了重复拷贝的陷阱。
<div style="width:100%;margin:auto">

</div>
<h2><span id="zi-fu-huan-chong-chi">字符缓冲池</span><a href="#zi-fu-huan-chong-chi" class="header-anchor">#</a></h2>
<p>为了优化单字节 <strong>bytes</strong> 对象(也可称为 字符对象
)的创建效率， Python 内部维护了一个 字符缓冲池 ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static PyBytesObject *characters[UCHAR_MAX + 1];</span><br></pre></td></tr></table></figure>
Python 内部 <strong>创建单字节 bytes</strong>
对象时，先检查目标对象是否已在缓冲池中。PyBytes_FromStringAndSize
函数是负责创建 bytes 对象的通用接口，同样位于
<strong>Objects/bytesobject.c</strong> 中：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    if (size &lt; 0) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">            &quot;Negative size passed to PyBytes_FromStringAndSize&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果目标对象为 单字节对象 且 已在字符缓冲池 中，直接返回已缓存对象</span><br><span class="line">    if (size &#x3D;&#x3D; 1 &amp;&amp; str !&#x3D; NULL &amp;&amp;</span><br><span class="line">        (op &#x3D; characters[*str &amp; UCHAR_MAX]) !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">#ifdef COUNT_ALLOCS</span><br><span class="line">        one_strings++;</span><br><span class="line">#endif</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        return (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建新 bytes 对象并拷贝字节序列</span><br><span class="line">    op &#x3D; (PyBytesObject *)_PyBytes_FromSize(size, 0);</span><br><span class="line">    if (op &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    if (str &#x3D;&#x3D; NULL)</span><br><span class="line">        return (PyObject *) op;</span><br><span class="line"></span><br><span class="line">    memcpy(op-&gt;ob_sval, str, size);</span><br><span class="line">    &#x2F;* share short strings *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果创建的对象为单字节对象，将其放入字符缓冲池</span><br><span class="line">    if (size &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] &#x3D; op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由此可见，当 Python 程序
<strong>开始运行时</strong>，<strong>字符缓冲池是空的</strong>。随着
<strong>单字节 bytes
对象</strong>的创建，缓冲池中的对象慢慢多了起来。</p>
<p>字符对象
<strong>首次创建后便在缓冲池中缓存起来</strong>；后续再次使用时，
<strong>Python 直接从缓冲池中取</strong>，避免重复创建和销毁。与 小整数
一样，字符对象 <strong>只有为数不多的 256
个</strong>，但使用频率非常高。缓冲池技术作为一种
<strong>以空间换时间</strong> 的优化手段，只需
<strong>较小的内存为代价</strong>，便可明显提升执行效率。</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/read/76/article/1905" title="Python 源码深度剖析/09 bytes 对象，不可变的字节序列">Python
源码深度剖析/09 bytes 对象，不可变的字节序列</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zpoint/CPython-Internals/blob/master/BasicObject/bytes/bytes.md" title="bytes">bytes</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/05/c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/05/c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/" class="post-title-link" itemprop="url">[c++]基础知识一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-05 11:22:17" itemprop="dateCreated datePublished" datetime="2020-12-05T11:22:17+08:00">2020-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2><span id="gou-zao-han-shu">构造函数</span><a href="#gou-zao-han-shu" class="header-anchor">#</a></h2>
<ol type="1">
<li>函数名与类名相同</li>
<li>不能定义返回值，也不能有return语句</li>
<li>可以有形式参数，也可以没有</li>
<li>可以是内联函数</li>
<li>可以重载</li>
<li>可以带默认参数值</li>
<li>对象被创建时自动调用</li>
<li>如果不定义构造函数，编译器编译阶段会生成默认构造函数</li>
<li>如果此时希望编译器隐含生成默认构造函数，只需加上=default</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Clock &#123;</span><br><span class="line">public:</span><br><span class="line">    Clock(int h, int m, int s);</span><br><span class="line">   Clock(); &#x2F;&#x2F;默认构造函数</span><br><span class="line">   void setTime(int h, int m, int s);</span><br><span class="line">    void showTime();</span><br><span class="line">private:</span><br><span class="line">    int hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock() : hour(0), minute(0), second(0) &#123;&#125;&#x2F;&#x2F;默认构造函数，用初始化列表，但是没用形参</span><br><span class="line">Clock::Clock(int h,int m,int s):hour(h),minute(m),second(s)&#123;&#125; </span><br><span class="line">&#x2F;&#x2F;用初始列表初始化hour，minute，second三个成员变量，效率高，简单初始化无需写在结构体里面</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  Clock c1(0,1,8); &#x2F;&#x2F;调用构造函数</span><br><span class="line">   Clock c2; &#x2F;&#x2F;调用无参构造函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="wei-tuo-gou-zao-han-shu">委托构造函数</span><a href="#wei-tuo-gou-zao-han-shu" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock::Clock(int h,int m,int s):hour(h),minute(m),second(s)&#123;&#125; </span><br><span class="line">Clock::Clock() : hour(0), minute(0), second(0) &#123;&#125;&#x2F;&#x2F;默认构造函数，用初始化列表，但是没用形参</span><br><span class="line"></span><br><span class="line">委托构造函数不仅可以简洁，而且保证代码一致性</span><br><span class="line">Clock::Clock():Clock(0,0,0)&#123;&#125;  &#x2F;&#x2F;默认构造函数用委托构造函数构造</span><br></pre></td></tr></table></figure>
<h3><span id="kao-bei-gou-zao-han-shu">拷贝构造函数</span><a href="#kao-bei-gou-zao-han-shu" class="header-anchor">#</a></h3>
<p>特殊的构造函数，其<strong>形参为本类对象的引用</strong>,
<strong>用一个已存在的对象去初始化同类型的新对象</strong> 1.
定义一个对象，以本类
<strong>另一个对象作为初始值，发送拷贝构造函数</strong> 2.
如果函数的形参时类的对象，调用函数时，将使用实参对象初始化形参对象 3.
如果函数的
<strong>返回值是类的对象，函数执行完返回主调函数时，将使用return语句中的对象初始化一个临时无名对象</strong>，传递给主调i函数
4. C++11用"=delete"指示编译器不生成默认复制构造函数<strong> 5.
</strong>拷贝构造函数是一种特殊的构造函数<strong>，具有
</strong>单个形参<strong>，该形参（常用const修饰）是
</strong>对该类类型的引用<strong>。 6.
当定义一个新对象并用一个同类型的对象对它进行初始化时，将
</strong>显示使用拷贝构造函数<strong>。当该类型的对象传递给函数或从函数返回该类型的对象时，将
</strong>隐式调用拷贝构造函数**。</p>
<p>C++支持两种初始化形式：复制初始化（int a = 5;）和直接初始化（int
a(5);）对于类
<strong>类型直接初始化直接调用实参匹配的构造函数</strong>，<strong>复制初始化总是调用拷贝构造函数</strong>，也就是说：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A x(2);　　&#x2F;&#x2F;直接初始化，调用构造函数</span><br><span class="line">A y &#x3D; x;　　&#x2F;&#x2F;复制初始化，调用拷贝构造函数</span><br></pre></td></tr></table></figure></p>
<p>下面使用上面定义的类对象来说明各个构造函数的用法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 1 void main()</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     &#x2F;&#x2F; 调用了无参构造函数，数据成员初值被赋为0.0</span><br><span class="line"> 4     Complex c1，c2;</span><br><span class="line"> 5  </span><br><span class="line"> 6     &#x2F;&#x2F; 调用一般构造函数，数据成员初值被赋为指定值</span><br><span class="line"> 7     Complex c3(1.0,2.5);</span><br><span class="line"> 8     &#x2F;&#x2F; 也可以使用下面的形式</span><br><span class="line"> 9     Complex c3 &#x3D; Complex(1.0,2.5);</span><br><span class="line">10          </span><br><span class="line">11     &#x2F;&#x2F; 把c3的数据成员的值赋值给c1</span><br><span class="line">12     &#x2F;&#x2F; 由于c1已经事先被创建，故此处不会调用任何构造函数</span><br><span class="line">13     &#x2F;&#x2F; 只会调用 &#x3D; 号运算符重载函数</span><br><span class="line">14     c1 &#x3D; c3;</span><br><span class="line">15          </span><br><span class="line">16     &#x2F;&#x2F; 调用类型转换构造函数</span><br><span class="line">17     &#x2F;&#x2F; 系统首先调用类型转换构造函数，将5.2创建为一个本类的临时对象，然后调用等号运算符重载，将该临时对象赋值给c1</span><br><span class="line">18     c2 &#x3D; 5.2;</span><br><span class="line">19        </span><br><span class="line">20     &#x2F;&#x2F; 调用拷贝构造函数( 有下面两种调用方式) </span><br><span class="line">21     Complex c5(c2);</span><br><span class="line">22     Complex c4 &#x3D; c2;  &#x2F;&#x2F; 注意和 &#x3D; 运算符重载区分,这里等号左边的对象不是事先已经创建，故需要调用拷贝构造函数，参数为c2       </span><br><span class="line">23          </span><br><span class="line">24 &#125;</span><br></pre></td></tr></table></figure>
参考：http://www.cnblogs.com/xkfz007/archive/2012/05/11/2496447.html</p>
<h2><span id="shen-kao-bei-he-qian-kao-bei">深拷贝和浅拷贝：</span><a href="#shen-kao-bei-he-qian-kao-bei" class="header-anchor">#</a></h2>
<ol type="1">
<li><p>所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。</p></li>
<li><p>在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间</p></li>
</ol>
<p>如果一个类拥有资源，当这个<strong>类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝</strong></p>
<p>上面提到，如果没有自定义拷贝构造函数，则系统会创建默认的拷贝构造函数，但系统创建的
<strong>默认拷贝构造函数只会执行“浅拷贝”</strong>，即将被拷贝对象的数据成员的值一一赋值给新创建的对象，若该类的数据成员中
<strong>有指针成员，则会使得新的对象的指针所指向的地址与被拷贝对象的指针所指向的地址相同，delete该指针时则会导致两次重复delete而出错</strong>。下面是示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include &lt;iostream.h&gt;</span><br><span class="line"> 2 #include &lt;string.h&gt;</span><br><span class="line"> 3 class Person </span><br><span class="line"> 4 &#123;</span><br><span class="line"> 5 public :</span><br><span class="line"> 6          </span><br><span class="line"> 7     &#x2F;&#x2F; 构造函数</span><br><span class="line"> 8     Person(char * pN)</span><br><span class="line"> 9     &#123;</span><br><span class="line">10         cout &lt;&lt; &quot;一般构造函数被调用 !\n&quot;;</span><br><span class="line">11         m_pName &#x3D; new char[strlen(pN) + 1];</span><br><span class="line">12         &#x2F;&#x2F;在堆中开辟一个内存块存放pN所指的字符串</span><br><span class="line">13         if(m_pName !&#x3D; NULL) </span><br><span class="line">14         &#123;</span><br><span class="line">15            &#x2F;&#x2F;如果m_pName不是空指针，则把形参指针pN所指的字符串复制给它</span><br><span class="line">16              strcpy(m_pName ,pN);</span><br><span class="line">17         &#125;</span><br><span class="line">18     &#125;        </span><br><span class="line">19        </span><br><span class="line">20     &#x2F;&#x2F; 系统创建的默认复制构造函数，只做位模式拷贝</span><br><span class="line">21     Person(Person &amp; p)    </span><br><span class="line">22     &#123; </span><br><span class="line">23         &#x2F;&#x2F;使两个字符串指针指向同一地址位置         </span><br><span class="line">24         m_pName &#x3D; p.m_pName;         </span><br><span class="line">25     &#125;</span><br><span class="line">26  </span><br><span class="line">27     ~Person( )</span><br><span class="line">28     &#123;</span><br><span class="line">29         delete m_pName;</span><br><span class="line">30     &#125;</span><br><span class="line">31          </span><br><span class="line">32 private :</span><br><span class="line">33     char * m_pName;</span><br><span class="line">34 &#125;;</span><br><span class="line">35  </span><br><span class="line">36 void main( )</span><br><span class="line">37 &#123; </span><br><span class="line">38     Person man(&quot;lujun&quot;);</span><br><span class="line">39     Person woman(man); </span><br><span class="line">40      </span><br><span class="line">41     &#x2F;&#x2F; 结果导致   man 和    woman 的指针都指向了同一个地址</span><br><span class="line">42      </span><br><span class="line">43     &#x2F;&#x2F; 函数结束析构时</span><br><span class="line">44     &#x2F;&#x2F; 同一个地址被delete两次</span><br><span class="line">45 &#125;</span><br><span class="line">46  </span><br><span class="line">47  </span><br><span class="line">48 &#x2F;&#x2F; 下面自己设计复制构造函数，实现“深拷贝”，即不让指针指向同一地址，而是重新申请一块内存给新的对象的指针数据成员</span><br><span class="line">49 Person(Person &amp; chs);</span><br><span class="line">50 &#123;</span><br><span class="line">51      &#x2F;&#x2F; 用运算符new为新对象的指针数据成员分配空间</span><br><span class="line">52      m_pName&#x3D;new char[strlen(p.m_pName)+ 1];</span><br><span class="line">53  </span><br><span class="line">54      if(m_pName)         </span><br><span class="line">55      &#123;</span><br><span class="line">56              &#x2F;&#x2F; 复制内容</span><br><span class="line">57             strcpy(m_pName ,chs.m_pName);</span><br><span class="line">58      &#125;</span><br><span class="line">59    </span><br><span class="line">60     &#x2F;&#x2F; 则新创建的对象的m_pName与原对象chs的m_pName不再指向同一地址了</span><br><span class="line">61 &#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="yi-ge-kong-de-class-lei-li-you-shi-me">一个空的class类里有什么?</span><a href="#yi-ge-kong-de-class-lei-li-you-shi-me" class="header-anchor">#</a></h2>
<p>定义一个空类
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
默认会生成以下几个函数 1. 无参的构造函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
2. 拷贝构造函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty(const Empty&amp; copy)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
3. 赋值运算符
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty&amp; operator &#x3D; (const Empty&amp; copy)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
4. 析构函数（非虚）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~Empty()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这些函数只有在第一次使用它们的时候才会生成，他们都是inline并且public的。如果想禁止生成这些函数，可以将它们定义成private函数，如果有很多类都有这种需求，那么可以定义一个基类，然后让其他类继承这个类。
### 空class用法</p>
<p>先假设我们有个很傲娇的类，它不希望通过构造函数生成，也不希望别的对象对它赋值。
然而更加高级的做法是定义一个空类，将空类的复制构造函数和赋值操作符声明为私有，然后让SomeClass继承它。像这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    Empty()&#123;&#125;                    &#x2F;&#x2F;允许derived class调用</span><br><span class="line">    ~Empty()&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    Empty(const Empty&amp;);            &#x2F;&#x2F;阻止了copying</span><br><span class="line">    Empty&amp; operator &#x3D; (const Empty&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SomeClass: private Empty</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这些函数只有在第一次使用它们的时候才会生成，他们都是inline并且public的。如果想禁止生成这些函数，可以将它们定义成private函数，如果有很多类都有这种需求，那么可以定义一个基类，然后让其他类继承这个类。</p>
<h2><span id="xu-han-shu-de-zuo-yong-yi-ji-shi-xian-yuan-li">虚函数的作用以及实现原理</span><a href="#xu-han-shu-de-zuo-yong-yi-ji-shi-xian-yuan-li" class="header-anchor">#</a></h2>
<p>链接：https://www.nowcoder.com/questionTerminal/1f67d4e2b6134c298e993e622181b333
#### 虚函数的作用：简单讲即实现多态。
基类定义了虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，且这样的函数调用是无法在编译器期间确认的，而是在运行期确认，也叫做迟绑定。</p>
<p>对于虚函数的支持则分两步完成：</p>
<p><strong>1.每一个class产生一堆指向虚函数的指针，放在表格之中。这个表格称之为虚函数表（virtual
table，vtbl）。</strong></p>
<p><strong>2.每一个对象被添加了一个指针，指向相关的虚函数表vtbl。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的构造函数，析构函数和拷贝赋值运算符自动完成。</strong></p>
<p>另外，虚函数表地址的前面设置了一个指向type_info的指针，RTTI（Run Time
Type
Identification）运行时类型识别是有编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI是为多态而生成的信息，所以只有具有虚函数的对象在会生成。</p>
<p><strong><em>C++中虚函数使用虚函数表和
虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地
址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的
虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处），
它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应
不同基类的虚函数表。</em></strong></p>
<p>简单来讲是多态，也就是允许派生类对象指向基类指针在运行时调用调用派生类的同名函数。
原理：含有虚函数的类对象，在啊创建时会再头部创建一个指针，指向一个虚表，虚表内保存着虚函数的地址，当调用虚函数时，调用指针指向虚表，子啊虚表中找到虚函数的地址。从而实现运行时多态，普通的成员函数地址是固定的，直接调用即可。</p>
<h2><span id="overload-overwrite-ji-override-de-qu-bie">Overload、Overwrite及Override的区别</span><a href="#overload-overwrite-ji-override-de-qu-bie" class="header-anchor">#</a></h2>
<p>Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。
1. 相同的范围（在同一个类中）； 2. 函数名字相同； 3. 参数不同； 4.
virtual 关键字可有可无。</p>
<p>Override(覆盖)：是指派生类函数覆盖基类函数，特征是： 1.
不同的范围（分别位于派生类与基类）； 2. 函数名字相同； 3. 参数相同； 4.
基类函数必须有virtual 关键字。</p>
<p>Overwrite(重写)：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
1.
如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
2.
如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> void F()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;Parent.F()&#x2F;n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void G()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;Parent.G()&#x2F;n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int Add(int x, int y)</span><br><span class="line"> &#123;</span><br><span class="line">        return x + y;</span><br><span class="line"> &#125;</span><br><span class="line">    &#x2F;&#x2F;重载(overload)Add函数</span><br><span class="line"> float Add(float x, float y)</span><br><span class="line">   &#123;</span><br><span class="line">        return x + y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ChildOne:Parent</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;重写(overwrite)父类函数</span><br><span class="line"> void F()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;ChildOne.F()&#x2F;n&quot;); </span><br><span class="line"> &#125;</span><br><span class="line">    &#x2F;&#x2F;覆写(override)父类虚函数,主要实现多态</span><br><span class="line">  void G()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;ChildOne.G()&#x2F;n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> ChildOne childOne;&#x2F;&#x2F; &#x3D; new ChildOne();</span><br><span class="line"> Parent* p &#x3D; (Parent*)&amp;childOne;</span><br><span class="line">  &#x2F;&#x2F;调用Parent.F()</span><br><span class="line">  p-&gt;F();</span><br><span class="line">    &#x2F;&#x2F;实现多态</span><br><span class="line">  p-&gt;G();</span><br><span class="line">    Parent* p2 &#x3D; new Parent();</span><br><span class="line">   &#x2F;&#x2F;重载(overload)</span><br><span class="line">  printf(&quot;%d&#x2F;n&quot;,p2-&gt;Add(1, 2));</span><br><span class="line">   printf(&quot;%f&#x2F;n&quot;,p2-&gt;Add(3.4f, 4.5f));</span><br><span class="line"> delete p2;</span><br><span class="line">    system(&quot;PAUSE&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="overload-de-hua-zhi-you-han-shu-fan-hui-zhi-lei-xing-bu-tong-hui-chong-zai-ma">overload的话，只有函数返回值类型不同，会重载吗?</span><a href="#overload-de-hua-zhi-you-han-shu-fan-hui-zhi-lei-xing-bu-tong-hui-chong-zai-ma" class="header-anchor">#</a></h2>
<ol type="1">
<li><p>在使用重载时只能通过<strong>不同的参数样式</strong>。例如，<strong>不同的参数类型，不同的参数个数，不同的参数顺序</strong>（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,
float)， 但是不能为fun(int, int)）；</p></li>
<li><p>不能通过访问权限、返回类型、抛出的异常进行重载；</p></li>
<li><p>方法的异常类型和数目不会对重载造成影响；</p></li>
<li><p>对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p></li>
</ol>
<h2><span id="yi-ge-jie-gou-ti-zhong-you-yi-ge-int-yi-ge-char-yi-ge-static-int-wen-zhe-ge-jie-gou-ti-zhan-duo-shao-nei-cun">一个结构体中有一个int，一个char，一个static
int，问这个结构体占多少内存</span><a href="#yi-ge-jie-gou-ti-zhong-you-yi-ge-int-yi-ge-char-yi-ge-static-int-wen-zhe-ge-jie-gou-ti-zhan-duo-shao-nei-cun" class="header-anchor">#</a></h2>
<p>结构体 <strong>内存对齐规则</strong> 结构体所占用的内存
<strong>与其成员在结构体中的声明顺序有关</strong>，其成员的内存对齐规则如下：</p>
<ol type="1">
<li><p>每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。</p></li>
<li><p>复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，可以最小化长度。</p></li>
<li><p>结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。</p></li>
<li><p>计算结构体的内存大小时，应该列出每个成员的偏移地址，则其长度=最后一个成员的偏移地址+最后一个成员数的长度+最后一个成员的调整参数</p></li>
</ol>
<h2><span id="stl-zhong-you-shi-me-lei">STL中有什么类</span><a href="#stl-zhong-you-shi-me-lei" class="header-anchor">#</a></h2>
<p>https://blog.csdn.net/chuanzhouxiao/article/details/51902786
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector 向量 </span><br><span class="line">string 字符串</span><br><span class="line">list 列表</span><br><span class="line">queue 队列</span><br><span class="line">map 映射</span><br><span class="line">set 集合</span><br><span class="line">stack 栈</span><br><span class="line"></span><br><span class="line">map，vector和unordered_map区别及实现原理 </span><br><span class="line">红黑树 hash表 </span><br><span class="line">mysql索引 </span><br><span class="line">tcp三次握手 重传机制 </span><br></pre></td></tr></table></figure>
## 进程数据栈堆</p>
<h3><span id="1-jin-cheng-he-xian-cheng-de-ding-yi">1.进程和线程的定义</span><a href="#1-jin-cheng-he-xian-cheng-de-ding-yi" class="header-anchor">#</a></h3>
<ol type="1">
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</li>
<li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</li>
</ol>
<h3><span id="2-jin-cheng-he-xian-cheng-de-qu-bie">2.进程和线程的区别</span><a href="#2-jin-cheng-he-xian-cheng-de-qu-bie" class="header-anchor">#</a></h3>
<ol type="1">
<li>进程在执行过程中拥有独立的内存单元，而该进程的多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
<li>在很多现代操作系统中，一个进程的（虚）地址空间大小为4G，分为系统（内核？）空间和用户空间两部分，系统空间为所有进程共享，而用户空间是独立的，一般WINDOWS进程的用户空间为2G。</li>
<li>一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)，Windows线程的缺省堆栈大小为1M。堆(heap)的分配与栈有所不同，一般是一个进程有一个C运行时堆，这个堆为本进程中所有线程共享，windows进程还有所谓进程默认堆，用户也可以创建自己的堆。
用操作系统术语，线程切换的时候实际上切换的是一个可以称之为线程控制块的结构（TCB?）,里面保存所有将来用于恢复线程环境必须的信息，包括所有必须保存的寄存器集，线程的状态等。</li>
</ol>
<h3><span id="3-duo-xian-cheng-de-gua-yong-chang-jing-shi-shi-me-wei-sha-yao-yong-duo-xian-cheng">3.多线程的适用场景是什么？为啥要用多线程？</span><a href="#3-duo-xian-cheng-de-gua-yong-chang-jing-shi-shi-me-wei-sha-yao-yong-duo-xian-cheng" class="header-anchor">#</a></h3>
<p>使用多线程是为了
<strong>提高程序运行的效率</strong>。假如有一个程序，要求用户输入多个算式，计算出结果，并分别打印到屏幕上。如果用户一直没有输入，那么无法计算，更无法打印。如果用户输入了，必须要全部输入完，才能计算出结果，再打印到屏幕。
使用线程的话，一个线程用来等待用户输入，一个用来计算结果，一个用来打印。用户在输入算式3的时候，计算线程在计算算式2，打印线程在打印算式1，三个线程同时进行，减少了等待，这样就提高了运行效率</p>
<h3><span id="4-dui-he-zhan">4.堆和栈</span><a href="#4-dui-he-zhan" class="header-anchor">#</a></h3>
<p><strong>堆</strong>：是
<strong>共有的空间，分全局堆和局部堆</strong>。全局堆就是
<strong>所有没有分配的空间</strong>，局部堆就是
<strong>用户分配的空间</strong>。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得
<strong>用完了要还给操作系统，要不然就是内存泄漏</strong>。</p>
<p><strong>栈</strong>：是个
<strong>线程独有的</strong>，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread
safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。
函数调用栈堆</p>
<p>Top N排序 拷贝构造函数 复制构造函数 static 关键字</p>
<h2><span id="yuan-wen-jian-cpp-dao-ke-zhi-xing-wen-jian-exe-de-guo-cheng">源文件cpp到可执行文件exe的过程</span><a href="#yuan-wen-jian-cpp-dao-ke-zhi-xing-wen-jian-exe-de-guo-cheng" class="header-anchor">#</a></h2>
<p>从一个cpp文件到一个exe文件，大概经历了以下过程：</p>
<ol type="1">
<li><p>预处理（preprocessor）
根据预处理命令组装成新的C/C++程序，常以i为扩展名。这个过程包括：宏的替换、删除注释、处理预处理指令（如#include、#ifdef）。</p></li>
<li><p>编译（complier） 将得到的i文件翻译成汇编代码，即.s文件。</p></li>
<li><p>汇编（assembler）
将汇编文件翻译成机器指令，并打包成可重定位目标程序的o文件。该文件是二进制文件，字节编码是机器指令。编译器把一个cpp编译汇编得到目标文件时，除了要在目标文件里写入cpp里包含的数据和代码，还要至少提供3个表：</p></li>
</ol>
<ul>
<li>未解决符号表（unresolved symbol
table）：提供所有在编译单元里引用但定义不在本编译单元里的符号及其出现的地址；</li>
<li>导出符号表（export symbol
table）：提供本编译单元具有定义，且愿意提供给其它编译单元使用的符号及其地址（全局作用域）；</li>
<li>地址重定向表（address redirect
table）：提供本编译单元所有对自身地址的引用的记录。</li>
</ul>
<ol start="4" type="1">
<li>链接（linker）
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或函数调用）或程序中可能调用了某个库文件中的函数。将引用的其它o文件并入到我们程序所在的o文件中并进行处理，方可得到最终的可执行文件。
链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定向表，对其中记录的地址进行重定向（即加上该编译单元实际在可执行文件里的起始地址）。然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上填写实际的地址（也要加上拥有该符号定义的编译单元实际在可执行文件里的起始地址）。最后把所有的目标文件的内容写在各自的位置上，再做一些别的工作，即得到一个可执行文件。
PS：实际链接的时候更为复杂，因为实际的目标文件里把数据或代码分为好几个区，重定向等要按区进行，但原理一样。</li>
</ol>
<ul>
<li>内部链接：一个名称对编译单元（cpp文件）来说是局部的，在链接的时候其它的编译单元无法链接到它；</li>
<li>外部链接：一个名称对编译单元来说不是局部的，在链接的时候其它的编译单元可以访问它，即它可以和别的编译单元交互。</li>
</ul>
<h2><span id="const-he-define">const和define</span><a href="#const-he-define" class="header-anchor">#</a></h2>
<p>const定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量，存放在静态区)，而#define定义的宏常量在内存中有若干个拷贝。
#define宏是在预编译阶段进行替换，而const修饰的只读变量是在编译的时候确定其值。
#define宏没有类型，而const修饰的只读变量具有特定的类型
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int *p;   &#x2F;&#x2F;p可变，p指向的对象不可变</span><br><span class="line">int const*p;  &#x2F;&#x2F;p可变，p指向的对象不可变</span><br><span class="line">int *const p;  &#x2F;&#x2F;p不可变，p指向的对象可变</span><br><span class="line">const int *const p;  &#x2F;&#x2F;指针p和p指向的对象都不可变</span><br></pre></td></tr></table></figure>
总的来说： const：有数据类型，编译进行安全检查，可调试
define:宏，不考虑数据类型，没有安检，不能调试</p>
<p>这里有一个记忆和理解的方法：
先忽略类型名(编译器解析的时候也是忽略类型名)，我们看const离哪个近。"近水楼台先得月"，离谁近就修饰谁。
判断时忽略括号中的类型
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const (int) *p;   &#x2F;&#x2F;const修饰*p，*p是指针指向的对象，不可变</span><br><span class="line">(int) const *p；  &#x2F;&#x2F;const修饰*p，*p是指针指向的对象，不可变</span><br><span class="line">(int)*const p;   &#x2F;&#x2F;const修饰p，p不可变，p指向的对象可变</span><br><span class="line">const (int) *const p;  &#x2F;&#x2F;前一个const修饰*p，后一个const修饰p，指针p和p指向的对象都不可变</span><br></pre></td></tr></table></figure>
## C++ 异常机制分析 http://www.cnblogs.com/QG-whz/p/5136883.html</p>
<h2><span id="new-he-malloc-de-qu-bie">new和malloc的区别</span><a href="#new-he-malloc-de-qu-bie" class="header-anchor">#</a></h2>
<p>https://www.cnblogs.com/engraver-lxw/p/8600816.html 1.
申请的内存所在位置 　　new操作符从自由存储区（free
store）上为对象动态分配内存空间，而malloc函数从<strong>堆上动态分配内存</strong>。
2. 返回类型安全性
　　new操作符内存分配成功时，<strong>返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符</strong>。而malloc内存分配成功则是**返回void
* ，需要通过强制类型转换将void*指针转换成我们需要的类型**。</p>
<ol start="3" type="1">
<li>内存分配失败时的返回值
　　new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</li>
</ol>
<p>在使用C语言时，我们习惯
<strong>在malloc分配内存后判断分配是否成功</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int *a  &#x3D; (int *)malloc ( sizeof (int ));</span><br><span class="line">if(NULL &#x3D;&#x3D; a)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
但是
<strong>对于new实际上这样做一点意义也没有</strong>，因为new根本不会返回NULL，而且
<strong>程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    int *a &#x3D; new int();</span><br><span class="line">&#125;</span><br><span class="line">catch (bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li>是否需要指定内存大小 使用
<strong>new操作符申请内存分配时无须指定内存块的大小</strong>，编译器会根据类型信息自行计算，而
<strong>malloc则需要显式地指出所需内存的尺寸</strong>。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;...&#125;</span><br><span class="line">A * ptr &#x3D; new A;</span><br><span class="line">A * ptr &#x3D; (A *)malloc(sizeof(A)); &#x2F;&#x2F;需要显式指定所需内存大小sizeof(A);</span><br></pre></td></tr></table></figure></li>
<li>是否调用构造函数/析构函数
使用new操作符来分配对象内存时会经历三个步骤：</li>
</ol>
<ul>
<li>第一步：调用operator new 函数（对于数组是operator
new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li>
<li>第二步：编译器运行
<strong>相应的构造函数以构造对象，并为其传入初值</strong>。</li>
<li>第三步：对象构造完成后，<strong>返回一个指向该对象的指针</strong>。</li>
</ul>
<p>使用delete操作符来释放对象内存时会经历两个步骤： - 第一步：调用
<strong>对象的析构函数</strong>。 - 第二步：编译器 <strong>调用operator
delete(或operator delete[])函数释放内存空间</strong>。</p>
<p>总之来说，<strong>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构</strong>。而
<strong>malloc则不会</strong>。</p>
<ol start="6" type="1">
<li>对数组的处理 C++提供了new[]与delete[]来专门处理数组类型:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A * ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个A对象</span><br></pre></td></tr></table></figure>
使用new[]分配的内存必须使用delete[]进行释放：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] ptr;</span><br></pre></td></tr></table></figure>
new对数组的支持体现在它会<strong>分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏</strong>。至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * ptr &#x3D; (int *) malloc( sizeof(int)* 10 );&#x2F;&#x2F;分配一个10个int元素的数组</span><br></pre></td></tr></table></figure></li>
<li>new与malloc是否可以相互调用 operator new /operator
delete的实现可以基于malloc，而
<strong>malloc的实现不可以去调用new</strong>。下面是编写operator new
/operator delete 的一种简单方式，其他版本也与之类似：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> void * operator new (sieze_t size)</span><br><span class="line"> &#123;</span><br><span class="line">     if(void * mem &#x3D; malloc(size)</span><br><span class="line">         return mem;</span><br><span class="line">     else</span><br><span class="line">         throw bad_alloc();</span><br><span class="line"> &#125;</span><br><span class="line"> void operator delete(void *mem) noexcept</span><br><span class="line"> &#123;</span><br><span class="line">    free(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="zhi-zhen-dui-qi">指针对齐</span><a href="#zhi-zhen-dui-qi" class="header-anchor">#</a></h2>
<p>以下代码打印的结果是（假设运行在 64 位计算机上）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct st_t &#123;</span><br><span class="line">    int status;</span><br><span class="line">    short *pdata;</span><br><span class="line">    char errstr[32]; </span><br><span class="line">&#125;;</span><br><span class="line">st_t st[16];</span><br><span class="line">char *p&#x3D;(char *)(st[2].esstr+32);</span><br><span class="line">printf(“%d”,(p-(char *)(st)));</span><br></pre></td></tr></table></figure></p>
<p>根据字节对齐，在64位系统下struct st_t 结构体占用的字节为48个。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct st_t &#123; </span><br><span class="line">int status;  &#x2F;&#x2F;占用8个（后面的4个为对齐位） </span><br><span class="line">short *pdata;&#x2F;&#x2F;占用8个 </span><br><span class="line">char errstr[32];&#x2F;&#x2F;占用32个 </span><br><span class="line">&#125;; </span><br><span class="line">char *p&#x3D;(char *)(st[2].esstr+32)，p实际指向了st[3] </span><br><span class="line">则p-(char *)(st))，即为&amp;st[3]-&amp;st[0],占用空间为3个结构体的大小，即3*48&#x3D;144</span><br></pre></td></tr></table></figure></p>
<h2><span id="kong-lei-de-sizeof-da-xiao-you-yi-ge-xu-han-shu-de-lei-de-sizeof">空类的sizeof大小，有一个虚函数的类的sizeof</span><a href="#kong-lei-de-sizeof-da-xiao-you-yi-ge-xu-han-shu-de-lei-de-sizeof" class="header-anchor">#</a></h2>
<p>https://blog.csdn.net/foreverhuylee/article/details/39320977
题目（二）：运行下面的代码，输出是什么？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        B() &#123;&#125;</span><br><span class="line">~B() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        C() &#123;&#125;</span><br><span class="line">        virtual ~C() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d, %d, %d\n&quot;, sizeof(A), sizeof(B), sizeof(C));</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><p>答案是1, 1, 4。class
A是一个空类型，它的实例不包含任何信息，本来求sizeof应该是0。但当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual
Studio 2008中每个空类型的实例占用一个byte的空间。</p></li>
<li><p>class B在class
A的基础上添加了构造函数和析构函数。由于构造函数和析构函数的调用与类型的实例无关（调用它们只需要知道函数地址即可），在它的实例中不需要增加任何信息。所以sizeof(B)和sizeof(A)一样，在Visual
Studio 2008中都是1。</p></li>
<li><p>class C在class
B的基础上把析构函数标注为虚拟函数。C++的编译器一旦发现一个类型中有虚拟函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4个字节的空间，因此sizeof(C)是4。</p></li>
</ol>
<h2><span id="zhi-chuan-di-yin-yong-chuan-di">值传递，引用传递</span><a href="#zhi-chuan-di-yin-yong-chuan-di" class="header-anchor">#</a></h2>
<p>值传递---单向传递 swap(int a,int b) 引用传递 ----双向传递 swap(int
&amp;a,int &amp;b)<br>
<strong>引用即别名，必须初始化</strong></p>
<h2><span id="nei-lian-han-shu-inline">内联函数 inline</span><a href="#nei-lian-han-shu-inline" class="header-anchor">#</a></h2>
<p>作用：可避免函数调用的开销
注：<strong>内联函数只是对编译器发送一个请求，编译器可以忽略该请求</strong>
一般用于<strong>优化规模小，流程直接，频繁调用的函数</strong></p>
<ol type="1">
<li>内联函数体内不能有循环语句和switch语句</li>
<li>内联函数定义必须在内联函数第一次调用之前</li>
<li>对内联函数不能进行异常接口声明</li>
</ol>
<h2><span id="constexpr-han-shu">constexpr函数</span><a href="#constexpr-han-shu" class="header-anchor">#</a></h2>
<p>指能用于常量表达式的函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constexpr int getsize() &#123;</span><br><span class="line">  return 20;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"> constexpr int foo &#x3D; getsize(); &#x2F;&#x2F;foo是常量表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## 常量表达式 值不会改变并且编译过程就能得到计算结果的表达式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int max_files&#x3D;20; &#x2F;&#x2F;常量表达式</span><br><span class="line">const int limit&#x3D;max_files+1; &#x2F;&#x2F;常量表达式</span><br><span class="line">int staff_size&#x3D;27; &#x2F;&#x2F;不是常量表达式</span><br></pre></td></tr></table></figure></p>
<h2><span id="mo-ren-can-shu-zhi">默认参数值</span><a href="#mo-ren-can-shu-zhi" class="header-anchor">#</a></h2>
<p>有默认参数的形参必须<strong>列在函数形参列表的最右端</strong>
调用实参与形参结合的次序是<strong>从左到右</strong>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int add(int x,int y&#x3D;5,int z&#x3D;6);&#x2F;&#x2F;正确</span><br><span class="line">add(1)&#x3D;12;</span><br><span class="line">add(1,2)&#x3D;9;</span><br><span class="line"></span><br><span class="line">int add(int x&#x3D;1,int y&#x3D;5,int z);&#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/02/%E8%AE%A1%E7%BD%91-http%E4%B9%8BGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/%E8%AE%A1%E7%BD%91-http%E4%B9%8BGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">[计网]http之GET和POST区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-02 20:24:34" itemprop="dateCreated datePublished" datetime="2020-12-02T20:24:34+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="liu-lan-qi-de-get-he-post">浏览器的GET和POST</span><a href="#liu-lan-qi-de-get-he-post" class="header-anchor">#</a></h1>
<p>这里特指浏览器中 <strong>非Ajax的HTTP请求</strong>，即从
<strong>HTML和浏览器</strong>诞生就一直使用的HTTP协议中的GET/POST。浏览器用
<strong>GET请求来获取一个html页面/图片/css/js等资源</strong>；用
<strong>POST来提交一个&lt; form&gt;表单</strong>，并
<strong>得到一个结果的网页</strong>。</p>
<h2><span id="get">GET</span><a href="#get" class="header-anchor">#</a></h2>
<p><strong>“读取“一个资源</strong>。比如Get到一个html文件。
<strong>反复读取不应该对访问的数据有副作用</strong>。比如”GET一下，用户就下单了，返回订单已受理“，这是不可接受的。没有副作用被称为
<strong>“幂等“（Idempotent)</strong>。因为
<strong>GET是读取</strong>，就可以
<strong>对GET请求的数据做缓存</strong>。这个缓存可以做到浏览器本身上（彻底
<strong>避免浏览器发请求</strong>），也可以做到代理上（如
<strong>nginx</strong>），或者
<strong>做到server端</strong>（用Etag，至少可以减少带宽消耗）</p>
<h2><span id="post">POST</span><a href="#post" class="header-anchor">#</a></h2>
<p>在页面里 <strong>&lt; form&gt; 标签</strong>会定义
<strong>一个表单</strong>。点击其中的
<strong>submit元素</strong>会发出一个
<strong>POST请求让服务器做一件事</strong>。这件事往往是
<strong>有副作用的，不幂等的</strong>。不幂等也就意味着
<strong>不能随意多次执行</strong>。因此也就
<strong>不能缓存</strong>。比如通过POST下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。试想一下，如果POST请求被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的“下单成功界面”，却又没有真的在服务器下单。那是一件多么滑稽的事情。因为POST可能有副作用，所以浏览器实现为
<strong>不能把POST请求保存为书签</strong>。想想，如果点一下书签就下一个单，是不是很恐怖？。此外如果尝试重新执行POST请求，浏览器也会弹一个框提示下这个刷新可能会有副作用，询问要不要继续。</p>
<h2><span id="gai-zao-get-he-post">改造GET和POST</span><a href="#gai-zao-get-he-post" class="header-anchor">#</a></h2>
<p>当然，服务器的
<strong>开发者完全可以把GET实现为有副作用；把POST实现为没有副作用</strong>。只不过这和浏览器的预期不符。把GET实现为有副作用是个很可怕的事情。
我依稀记得很久之前百度贴吧有一个因为
<strong>使用GET请求可以修改管理员的权限而造成的安全漏洞</strong>。反过来，把没有副作用的请求用POST实现，浏览器该弹框还是会弹框，对用户体验好处改善不大。但是后边可以看到，将HTTP
POST作为接口的形式使用时，就没有这种弹框了。于是
<strong>把一个POST请求实现为幂等就有实际的意义</strong>。
<strong>POST幂等能让很多业务的前后端交互更顺畅</strong>，以及避免一些因为前端bug，触控失误等带来的重复提交。将一个有副作用的操作实现为幂等必须得从业务上能定义出怎么就算是“重复”。如提交数据中增加一个dedupKey在一个交易会话中有效，或者
<strong>利用提交的数据里可以天然当dedupKey的字段</strong>。这样万一用户强行重复提交，服务器端可以做一次防护。</p>
<h2><span id="get-he-post-shu-ju-de-ge-shi-qu-bie">GET和POST数据的格式区别</span><a href="#get-he-post-shu-ju-de-ge-shi-qu-bie" class="header-anchor">#</a></h2>
<p>GET和POST <strong>携带数据的格式也有区别</strong>。
当浏览器发出一个GET请求时，就意味着
<strong>要么是用户自己在浏览器的地址栏输入</strong>，要不就是
<strong>点击了html里a标签的href中的url</strong>。所以其实
<strong>并不是GET只能用url</strong>，而是
<strong>浏览器直接发出的GET只能由一个url触发</strong>。GET上要在url之外带一些参数就
<strong>只能依靠url上附带querystring</strong>。请求参数和对应的值附加在URL后面，利用一个
<strong>"?"代表URL的结尾与请求参数的开始</strong>，多个 <strong>参数用
"&amp;"连接</strong>。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;server&#x2F;action?id&#x3D;a&amp;id&#x3D;b </span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;server&#x2F;action&#x2F;?info\&#x3D;&#39;&#39;\&amp;abc\&#x3D;c6cebb78a7be\&amp;server\&#x3D;52300 (这里加了转义字符&#39;\&#39;，待验证是否必要)</span><br></pre></td></tr></table></figure></p>
<p>但是HTTP协议本身并没有这个限制。浏览器的POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是
<strong>application/x-www-form-urlencoded用来传输简单的数据</strong>，大概就是"key1=value1&amp;key2=value2"这样的格式。另外一种是
<strong>传文件，会采用multipart/form-data格式</strong>。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。浏览器在POST一个表单时，<strong>url上也可以带参数</strong>，只要&lt;
form action="url"
&gt;里的url带querystring就行。只不过表单里面的那些用&lt; input&gt;
等标签经过用户操作产生的数据都在会在body里。因此我们一般会泛泛的说“GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中“。但这种情况仅限于浏览器发请求的场景。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.zybuluo.com/JunQiu/note/1291674" title="四种常见的 POST 提交数据方式？">四种常见的 POST
提交数据方式</a></p>
<h1><span id="jie-kou-zhong-de-get-he-post">接口中的GET和POST</span><a href="#jie-kou-zhong-de-get-he-post" class="header-anchor">#</a></h1>
<p>这里是指通过浏览器的Ajax api，或者iOS/Android的App的http
client，java的commons-httpclient/okhttp或者是curl，postman之类的工具
<strong>发出来的GET和POST请求</strong>。此时GET/POST不光能用在
<strong>前端和后端的交互</strong>中，还能用在
<strong>后端各个子服务的调用</strong>中（即当一种
<strong>RPC协议</strong>使用）。尽管RPC有很多协议，比如thrift，grpc，但是http本身
<strong>已经有大量的现成的支持工具</strong>可以使用，并且对人类很友好，容易debug。HTTP协议在
<strong>微服务中的使用是相当普遍</strong>的。当用
<strong>HTTP实现接口</strong>发送请求时，就
<strong>没有浏览器中那么多限制了，只要是
</strong>符合HTTP格式的就可以发<strong>。HTTP请求的格式，大概是这样的一个字符串：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;METHOD&gt; &lt;URL&gt; HTTP&#x2F;1.1\r\n</span><br><span class="line">&lt;Header1&gt;: &lt;HeaderValue1&gt;\r\n</span><br><span class="line">&lt;Header2&gt;: &lt;HeaderValue2&gt;\r\n</span><br><span class="line">...</span><br><span class="line">&lt;HeaderN&gt;: &lt;HeaderValueN&gt;\r\n</span><br><span class="line">\r\n</span><br><span class="line">&lt;Body Data....&gt;</span><br></pre></td></tr></table></figure>
其中的“<method>"可以 是 </method></strong>GET或POST<strong>，或者其他的HTTP
Method，如 </strong>PUT、DELETE、OPTION……<strong>。HTTP是
</strong>基于TCP/IP的<strong>关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是
</strong>TCP/IP<strong>，也就是说，</strong>GET/POST都是TCP链接<strong>。GET和POST能做的事情是一样的。因此从协议本身看，并
</strong>没有什么限制说GET一定不能没有body<strong>，</strong>POST就一定不能把参放到<url>的querystring上<strong>。因此其实
</strong>可以更加自由的去利用格式<strong>。比如Elastic Search的_search
api就 </strong>用了带body的GET<strong>；也可以自己开发接口
</strong>让POST一半的参数放在url的querystring里<strong>，</strong>另外一半放body里**；你甚至还可以让所有的参数都放Header里——可以做各种各样的定制，只要请求的客户端和服务器端能够约定好。</url></p>
<p>当然，太自由也带来了另一种麻烦，开发人员不得不每次讨论确定参数是
<strong>放url的path里，querystring里，body里，header里</strong>这种问题。于是就有了
<strong>一些列接口规范/风格</strong>。其中名气最大的当属
<strong>REST</strong>。REST充分运用
<strong>GET、POST、PUT和DELETE，约定了这4个接口分别获取、创建、替换和删除“资源”</strong>，REST最佳实践还推荐在
<strong>请求体使用json格式</strong>。这样仅仅通过看HTTP的method就可以明白接口是什么意思，并且解析格式也得到了统一。</p>
<h3><span id="get-he-post-huan-you-yi-ge-chong-da-qu-bie">GET和POST还有一个重大区别：</span><a href="#get-he-post-huan-you-yi-ge-chong-da-qu-bie" class="header-anchor">#</a></h3>
<p><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></p>
<p>对于GET方式的请求，浏览器会把 <strong>http
header和data一并发送出</strong>去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器 <strong>先发送header，服务器响应100
continue，浏览器再发送data，服务器响应200 ok</strong>（返回数据）。
<strong>注：</strong> 1. GET与POST都有自己的语义，不能随便混用。</p>
<ol start="2" type="1">
<li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li>
<li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li>
</ol>
<h3><span id="json-xiang-dui-yu-x-www-form-urlencoded-de-you-shi">json相对于x-www-form-urlencoded的优势:</span><a href="#json-xiang-dui-yu-x-www-form-urlencoded-de-you-shi" class="header-anchor">#</a></h3>
<ol type="1">
<li>可以有 <strong>嵌套结构</strong></li>
<li>可以支持
<strong>更丰富的数据类型</strong>。通过一些框架，json可以直接被服务器代码映射为业务实体。用起来十分方便。但是
<strong>如果是写一个接口支持上传文件</strong>，那么还是
<strong>multipart/form-data格式更合适</strong>。</li>
</ol>
<h1><span id="an-quan-xing">安全性</span><a href="#an-quan-xing" class="header-anchor">#</a></h1>
<p>我们常听到GET不如POST安全，因为
<strong>POST用body传输数据</strong>，而
<strong>GET用url传输</strong>，更加容易看到。但是
<strong>从攻击的角度，无论是GET还是POST都不够安全</strong>，因为
<strong>HTTP本身是明文协议</strong>。每个
<strong>HTTP请求和返回的每个byte都会在网络上明文传播</strong>，不管是url，header还是body。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。为了避免传输中数据被窃取，<strong>必须做从客户端到服务器的端端加密</strong>。业界的通行做法就是
<strong>https</strong>——即
<strong>用SSL协议协商出的密钥加密明文的http数据</strong>。这个
<strong>加密的协议和HTTP协议本身相互独立</strong>。如果是利用HTTP开发公网的站点/App，要保证安全，<strong>https是最最基本的要求</strong>。当然，端端加密并不一定非得用https。比如国内金融领域都会用私有网络，也有GB的加密协议SM系列。但除了军队，金融等特殊机构之外，似乎并没有必要自己发明一套类似于ssl的协议。</p>
<p>回到HTTP本身，的确
<strong>GET请求的参数更倾向于放在url</strong>上，因此
<strong>有更多机会被泄漏</strong>。比如携带私密信息的url会展示在地址栏上，还可以分享给第三方，就非常不安全了。此外，从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的access
log通常会输出完整的url，比如nginx的默认access
log就是如此。如果url上携带敏感数据，就会被记录下来。但请注意，就算私密数据在body里，也是可以被记录下来的，因此如果请求要经过不信任的公网，<strong>避免泄密的唯一手段就是https</strong>。这里说的“避免access
log泄漏“仅仅是指避免可信区域中的http代理的默认行为带来的安全隐患。</p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28586791" title="知乎--GET 和 POST 到底有什么区别？">知乎--GET 和 POST
到底有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/" title="都 2019 年了，还问 GET 和 POST 的区别">都 2019 年了，还问 GET 和
POST 的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zybuluo.com/JunQiu/note/1291674" title="四种常见的 POST 提交数据方式？">四种常见的 POST
提交数据方式</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/24/linux-2-curl%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/linux-2-curl%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">[linux] 2.curl命令行工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-24 16:12:31" itemprop="dateCreated datePublished" datetime="2020-11-24T16:12:31+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">linux指令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>curl 是常用的命令行工具(其实并非linux下的,windows
cmd也有，只是我在linux下使用),用来请求 Web 服务器。它的名字就是
<strong>客户端（client）的 URL 工具</strong>的意思。</p>
<p>不带有任何参数时，curl 就是发出 <strong>GET</strong> 请求。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure></p>
<h2><span id="d">-d</span><a href="#d" class="header-anchor">#</a></h2>
<p>-d参数用于发送 <strong>POST 请求</strong>的数据体。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -d&#39;login&#x3D;2333＆password&#x3D;2333&#39;-X POST https:&#x2F;&#x2F;google.com&#x2F;login</span><br></pre></td></tr></table></figure></p>
<h2><span id="x">-X</span><a href="#x" class="header-anchor">#</a></h2>
<p>-X参数 <strong>指定 HTTP 请求</strong>的方法。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST https:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure></p>
<h2><span id="h">-H</span><a href="#h" class="header-anchor">#</a></h2>
<p>-H参数 <strong>添加 HTTP 请求的标头</strong>。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &#39;Accept-Language: en-US&#39; https:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure>
上面命令添加 HTTP 标头Accept-Language: en-US。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &#39;Accept-Language: en-US&#39; -H &#39;Secret-Message: xyzzy&#39; https:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure>
<p>上面命令 <strong>添加两个 HTTP 标头</strong>。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -d &#39;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#39; -H &#39;Content-Type: application&#x2F;json&#39; https:&#x2F;&#x2F;google.com&#x2F;login</span><br></pre></td></tr></table></figure>
上面命令 <strong>添加 HTTP 请求的标头是Content-Type:
application/json</strong>，然后用-d参数发送 JSON 数据。</p>
<h2><span id="v">-v</span><a href="#v" class="header-anchor">#</a></h2>
<ul>
<li>-v参数输出通信的整个过程，用于调试。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure></li>
<li>-trace参数也可以用于调试，还会输出原始的二进制数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --trace - https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>
<h2><span id="o">-o</span><a href="#o" class="header-anchor">#</a></h2>
<p>-o参数将服务器的回应
<strong>保存成文件</strong>，等同于wget命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o baidu.html https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>
<p>上面命令将www.baidu.com保存成baidu.html。</p>
<h1><span id="bao-cuo-curl-35-unknown-ssl-protocol-error-in-connection-to-localhost-27183">报错curl:
(35) Unknown SSL protocol error in connection to localhost:27183</span><a href="#bao-cuo-curl-35-unknown-ssl-protocol-error-in-connection-to-localhost-27183" class="header-anchor">#</a></h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v https:&#x2F;&#x2F;localhost:27183&#x2F;abc</span><br><span class="line">* Hostname was NOT found in DNS cache</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* Connected to localhost (127.0.0.1) port 27183 (#0)</span><br><span class="line">* successfully set certificate verify locations:</span><br><span class="line">*   CAfile: none</span><br><span class="line">  CApath: &#x2F;etc&#x2F;ssl&#x2F;certs</span><br><span class="line">* SSLv3, TLS handshake, Client hello (1):</span><br><span class="line">* Unknown SSL protocol error in connection to localhost:27183</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (35) Unknown SSL protocol error in connection to localhost:27183</span><br></pre></td></tr></table></figure>
<p><strong>Possible reason</strong>：没有证书，本地用
<strong>http</strong>不能用https</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">[python源码分析] 装饰器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-19 12:58:11" itemprop="dateCreated datePublished" datetime="2020-11-19T12:58:11+08:00">2020-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">python源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要了解装饰器，首先我们来看看嵌套函数 ## 嵌套函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def adder(n):</span><br><span class="line">    def handler(x):</span><br><span class="line">        return n+x</span><br><span class="line">    return handler    #返回的是一个函数的引用</span><br></pre></td></tr></table></figure>
像 adder 函数和 handler
这样，在一个函数的函数体内定义另一个函数，就构成了 嵌套函数
。adder-handler 这段简单的代码包含了 3 个不同的作用域：</p>
<div style="width:80%;margin:auto">
<img src="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/wrapper_func.jpg" class title="wrapper_func图">
</div>
<p>作用域是一个 <strong>静态概念</strong>，由 Python
代码语法决定，与编译后产生的 代码对象
一一对应。作用域规定了能够被某个代码块访问的变量有哪些，但对变量具体的值则一概不关心。</p>
<p>一旦 Python 程序开始运行，<strong>虚拟机</strong>需要为
<strong>作用域中的变量</strong> 分配一定的
<strong>存储空间</strong>，这就是 <strong>名字空间</strong>
。名字空间依照作用域规则实现，它
<strong>决定了某个变量在运行时的取值</strong>，可以看做是
<strong>作用域在运行时的动态表现</strong>方式。</p>
<p>当 <strong>adder 函数执行</strong>时，作用域 A 在虚拟机中表现为 全局
名字空间，作用域 B 表现为 局部 名字空间：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">globals: adder</span><br><span class="line">locals: n, handler</span><br></pre></td></tr></table></figure>
当 <strong>handler 函数执行</strong>时，例如调用 adder(10) 时，作用域 A
在虚拟机中表现为 <strong>全局 名字空间</strong>，作用域 B 表现为
<strong>闭包 名字空间</strong>：作用域 C 表现为 <strong>局部
名字空间</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">globals: adder</span><br><span class="line">locals: x</span><br><span class="line">enclosure: n</span><br></pre></td></tr></table></figure></p>
<h2><span id="bi-bao">闭包</span><a href="#bi-bao" class="header-anchor">#</a></h2>
<h3><span id="shi-me-shi-bi-bao-ni">什么是闭包呢？</span><a href="#shi-me-shi-bi-bao-ni" class="header-anchor">#</a></h3>
<p><strong>闭包 ( closure )</strong> 是 <strong>词法闭包 ( Lexical
Closure )</strong> 的简称，指
<strong>延伸了作用域的函数</strong>，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。简单来说就是
<strong>嵌套函数引用了外层函数的变量</strong>。这些被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p>
<p>首先我们来看看adder(10)示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add10 &#x3D; adder(10)</span><br><span class="line">&gt;&gt;&gt; add10(10)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; add10(15)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
观察上面的例子，当函数 adder 返回，<strong>局部变量 n
应该就被回收了</strong>，为什么 <strong>handler
函数还能访问到它呢</strong>？这正是由于
<strong>闭包空间</strong>的存在。</p>
<p>以 adder(10) 为例，它是一个 handler 函数对象，闭包变量 n 值总是 10
。那么，内层函数是如何访问闭包作用域的呢？我们对函数代码对象进行反汇编，从中可以看出端倪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add10 &#x3D; adder(10)</span><br><span class="line">&gt;&gt;&gt; add10</span><br><span class="line">&lt;function adder.&lt;locals&gt;.handler at 0x10dc2b6a8&gt;</span><br><span class="line">&gt;&gt;&gt; add10.__code__</span><br><span class="line">&lt;code object handler at 0x10dbe5150, file &quot;&lt;stdin&gt;&quot;, line 2&gt;</span><br><span class="line">&gt;&gt;&gt; dis.dis(add10.__code__)</span><br><span class="line">  3           0 LOAD_DEREF               0 (n)      # 执行了闭包变量(藏于 PyFrameObject)查找工作</span><br><span class="line">              2 LOAD_FAST                0 (x)      # 局部变量(栈帧对象中)查找</span><br><span class="line">              4 BINARY_ADD</span><br><span class="line">              6 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>PyFrameObject 结构体最后部分是不固定的，依次存放着
<strong>静态局部名字空间、闭包名字空间以及临时栈</strong>。以 add10(1)
为例，函数运行时 PyFrameObject 状态如下如下：</p>
<div style="width:80%;margin:auto">
<img src="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/add10%E5%AE%9E%E4%BE%8B.jpg" class title="add10实例图">
</div>
<p>由于函数 <strong>局部变量、闭包变量个数</strong> 在
<strong>编译阶段</strong> 就能
<strong>确定</strong>，<strong>运行时并不会增减</strong>，因此
<strong>无须用 dict 对象来保存</strong>。相反，将这些变量依次排列
<strong>保存在数组</strong>中，然后通过数组下标来访问即可。这就是所谓的
<strong>静态名字空间</strong>。</p>
<p>对于局部变量 n ，数组对应的槽位保存着整数对象 1 的地址，表示 n 与 1
绑定。而闭包变量 x 则略有差别，槽位 <strong>不直接保存整数对象</strong>
10 ，而是通过一个 <strong>PyCellObject 间接</strong>与整数对象 10
绑定。</p>
<h3><span id="bi-bao-bian-liang-ru-he-chu-shi-hua">闭包变量如何初始化</span><a href="#bi-bao-bian-liang-ru-he-chu-shi-hua" class="header-anchor">#</a></h3>
<p>函数对象 <strong>PyFunctionObject</strong> 中有一个字段
<strong>func_closure</strong> ，保存着函数
<strong>所有闭包变量</strong>。我们可以通过名字
<strong><strong>closure</strong></strong> 可以 <strong>访问</strong>
到这个底层结构体字段：</p>
<blockquote>
<blockquote>
<blockquote>
<p>add10.__closure__ (&lt;cell at 0x10dc09e28: int object at
0x10da161a0&gt;,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>这是一个由 *<strong>PyCellObject</strong> 组成的
<strong>元组</strong>，PyCellObject 则
<strong>保存着闭包变量的值</strong>。当函数调用发生时，Python 虚拟机创建
<strong>PyFrameObject 对象</strong>，并从
<strong>函数对象取出该元组，依次填充相关静态槽位</strong>。</p>
<div style="width:80%;margin:auto">
<img src="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%B8%A7.jpg" class title="闭包与运行帧图">
</div>
<h3><span id="wei-shi-me-bi-bao-bian-liang-yao-tong-guo-pycellobject-jian-jie-yin-yong">为什么闭包变量要通过
PyCellObject 间接引用?</span><a href="#wei-shi-me-bi-bao-bian-liang-yao-tong-guo-pycellobject-jian-jie-yin-yong" class="header-anchor">#</a></h3>
<p>最新的 Python(3.7+) 提供了 <strong>nonlocal</strong> 关键字，支持
<strong>修改闭包变量</strong>。如果没有 PyCellObject ，函数在运行时
<strong>直接修改 PyFrameObject</strong>
，<strong>函数返回就被回收了</strong>。借助 PyCellObject
，<strong>函数在运行时修改的是 ob_ref</strong>
。这样一来，<strong>就算函数返回，修改还是随函数而存在</strong>。</p>
<h3><span id="shi-li-li-jie">示例理解</span><a href="#shi-li-li-jie" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lst &#x3D; []</span><br><span class="line">for i in arange(5):</span><br><span class="line">  def f ():</span><br><span class="line">    print (i)</span><br><span class="line">  print (f)</span><br><span class="line">  lst.append(f)</span><br><span class="line"></span><br><span class="line">for f in lst:</span><br><span class="line">  f()  </span><br></pre></td></tr></table></figure>
<p>输出为
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;function f at 0x000001E36692FE58&gt;  &#x2F;&#x2F;函数对象是动态生成的</span><br><span class="line">&lt;function f at 0x000001E366949048&gt;</span><br><span class="line">&lt;function f at 0x000001E36694E798&gt;</span><br><span class="line">&lt;function f at 0x000001E36694E4C8&gt;</span><br><span class="line">&lt;function f at 0x000001E36694E708&gt;</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
这是因为 <strong>闭包变量</strong>是通过 <strong>PyCellObject
间接引用</strong>，PyCellObject中的
ob_ref指针指向了i这个对象，而i最后变成了4。</p>
<p>若要正常输出0，1，2，3，4，应该怎么修改呢？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lst &#x3D; []</span><br><span class="line">for i in arange(5):</span><br><span class="line">  def f (i &#x3D; i):</span><br><span class="line">    print (i)</span><br><span class="line">  lst.append(f)</span><br><span class="line"></span><br><span class="line">for f in lst:</span><br><span class="line">  f()  </span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>这里的i是局部变量</p>
<h2><span id="zhuang-shi-qi">装饰器</span><a href="#zhuang-shi-qi" class="header-anchor">#</a></h2>
<p>前面我们了解了 <strong>嵌套函数和闭包</strong>，我们可以
<strong>让函数具备搭积木的魔法</strong>，例如：打印函数的执行时间。</p>
<p>事不宜迟，我们来实践一下，实现 timer 函数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def timer(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        start &#x3D; time.time()</span><br><span class="line">        func(*args, **kwargs) #此处拿到了被装饰的函数func</span><br><span class="line">        time.sleep(2)#模拟耗时操作</span><br><span class="line">        long &#x3D; time.time() - start</span><br><span class="line">        print(f&#39;共耗时&#123;long&#125;秒。&#39;)</span><br><span class="line">    return wrapper          #返回内层函数的引用</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def add(a, b):</span><br><span class="line">    print(a+b)</span><br><span class="line"></span><br><span class="line">add(1, 2) #正常调用add</span><br></pre></td></tr></table></figure>
timer被我们改造成了
<strong>装饰器</strong>，它接受被装饰函数为入参，返回内部
<strong>嵌套函数的引用</strong>（注意：<strong>此处并未执行函数</strong>），内部嵌套函数
<strong>wrapper持有被装饰函数的引用即func</strong>。</p>
<p>“@”是Python的语法糖，它的作用类似于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add &#x3D; timer(add) #此处返回的是timer.&lt;locals&gt;.wrapper函数引用</span><br><span class="line">add(1, 2)</span><br></pre></td></tr></table></figure></p>
<div style="width:80%;margin:auto">
<img src="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/timer%E5%87%BD%E6%95%B0.jpg" class title="timer函数图">
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/18/svn-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/18/svn-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/" class="post-title-link" itemprop="url">[svn]常用命令行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-18 14:18:12" itemprop="dateCreated datePublished" datetime="2020-11-18T14:18:12+08:00">2020-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2><span id="xia-zai-wen-jian-dao-ben-di-mu-lu">下载文件到本地目录</span><a href="#xia-zai-wen-jian-dao-ben-di-mu-lu" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn checkout path（path是服务器 上的目录）</span><br><span class="line">例如：svn checkout svn:&#x2F;&#x2F;192.168.1.1&#x2F;pro&#x2F;domain</span><br><span class="line">简写：svn co</span><br></pre></td></tr></table></figure>
<h2><span id="cha-kan-dang-qian-dang-qian-xiang-mu-di-zhi">查看当前当前项目地址</span><a href="#cha-kan-dang-qian-dang-qian-xiang-mu-di-zhi" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn info （这里返回的是root路径）</span><br><span class="line"></span><br><span class="line">svn info filename （返回的时特定文件filename的路径）</span><br></pre></td></tr></table></figure>
<h2><span id="qie-huan-fen-zhi-svn-sw">切换分支（svn sw）</span><a href="#qie-huan-fen-zhi-svn-sw" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svn sw &lt;branch_full_url&gt;</span><br><span class="line"></span><br><span class="line">sample：</span><br><span class="line">svn sw https:&#x2F;&#x2F;mysvn.cn&#x2F;svn&#x2F;repo&#x2F;project&#x2F;branches&#x2F;version-xxx</span><br></pre></td></tr></table></figure>
<h2><span id="cha-kan-ri-zhi">查看日志</span><a href="#cha-kan-ri-zhi" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn log path</span><br><span class="line">sample：svn log test.php  （显示这个文件的所有修改记录，及其版本号的变化）</span><br></pre></td></tr></table></figure>
<h2><span id="bi-jiao-chai-yi">比较差异</span><a href="#bi-jiao-chai-yi" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">svn diff path(将修改的文件与基础版本比较)</span><br><span class="line">sample：svn diff test.php</span><br><span class="line"></span><br><span class="line">svn diff -r m:n path(对版本m和版本n比较差异)</span><br><span class="line">sample：svn diff -r 200:201 test.php</span><br><span class="line"></span><br><span class="line">简写：svn di</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/16/python-%E5%BC%B1%E5%BC%95%E7%94%A8weakref%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/16/python-%E5%BC%B1%E5%BC%95%E7%94%A8weakref%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">[python]弱引用weakref介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-16 20:19:27" itemprop="dateCreated datePublished" datetime="2020-11-16T20:19:27+08:00">2020-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虽然一般情况下python无需像cpp一样需要手动
内存申请和释放，但是某些情况，我们需要自己去管理对象的销毁，让它的生命周期符合我们的预期。weakref就是一种方式。</p>
<h2><span id="1-gai-nian">1. 概念</span><a href="#1-gai-nian" class="header-anchor">#</a></h2>
<p>首先需要了解的是在 Python 里每个对象都有一个
<strong>引用计数</strong>，当这个引用计数为 0 时，Python 的garbage
collection(GC)是可以 <strong>安全销毁这个对象</strong>的，
比如对一个对象创建引用则计数加 1,删除引用则计数减 1 。</p>
<p>weakref 模块允许
<strong>对一个对象创建弱引用</strong>，弱引用不像正常引用,
<strong>弱引用不会增加引用计数</strong>，也就是说
<strong>当一个对象上只有弱引用时，GC是可以销毁该对象的</strong>。</p>
<h2><span id="2-weakref-ref">2 weakref.ref</span><a href="#2-weakref-ref" class="header-anchor">#</a></h2>
<h3><span id="2-1-weakref-ref-yong-fa">2.1 weakref.ref用法</span><a href="#2-1-weakref-ref-yong-fa" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import weakref</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; class DBO(object):</span><br><span class="line">...     pass</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dbo1 &#x3D; DBO()                    # 创建对象，引用+1</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)           # 调用sys.getrefcount，该函数引用了dbo1，对象引用+1</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; weakref_dbo &#x3D; weakref.ref(dbo1) # 创建弱引用</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)           # 弱引用没有增加引用计数</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; weakref_dbo                     # 弱引用指向的对象</span><br><span class="line">&lt;weakref at 0x7f9b0316d3c0; to &#39;DBO&#39; at 0x7f9b03166ed0&gt;</span><br><span class="line">&gt;&gt;&gt; dbo2 &#x3D; weakref_dbo()            # 获取弱引用指向的对象</span><br><span class="line">&gt;&gt;&gt; dbo1 is dbo2                    # dbo1和dbo2引用的是同一个对象</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)           # 对象上的引用计数加 1</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo2)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; dbo1 &#x3D; None                     # 删除引用</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)           # 这个数字是None对象的引用次数</span><br><span class="line">2545</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; weakref_dbo</span><br><span class="line">&lt;weakref at 0x7f9b0316d3c0; to &#39;DBO&#39; at 0x7f9b03166ed0&gt;</span><br><span class="line">&gt;&gt;&gt; dbo2 &#x3D; None                     # 删除引用</span><br><span class="line">&gt;&gt;&gt; weakref_dbo                     # 当对象引用计数为0时，弱引用失效</span><br><span class="line">&lt;weakref at 0x7f9b0316d3c0; dead&gt;</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)</span><br><span class="line">2546</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<h3><span id="2-1-weakref-ref-yuan-ma">2.1 weakref.ref源码</span><a href="#2-1-weakref-ref-yuan-ma" class="header-anchor">#</a></h3>
<p>接下来我们看看它的源码套餐，定义在objects/weakrefObjects.c中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyWeakref_NewRef(PyObject *ob, PyObject *callback)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*PyWeakReference是一个弱引用对象，result做临时存储*&#x2F;</span><br><span class="line">    PyWeakReference *result &#x3D; NULL;</span><br><span class="line">    PyWeakReference **list;</span><br><span class="line">    PyWeakReference *ref, *proxy;</span><br><span class="line">    &#x2F;*检查当前对象类型是否支持弱引用*&#x2F;</span><br><span class="line">    if (!PyType_SUPPORTS_WEAKREFS(Py_TYPE(ob))) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     &quot;cannot create weak reference to &#39;%s&#39; object&quot;,</span><br><span class="line">                     Py_TYPE(ob)-&gt;tp_name);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*获取弱引用链表指针*&#x2F;</span><br><span class="line">    list &#x3D; GET_WEAKREFS_LISTPTR(ob);</span><br><span class="line">    &#x2F;*根据*list，给 ref 和 proxy 赋值*&#x2F;</span><br><span class="line">    get_basic_refs(*list, &amp;ref, &amp;proxy);</span><br><span class="line">    if (callback &#x3D;&#x3D; Py_None)</span><br><span class="line">        callback &#x3D; NULL;</span><br><span class="line">    if (callback &#x3D;&#x3D; NULL)</span><br><span class="line">        &#x2F;* return existing weak reference if it exists *&#x2F;</span><br><span class="line">        result &#x3D; ref;</span><br><span class="line">    if (result !&#x3D; NULL)</span><br><span class="line">        &#x2F;*给当前weak reference引用加1*&#x2F;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;* Note: new_weakref() can trigger cyclic GC, so the weakref</span><br><span class="line">           list on ob can be mutated.  This means that the ref and</span><br><span class="line">           proxy pointers we got back earlier may have been collected,</span><br><span class="line">           so we need to compute these values again before we use</span><br><span class="line">           them.</span><br><span class="line">            使用之前，先确认ob对象没有被析构</span><br><span class="line">            *&#x2F;</span><br><span class="line">        result &#x3D; new_weakref(ob, callback);</span><br><span class="line">        if (result !&#x3D; NULL) &#123;</span><br><span class="line">            get_basic_refs(*list, &amp;ref, &amp;proxy);</span><br><span class="line">            if (callback &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                if (ref &#x3D;&#x3D; NULL)</span><br><span class="line">                    insert_head(result, list);</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;* Someone else added a ref without a callback</span><br><span class="line">                       during GC.  Return that one instead of this one</span><br><span class="line">                       to avoid violating the invariants of the list</span><br><span class="line">                       of weakrefs for ob. *&#x2F;</span><br><span class="line">                    Py_DECREF(result);</span><br><span class="line">                    Py_INCREF(ref);</span><br><span class="line">                    result &#x3D; ref;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                PyWeakReference *prev;</span><br><span class="line"></span><br><span class="line">                prev &#x3D; (proxy &#x3D;&#x3D; NULL) ? ref : proxy;</span><br><span class="line">                if (prev &#x3D;&#x3D; NULL)</span><br><span class="line">                    insert_head(result, list);</span><br><span class="line">                else</span><br><span class="line">                    insert_after(result, prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (PyObject *) result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>weakref.proxy proxy
像是弱引用对象，它们的行为就是它们所引用的对象的行为，这样就
<strong>不必 首先调用弱引用对象来访问背后的对象</strong>。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from socket import *</span><br><span class="line">&gt;&gt;&gt; s &#x3D; socket(AF_INET, SOCK_STREAM)</span><br><span class="line">&gt;&gt;&gt; ref_s &#x3D; weakref.ref(s)</span><br><span class="line">&gt;&gt;&gt; ref_s</span><br><span class="line">&lt;weakref at 0x7f9b0316d3c0; to &#39;_socketobject&#39; at 0x7f9b0310b910&gt;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;socket._socketobject object at 0x7f9b0310b910&gt;</span><br><span class="line">&gt;&gt;&gt; proxy_s &#x3D; weakref.proxy(s)</span><br><span class="line">&gt;&gt;&gt; proxy_s</span><br><span class="line">&lt;weakproxy at 0x7f9b03117208 to _socketobject at 0x7f9b0310b910&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; ref_s.close()               #  不能直接调用对象方法</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#39;weakref&#39; object has no attribute &#39;close&#39;</span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>&gt;&gt;&gt; ref_s().close()              #  不能直接调用对象方法，要加上()
&gt;&gt;&gt;
&gt;&gt;&gt; proxy_s.close()              #  可以直接调用对象方法
&gt;&gt;&gt; 
&gt;&gt;&gt; sys.getrefcount(s)
2
&gt;&gt;&gt; ref_s
&lt;weakref at 0x7f9b0316d3c0; to &#39;_socketobject&#39; at 0x7f9b0310b910&gt;
&gt;&gt;&gt; r = ref_s()
&gt;&gt;&gt; r.close()
&gt;&gt;&gt; sys.getrefcount(s)
3
&gt;&gt;&gt; ref_s
&lt;weakref at 0x7f9b0316d3c0; to &#39;_socketobject&#39; at 0x7f9b0310b910&gt;
&gt;&gt;&gt; del ref_s
&gt;&gt;&gt; ref_s
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;ref_s&#39; is not defined
&gt;&gt;&gt;</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/15/TCP-IP%E5%8D%B7%E4%B8%80-1-Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/TCP-IP%E5%8D%B7%E4%B8%80-1-Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">[TCP/IP卷一]1.Internet地址结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-15 23:01:21" itemprop="dateCreated datePublished" datetime="2020-11-15T23:01:21+08:00">2020-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近打算读一下计算机网路领域的圣经，并将一些重要知识点总结记录下来。</p>
<h2><span id="1-1-yin-yan">1.1 引言</span><a href="#1-1-yin-yan" class="header-anchor">#</a></h2>
<p>链接到Internet的设备都必须有一个
<strong>IP地址</strong>。基于TCP/IP协议的专用网络中
<strong>使用的设备</strong> 也具有IP地址。
<strong>IP路由器</strong>实现的转发程序使用IP地址来
<strong>识别流量去向</strong>；IP地址也表示流量的来源。
IP地址与电话号码类似，但人们知道电话号码，而 IP地址通常被Internet中的
<strong>DNS</strong>屏蔽在用户视野之外， DNS实现大多数人使用的是
<strong>名字</strong>而非数字化的IP地址。</p>
<p>个人用户通常由Internet <strong>服务商（ISP）分配</strong>
地址，通过支付费用来获得地址和执行路由。</p>
<h2><span id="1-2-biao-shi-ip-di-zhi">1.2 表示IP地址</span><a href="#1-2-biao-shi-ip-di-zhi" class="header-anchor">#</a></h2>
<ul>
<li><p>IPv4地址，通常采用
<strong>点分四组或者点分十进制表示法（192.168.0.1）</strong>。点分四组表示法由
四个用点分隔的十进制数组成。每个数字都是
<strong>[0,255]的非负整数(8位二进制可以表示)</strong>，代表整个IP地址的四分之一（共占32位大小）。</p></li>
<li><p>IPv6，地址长度为
<strong>128位</strong>，是IPv4的四倍，它通常采用成为<strong>块或者字段的四个十六进制数（一个块大小为16位）</strong>，这些数用冒号分隔。
例如一个包含8个块的IPv6可以写成
5f05:2000:80ad:5800:0058:0800:2023:1d71。虽然不像用户熟悉的十进制数，但将十六进制转换为二级制更容易。另外IPv6可以简化成标准化的
<strong>[RFC4291]</strong>:</p></li>
<li><ol type="1">
<li>一个块的前导零不必书写，如上面可以写成：5f05:2000:80ad:5800:58:800:2023:1d71</li>
</ol></li>
<li><ol start="2" type="1">
<li>全零块可以省略，用::代替，例如 0：0：0：0：0：0：0：1可以写成
::1。为了避免歧义，<strong>一个IPv6中::只能使用一次</strong>。</li>
</ol></li>
<li><ol start="3" type="1">
<li>IPv6格式嵌入IPv4地址可使用混合符号形式，如IPv6地址::ffff:10.0.0.1可以表示IPv4地址为10.0.0.1。</li>
</ol></li>
<li><ol start="4" type="1">
<li>IPv6的
<strong>低32位通常用点分四组法</strong>。Ipv6地址::0102::f001相当于地址::1.2.240.1。它被称为IPv4兼容的IPv6地址。</li>
</ol></li>
</ul>
<p>后面<strong>[RFC5952]</strong>做了命名新的优化，这里不细讲了。</p>
<h2><span id="1-3-ji-ben-de-ip-di-zhi-jie-gou">1.3 基本的IP地址结构</span><a href="#1-3-ji-ben-de-ip-di-zhi-jie-gou" class="header-anchor">#</a></h2>
<p>IPv4 地址空间中有 4 294 967 296(2^32)个可能的地址，而
IPv6地址个数为(2^128)：(不列了，实在太大了，根本用不完)。由于拥有大量地址，可以方便将地址空间
<strong>分为一个一个块</strong>。</p>
<h3><span id="1-3-1-dan-bo-di-zhi">1.3.1 单播地址</span><a href="#1-3-1-dan-bo-di-zhi" class="header-anchor">#</a></h3>
<p>大多IPv4地址块被 <strong>最终细分为一个地址</strong>，用于
<strong>识别链接Internet或某些专用的内联网计算机网络接口</strong>。这些就是单播地址(IPv4
<strong>大部分都是单播地址空间</strong>)</p>
<p>除了单播地址，还有 <strong>广播，组播和任播地址</strong>。</p>
<h3><span id="1-3-2-fen-lei-xun-zhi">1.3.2 分类寻址</span><a href="#1-3-2-fen-lei-xun-zhi" class="header-anchor">#</a></h3>
<ul>
<li>每个IP单播地址 =
<strong>网络部分(识别接口使用的iP地址在哪个网络可被发现) +
主机地址(识别网络部分下的特定主机)</strong>。 因此地址中一些连续位称为
<strong>网络号</strong>，其余称为 <strong>主机号</strong>。</li>
<li>现实中 <strong>不同网络下主机数量不一</strong>，
每台主机都需要一个唯一IP。 --
方案1：基于当前或预计主机数量，将不同大小的IP地址空间分配给不同的站点。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/" class="post-title-link" itemprop="url">[python源码分析] 4.不溢出的整数int</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-14 16:05:47" itemprop="dateCreated datePublished" datetime="2020-11-14T16:05:47+08:00">2020-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">python源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="zheng-shu-yi-chu">整数溢出</span><a href="#zheng-shu-yi-chu" class="header-anchor">#</a></h1>
<p>c语言中，32位机器的int 长度为32 位，表示的范围: [-2147483648,
2147483647], 超过这个范围就会溢出了。
由于整数溢出现象的存在，程序员需要结合业务场景，<strong>谨慎选择数据类型</strong>。</p>
<p>而在python中，就没有整数溢出的烦恼。 Python
可以计算十的一百次方，这在其他语言是不可想象的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 ** 100</span><br><span class="line">10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>
也许我们过去都接触过
<strong>c语言大整数的实现</strong>，接下来我们来看看python如何实现大整数。</p>
<h1><span id="int-dui-xiang">int 对象</span><a href="#int-dui-xiang" class="header-anchor">#</a></h1>
<p>int 对象在 Include/longobject.h 头文件中定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _longobject PyLongObject; &#x2F;* Revealed in longintrepr.h *&#x2F;</span><br></pre></td></tr></table></figure>
顺着注释去 Include/longintrepr.h 中，找到了实现 int 对象的结构体：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct _longobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD        &#x2F;*可变长对象都具有的公共头部*&#x2F;</span><br><span class="line">    digit ob_digit[1];     &#x2F;*这里存储int的整数值*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在 Include/longintrepr.h 头文件，可以找到 <strong>digit</strong>
字段的定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PYLONG_BITS_IN_DIGIT &#x3D;&#x3D; 30</span><br><span class="line">typedef uint32_t digit;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">#elif PYLONG_BITS_IN_DIGIT &#x3D;&#x3D; 15</span><br><span class="line">typedef unsigned short digit;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
由此可知<strong>digit 就是一个 C 语言整数</strong>，因此 <strong>int
对象是通过整数数组来实现大整数的</strong>。至于整数数组用什么整数类型来实现，
Python 提供了两个版本，一个是 <strong>32 位的 uint32_t ，一个是 16 位的
unsigned short</strong> ，编译 Python 解析器时可以
<strong>通过宏定义指定选用的版本</strong>。</p>
<p>Python 作者为什么要这样设计呢？这主要是
<strong>出于内存方面的考量：对于范围不大的整数，用 16
位整数表示即可</strong>，用 32 位就有点浪费。</p>
<p>整数对象| 对象大小（16位）| 对象大小（32位） -:-|-:-|-:- 1|24 + 2 * 1
= 26|24 + 4 * 1 = 28 1000000 |24 + 2 * 2 = 28|24 + 4 * 1 = 28
10000000000 |24 + 2 * 3 = 30|24 + 4 * 2 = 32</p>
<hr>
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/PyIntObject.jpg" class title="PyIntObject图">
</div>
<h5><span id="q-ob-digit-shu-zu-chang-du-ke-neng-da-yu-1-er-wei-shi-me-zai-jie-gou-ti-ding-yi-zhong-ob-digit-shu-zu-chang-du-que-gu-ding-wei-1">Q：ob_digit
数组长度可能大于1，而为什么在结构体定义中， ob_digit 数组长度却固定为
1？</span><a href="#q-ob-digit-shu-zu-chang-du-ke-neng-da-yu-1-er-wei-shi-me-zai-jie-gou-ti-ding-yi-zhong-ob-digit-shu-zu-chang-du-que-gu-ding-wei-1" class="header-anchor">#</a></h5>
<p>由于 C 语言中 <strong>数组长度不是类型信息</strong>，我们可以
<strong>根据实际需要为 ob_digit 数组分配足够的内存，并将其当成长度为 n
的数组</strong>操作。这也是 C 语言中一个常用的编程技巧。长度信息在
<strong>PyVarObject(PyVarObject比PyObjcet多了个ob_size字段，详细定义可以看<a target="_blank" rel="noopener" href="http://liuw.tech/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%AF%B9%E8%B1%A1/" title="[python源码分析] 1.对象">[python源码分析]
1.对象</a>)中的ob_size中</strong>。</p>
<h1><span id="shi-xian-da-zheng-shu">实现大整数</span><a href="#shi-xian-da-zheng-shu" class="header-anchor">#</a></h1>
<p>整数分为 <strong>正数 、 负数 和 零</strong> ， Python 规定不同整数在
int 对象中的存储方式，要点可以总结为 3 条：</p>
<p>整数 <strong>绝对值</strong> 根据实际情况分为若干部分，保存于
ob_digit 数组中； <strong>ob_digit 数组长度 保存于 ob_size
字段</strong>，对于 <strong>负整数 的情况，ob_size
为负</strong>（这里可以说就很精妙了）； 整数 <strong>零 以 ob_size 等于
0 来表示</strong>，<strong>ob_digit 数组为空</strong>； 接下来，我们以 5
个典型的例子详细介绍这几条规则：</p>
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/bigInt.jpg" class title="bigInt图">
</div>
<ol type="1">
<li>对于整数 0 ， ob_size 字段等于 0 ， ob_digit
数组为空，无需分配。</li>
<li>对于整数 10 ，其绝对值保存于 ob_digit 数组中，数组长度为 1 ，
ob_size 字段等于 1 。</li>
<li>对于整数 -10 ，其绝对值同样保存于 ob_digit 数组中，但由于 -10
为负数， <strong>ob_size 字段等于 -1</strong> 。</li>
<li>对于整数 1073741824 ( 2 的 30 次方)，由于 <strong>Python 只使用 32
整数的后 30 位</strong>，因此
<strong>需要另一个整数才能存储</strong>，整数数组长度为 2
。绝对值这样计算：<span class="math inline">\(2^{30}*1+2^0*0=10737418242\)</span></li>
<li>对于整数 -4294967297 (负的 2 的 32 次方加 1 )，同样要长度为 2 的
ob_digit 数组，但 ob_size 字段为负。绝对值这样计算：<span class="math inline">\(2^{30}*4+2^0*1=42949672972\)</span></li>
</ol>
<h3><span id="wei-shi-me-python-zhi-yong-ob-digit-shu-zu-zheng-shu-de-hou-30-wei">为什么 Python
只用 ob_digit 数组整数的后 30 位？</span><a href="#wei-shi-me-python-zhi-yong-ob-digit-shu-zu-zheng-shu-de-hou-30-wei" class="header-anchor">#</a></h3>
<p>这跟 <strong>加法进位有关</strong>。如果全部 32
位都用来保存绝对值，那么为了保证加法不溢出(产生进位)，需要先强制转换成
64 位类型后在进行计算。但 <strong>牺牲最高 1
位后，加法运算便不用担心进位溢出了</strong>。那么，为什么 Python
牺牲最高 2 位呢？应该是 <strong>为了和 16 位整数方案统一起来：如果选用
16 位整数作为数组， Python 则只使用其中 15 位</strong>。</p>
<h1><span id="xiao-zheng-shu-jing-tai-dui-xiang-chi">小整数静态对象池</span><a href="#xiao-zheng-shu-jing-tai-dui-xiang-chi" class="header-anchor">#</a></h1>
<p>小整数对象池在 Objects/longobject.c 中实现，关键代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*小整数池的范围通过宏来定义的, 默认是-5-257,我们可以通过修改此处的宏来调整小整数池的大小, 但是需要对python进行重新编译*&#x2F;</span><br><span class="line">#ifndef NSMALLPOSINTS</span><br><span class="line">#define NSMALLPOSINTS           257   &#x2F;*该宏规定了对象池 正数个数 (从 0 开始，包括 0 )，默认 257 个*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#ifndef NSMALLNEGINTS</span><br><span class="line">#define NSMALLNEGINTS           5     &#x2F;*该宏规定了对象池 负数个数 ，默认 5 个*&#x2F;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];  &#x2F;*一个整数对象数组，保存预先创建好的小整数对象*&#x2F;</span><br></pre></td></tr></table></figure></p>
<p>如果在[-5,
257)范围内，会直接返回存于small_ints的对象，所以小整数只会存在一个实例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; longobject.c</span><br><span class="line">static PyObject * </span><br><span class="line">get_small_int(sdigit ival)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    assert(-NSMALLNEGINTS &lt;&#x3D; ival &amp;&amp; ival &lt; NSMALLPOSINTS);</span><br><span class="line">    v &#x3D; (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">#ifdef COUNT_ALLOCS</span><br><span class="line">    if (ival &gt;&#x3D; 0)</span><br><span class="line">        quick_int_allocs++;</span><br><span class="line">    else</span><br><span class="line">        quick_neg_int_allocs++;</span><br><span class="line">#endif</span><br><span class="line">    return v;</span><br></pre></td></tr></table></figure></p>
<p>至于为什么选择静态缓存从 <strong>-5 到 256</strong>
之间的小整数，主要是出于某种 权衡 ：<strong>这个范围内的整数使用
频率很高 ，而缓存这些小整数的 内存开销相对可控</strong>
。很多程序开发场景都没有固定的正确答案，需要根据实际情况平衡利弊。</p>
<p>理解了静态对象池，如下现象就很好理解了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1 + 0</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1 * 1</span><br><span class="line">&gt;&gt;&gt; id(a), id(b)</span><br><span class="line">(4408209536, 4408209536)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c &#x3D; 1000 + 0</span><br><span class="line">&gt;&gt;&gt; d &#x3D; 1000 * 1</span><br><span class="line">&gt;&gt;&gt; id(c), id(d)</span><br><span class="line">(4410298224, 4410298160)</span><br></pre></td></tr></table></figure></p>
<p>由于整数对象是 <strong>不可变对象</strong>
，任何<strong>整数运算结果都以新对象返回</strong>，而<strong>对象创建销毁开销却不小</strong>。为了优化整数对象的性能，
Python 在启动时将使用 频率较高 的小整数预先创建好，这就是
<strong>小整数缓存池</strong> 。默认情况下，小整数缓存池缓存 <strong>从
-5 到 256 之间的整数</strong>。</p>
<h1><span id="shu-xue-yun-suan">数学运算</span><a href="#shu-xue-yun-suan" class="header-anchor">#</a></h1>
根据我们在 PyTypeObject 中学到的知识，对象的行为由对象的 类型
决定。因此，整数对象
<strong>数学运算的秘密藏在整数类型对象中</strong>。在
<strong>Objects/longobject.c</strong> 中找到整数类型对象( PyLong_Type
)，其定义如下所示：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;int&quot;,                                      &#x2F;* tp_name *&#x2F;</span><br><span class="line">    offsetof(PyLongObject, ob_digit),           &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    sizeof(digit),                              &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_vectorcall_offset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_getattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_async *&#x2F;</span><br><span class="line">    long_to_decimal_string,                     &#x2F;* tp_repr *&#x2F;</span><br><span class="line">    &amp;long_as_number,                            &#x2F;* tp_as_number *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc)long_hash,                        &#x2F;* tp_hash *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_call *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_str *&#x2F;</span><br><span class="line">    PyObject_GenericGetAttr,                    &#x2F;* tp_getattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_buffer *&#x2F;</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               &#x2F;* tp_flags *&#x2F;</span><br><span class="line">    long_doc,                                   &#x2F;* tp_doc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_traverse *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_clear *&#x2F;</span><br><span class="line">    long_richcompare,                           &#x2F;* tp_richcompare *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_weaklistoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iter *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iternext *&#x2F;</span><br><span class="line">    long_methods,                               &#x2F;* tp_methods *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_members *&#x2F;</span><br><span class="line">    long_getset,                                &#x2F;* tp_getset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_base *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dict *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_get *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_set *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dictoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_init *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_alloc *&#x2F;</span><br><span class="line">    long_new,                                   &#x2F;* tp_new *&#x2F;</span><br><span class="line">    PyObject_Del,                               &#x2F;* tp_free *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
类型对象中， <strong>tp_as_number 是一个关键字段。该字段指向一个
PyNumberMethods 结构体</strong>，结构体保存了 <strong>各种数学运算的
函数指针 </strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static PyNumberMethods long_as_number &#x3D; &#123;</span><br><span class="line">    (binaryfunc)long_add,       &#x2F;*nb_add*&#x2F;</span><br><span class="line">    (binaryfunc)long_sub,       &#x2F;*nb_subtract*&#x2F;</span><br><span class="line">    (binaryfunc)long_mul,       &#x2F;*nb_multiply*&#x2F;</span><br><span class="line">    long_mod,                   &#x2F;*nb_remainder*&#x2F;</span><br><span class="line">    long_divmod,                &#x2F;*nb_divmod*&#x2F;</span><br><span class="line">    long_pow,                   &#x2F;*nb_power*&#x2F;</span><br><span class="line">    (unaryfunc)long_neg,        &#x2F;*nb_negative*&#x2F;</span><br><span class="line">    (unaryfunc)long_long,       &#x2F;*tp_positive*&#x2F;</span><br><span class="line">    (unaryfunc)long_abs,        &#x2F;*tp_absolute*&#x2F;</span><br><span class="line">    (inquiry)long_bool,         &#x2F;*tp_bool*&#x2F;</span><br><span class="line">    (unaryfunc)long_invert,     &#x2F;*nb_invert*&#x2F;</span><br><span class="line">    long_lshift,                &#x2F;*nb_lshift*&#x2F;</span><br><span class="line">    (binaryfunc)long_rshift,    &#x2F;*nb_rshift*&#x2F;</span><br><span class="line">    long_and,                   &#x2F;*nb_and*&#x2F;</span><br><span class="line">    long_xor,                   &#x2F;*nb_xor*&#x2F;</span><br><span class="line">    long_or,                    &#x2F;*nb_or*&#x2F;</span><br><span class="line">    long_long,                  &#x2F;*nb_int*&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
下图展示了 <strong>整数对象 、 整数类型对象 以及
整数数学运算处理函数</strong> 之间的关系：
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/IntOp.jpg" class title="IntOp图">
</div>
<h3><span id="jia-fa">加法</span><a href="#jia-fa" class="header-anchor">#</a></h3>
<p>如何为一个由数组表示的大整数实现加法？问题答案得在 long_add
函数中找，该函数是整数对象 加法处理函数 。我们再接再厉，扒开 long_add
函数看个究竟(同样位于 Objects/longobject.c )：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">long_add(PyLongObject *a, PyLongObject *b)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;*定义变量 z 用于临时保存计算结果*&#x2F;</span><br><span class="line">    PyLongObject *z;  </span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    如果参与运算的整数对象底层数组长度均不超过 1 ，直接用 MEDIUM_VALUE 宏将整数对象转化成 C 整数类型进行运算，</span><br><span class="line">    性能损耗极小。满足这个条件的整数范围在 -1073741823~1073741823 之间，足以覆盖程序运行时的绝大部分运算场景</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (Py_ABS(Py_SIZE(a)) &lt;&#x3D; 1 &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;&#x3D; 1) &#123;</span><br><span class="line">        return PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    if (Py_SIZE(a) &lt; 0) &#123;</span><br><span class="line">        if (Py_SIZE(b) &lt; 0) &#123;</span><br><span class="line">          &#x2F;*如果两个整数均为 负数 ，调用 x_add 计算两者绝对值之和，再将结果符号设置为负( 16 行处)*&#x2F;</span><br><span class="line">            z &#x3D; x_add(a, b);</span><br><span class="line">            if (z !&#x3D; NULL) &#123;</span><br><span class="line">                assert(Py_REFCNT(z) &#x3D;&#x3D; 1);</span><br><span class="line">                Py_SIZE(z) &#x3D; -(Py_SIZE(z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;*如果 a 为负数， b 为正数，调用 x_sub 计算 b 和 a 的绝对值之差即为最终结果*&#x2F;</span><br><span class="line">        else</span><br><span class="line">            z &#x3D; x_sub(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (Py_SIZE(b) &lt; 0)</span><br><span class="line">            z &#x3D; x_sub(a, b);</span><br><span class="line">        else</span><br><span class="line">        &#x2F;*如果两个整数均为正数，调用 x_add 计算两个绝对值之和即为最终结果*&#x2F;</span><br><span class="line">            z &#x3D; x_add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    return (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### x_add x_add 用于计算两个整数对象绝对值之和，源码同样位于
Objects/longobject.c ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static PyLongObject *</span><br><span class="line">x_add(PyLongObject *a, PyLongObject *b)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;*取ob_size的绝对值*&#x2F;</span><br><span class="line">    Py_ssize_t size_a &#x3D; Py_ABS(Py_SIZE(a)), size_b &#x3D; Py_ABS(Py_SIZE(b));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*用变量z 临时存储计算结果*&#x2F;</span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    &#x2F;*临时进位*&#x2F;</span><br><span class="line">    digit carry &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ensure a is the larger of the two: *&#x2F;</span><br><span class="line">    if (size_a &lt; size_b) &#123;</span><br><span class="line">     &#x2F;*如果 a 数组长度比较小，将 a 、 b 交换，数组长度较大的那个在前面*&#x2F;</span><br><span class="line">        &#123; PyLongObject *temp &#x3D; a; a &#x3D; b; b &#x3D; temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp &#x3D; size_a;</span><br><span class="line">            size_a &#x3D; size_b;</span><br><span class="line">            size_b &#x3D; size_temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*创建新整数对象，用于保存计算结果（注意到长度必须比 a 和 b 都大一，因为可能有进位）*&#x2F;</span><br><span class="line">    z &#x3D; _PyLong_New(size_a+1);</span><br><span class="line"></span><br><span class="line">    if (z &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    &#x2F;*遍历 b 底层数组，与 a 对应部分相加并保存到 z 中，需要特别注意进位计算*&#x2F;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; ++i) &#123;</span><br><span class="line">        carry +&#x3D; a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] &#x3D; carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;&#x3D; PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*遍历 a 底层数组剩余部分，与进位相加后保存到 z 中，同样需要特别注意进位计算*&#x2F;</span><br><span class="line">    for (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        carry +&#x3D; a-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] &#x3D; carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;&#x3D; PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*将进位写入 z 底层数组最高位单元中*&#x2F;</span><br><span class="line">    z-&gt;ob_digit[i] &#x3D; carry;</span><br><span class="line">    &#x2F;*去除计算结果 z 底层数组中前面多余的零，因为最后的进位可能为零*&#x2F;</span><br><span class="line">    return long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/read/76/article/1903" title="Python 源码深度剖析/07 int 对象，永不溢出的整数">Python
源码深度剖析/07 int 对象，永不溢出的整数</a></li>
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/read/76/article/1904" title="Python 源码深度剖析/08 int 源码解析：如何实现大整数运算？">Python
源码深度剖析/08 int 源码解析：如何实现大整数运算？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34174132/article/details/89699621?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" title="Python3源码—整数对象">Python3源码—整数对象</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/12/linux-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/12/linux-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">[linux] 1.常用指令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-12 14:54:38" itemprop="dateCreated datePublished" datetime="2020-11-12T14:54:38+08:00">2020-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">linux指令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2><span id="jin-cheng-xiang-guan-zhi-ling-ps">进程相关指令 ps</span><a href="#jin-cheng-xiang-guan-zhi-ling-ps" class="header-anchor">#</a></h2>
<p>参考自 <a target="_blank" rel="noopener" href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html" title="ps 进程查看器">ps 进程查看器</a></p>
<h3><span id="jin-cheng-zhuang-tai">进程状态</span><a href="#jin-cheng-zhuang-tai" class="header-anchor">#</a></h3>
<p>ps工具标识进程的5种状态码: - D 不可中断 uninterruptible sleep
(usually IO) - R 运行 runnable (on run queue) - S 中断 sleeping - T 停止
traced or stopped - Z 僵死 a defunct (”zombie”) process</p>
<h3><span id="ming-ling-can-shu">命令参数</span><a href="#ming-ling-can-shu" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a       显示 所有进程（显示状态码）</span><br><span class="line">-a      显示同一终端下的所有程序</span><br><span class="line">-A      所有进程</span><br><span class="line">e       环境变量</span><br><span class="line">c       进程的 真实名称</span><br><span class="line"></span><br><span class="line">r       当前 终端的进程</span><br><span class="line">T       当前 终端的所有程序</span><br><span class="line">u       用户的所有进程</span><br><span class="line">-au     较详细的资讯</span><br><span class="line">-aux    所有包含其他使用者的行程</span><br><span class="line"></span><br><span class="line">-N      反向选择</span><br><span class="line">-e      等于“-A”</span><br><span class="line">f       显示程序间的关系</span><br><span class="line">-H      显示树状结构</span><br><span class="line"></span><br><span class="line">-C&lt;命令&gt;               列出指定命令的状况</span><br><span class="line">–lines&lt;行数&gt;           每页显示的行数</span><br><span class="line">–width&lt;字符数&gt;         每页显示的字符数</span><br><span class="line">–help                  显示帮助信息</span><br><span class="line">–version                显示版本显示</span><br></pre></td></tr></table></figure>
<h3><span id="shu-chu-lie-han-yi">输出列含义</span><a href="#shu-chu-lie-han-yi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">F           代表这个程序的旗标 (flag)， 4 代表使用者为 super user</span><br><span class="line">S           代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</span><br><span class="line">UID         程序被该 UID 所拥有</span><br><span class="line">PID         进程的ID</span><br><span class="line">PPID        则是其 上级父程序的ID</span><br><span class="line">C           CPU 使用的资源百分比</span><br><span class="line">PRI         这个是 Priority (优先执行序) 的缩写，详细后面介绍</span><br><span class="line">NI          这个是 Nice 值，在下一小节我们会持续介绍</span><br><span class="line">ADDR        这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</span><br><span class="line">SZ          使用掉的内存大小</span><br><span class="line">WCHAN       目前这个程序是否正在运作当中，若为 - 表示正在运作</span><br><span class="line">TTY         登入者的终端机位置</span><br><span class="line">TIME        使用掉的 CPU 时间。</span><br><span class="line">CMD         所下达的指令为何</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="qi-ta-chang-yong-zhi-ling">其它常用指令</span><a href="#qi-ta-chang-yong-zhi-ling" class="header-anchor">#</a></h2>
<h3><span id="linux-huan-jing-zhong-ying-wen-qie-huan-pei-zhi-yi-ji-luan-ma-wen-ti">linux环境中英文切换配置以及乱码问题</span><a href="#linux-huan-jing-zhong-ying-wen-qie-huan-pei-zhi-yi-ji-luan-ma-wen-ti" class="header-anchor">#</a></h3>
<h4><span id="ji-chu-pei-zhi">基础配置</span><a href="#ji-chu-pei-zhi" class="header-anchor">#</a></h4>
<p>本质就是修改系统的LANG变量</p>
<p>LANG是language的简称，稍微有英语基础的用户一看就看出来这个变量是决定系统的默认语言的，即系统的菜单、程序的工具栏语言、输入法默
认语言等。</p>
<h4><span id="cha-kan-dang-qian-yong-hu-de-lang-bian-liang">查看当前用户的LANG变量</span><a href="#cha-kan-dang-qian-yong-hu-de-lang-bian-liang" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">liuw@12:~locale</span><br><span class="line"></span><br><span class="line">LANG&#x3D;zh_CN</span><br><span class="line">LANGUAGE&#x3D;</span><br><span class="line">LC_CTYPE&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_NUMERIC&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_TIME&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_COLLATE&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_MONETARY&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_MESSAGES&#x3D;en_US</span><br><span class="line">LC_PAPER&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_NAME&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_ADDRESS&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_TELEPHONE&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_MEASUREMENT&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_IDENTIFICATION&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_ALL&#x3D;</span><br></pre></td></tr></table></figure>
<h4><span id="pei-zhi-zi-ji-de-lang">配置自己的LANG</span><a href="#pei-zhi-zi-ji-de-lang" class="header-anchor">#</a></h4>
如果你希望修改整个系统的编码和语言信息，可以修改系统的配置文件修改LANG，而如果不希望影响其他用户直接在
<strong>自己的~/.bashrc中配置LANG</strong>即可
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># use english</span><br><span class="line">export LANG&#x3D;en_US.UTF-8</span><br><span class="line"></span><br><span class="line">LANG&#x3D;en_US.UTF-8</span><br><span class="line">LANGUAGE&#x3D;</span><br><span class="line">LC_CTYPE&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_NUMERIC&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_TIME&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_COLLATE&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_MONETARY&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_MESSAGES&#x3D;en_US</span><br><span class="line">LC_PAPER&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_NAME&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_ADDRESS&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_TELEPHONE&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_MEASUREMENT&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_IDENTIFICATION&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_ALL&#x3D;</span><br></pre></td></tr></table></figure>
配置后如图：
<div style="width:90%;margin:auto">
<img src="/2020/11/12/linux-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/locale%E5%90%8E.png" class title="locale后图">
</div>
<h4><span id="svn-can-t-convert-string-from-utf-8-to-native-encoding-wen-ti">SVN:
Can't convert string from 'UTF-8' to native encoding问题</span><a href="#svn-can-t-convert-string-from-utf-8-to-native-encoding-wen-ti" class="header-anchor">#</a></h4>
<p>上图可以看到，原本的'LC_ALL'为空，对中文因此出现了这个问题
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LC_ALL&#x3D;</span><br></pre></td></tr></table></figure>
解决方案：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LC_ALL&#x3D;zh_CN.UTF-8     # 配置~&#x2F;.bashrc中 LC_ALL</span><br></pre></td></tr></table></figure></p>
<h3><span id="cha-xun-linux-xi-tong-lei-xing">查询linux系统类型</span><a href="#cha-xun-linux-xi-tong-lei-xing" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>
<p>这个命令适用于所有遵守LSB规范的的linux，包括Redhat、SuSE、Debian、Ubuntu、Centos等发行版</p>
<h3><span id="xian-shi-xi-tong-he-xin-xin-xi">显示系统核心信息</span><a href="#xian-shi-xi-tong-he-xin-xin-xi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uname</span><br><span class="line"></span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<h3><span id="nei-cun-xin-xi">内存信息</span><a href="#nei-cun-xin-xi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;meminfo</span><br></pre></td></tr></table></figure>
<h3><span id="cpu-xin-xi">CPU信息</span><a href="#cpu-xin-xi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure>
<h3><span id="cha-kan-dang-qian-lu-jing">查看当前路径</span><a href="#cha-kan-dang-qian-lu-jing" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<h3><span id="chong-ming-ming-wen-jian-mv">重命名文件 mv</span><a href="#chong-ming-ming-wen-jian-mv" class="header-anchor">#</a></h3>
<p>例子：将目录A重命名为B
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv A B</span><br></pre></td></tr></table></figure>
例子：将/a目录移动到/b下，并重命名为c
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;a &#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure></p>
<h3><span id="sou-suo-wen-jian-find">搜索文件 find</span><a href="#sou-suo-wen-jian-find" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -mtime 0   #0代表当前时间，即从现在到24小时前，有改动过内容的文件都会被列出来</span><br><span class="line"></span><br><span class="line">find &#x2F;etc -newer &#x2F;etc&#x2F;passwd #寻找&#x2F;etc下面的文件，如果文件日期比&#x2F;etc&#x2F;passwd新就列出</span><br><span class="line"></span><br><span class="line">find &#x2F; -name file  #&#x2F;代表全文搜索</span><br><span class="line"></span><br><span class="line">find &#x2F;home -user Anmy  #查找&#x2F;home下属于Anmy的文件</span><br><span class="line"></span><br><span class="line">find &#x2F; -nouser #查找系统中不属于任何人的文件，可以轻易找出那些不太正常的文件</span><br><span class="line"></span><br><span class="line">find &#x2F; -name passed #查找文件名为passed的文件</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liu Wen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sysuleo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sysuleo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/leo666-40" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;leo666-40" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>zhihu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Wen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  


</body>
</html>
