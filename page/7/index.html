<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-uUIis3aZOy">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LiuWen&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="LiuWen&#39;s Blogs">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liu Wen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>LiuWen's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LiuWen's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/10/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-float%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/10/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-float%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">[python源码分析] 3.float解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-10 22:26:12" itemprop="dateCreated datePublished" datetime="2020-11-10T22:26:12+08:00">2020-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">python源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="nei-bu-jie-gou">内部结构</span><a href="#nei-bu-jie-gou" class="header-anchor">#</a></h1>
<p>float 实例对象在 Include/floatobject.h 中定义如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD   &#x2F;&#x2F;定长对象共用的头部</span><br><span class="line">    double ob_fval;  &#x2F;&#x2F;额外字段,存储对象所承载的浮点值</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure></p>
下面是浮点<strong>实例对象</strong>内部结构图：
<div style="width:95%;margin:auto">
<img src="/2020/11/10/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-float%E8%A7%A3%E6%9E%90/%5Bpython%5Dfloat1.png" class title="PyFloatObject图">
</div>
<h2><span id="float-lei-xing-dui-xiang">float 类型对象</span><a href="#float-lei-xing-dui-xiang" class="header-anchor">#</a></h2>
<p>与实例对象不同， <strong>float 类型对象 全局唯一</strong>
，因此可以作为 <strong>全局变量</strong> 定义。 在 C 文件
<strong>Objects/floatobject.c</strong> 中，我们找到了代表 float
类型对象的<strong>全局变量 PyFloat_Type</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyFloat_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;float&quot;,                                  &#x2F;*tp_name 字段保存类型名称，常量 float*&#x2F;</span><br><span class="line">    sizeof(PyFloatObject),</span><br><span class="line">    0,</span><br><span class="line">    (destructor)float_dealloc,                  &#x2F;* tp_dealloc 对象销毁相关*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_print *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_getattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_reserved *&#x2F;</span><br><span class="line">    (reprfunc)float_repr,                       &#x2F;* tp_repr 生成语法字符串表示形式的函数*&#x2F;</span><br><span class="line">    &amp;float_as_number,                           &#x2F;* tp_as_number 数值操作集*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc)float_hash,                       &#x2F;* tp_hash 哈希值生成函数*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_call *&#x2F;</span><br><span class="line">    (reprfunc)float_repr,                       &#x2F;* tp_str 生成普通字符串表示形式的函数*&#x2F;</span><br><span class="line">    PyObject_GenericGetAttr,                    &#x2F;* tp_getattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_buffer *&#x2F;</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   &#x2F;* tp_flags *&#x2F;</span><br><span class="line">    float_new__doc__,                           &#x2F;* tp_doc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_traverse *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_clear *&#x2F;</span><br><span class="line">    float_richcompare,                          &#x2F;* tp_richcompare *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_weaklistoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iter *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iternext *&#x2F;</span><br><span class="line">    float_methods,                              &#x2F;* tp_methods *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_members *&#x2F;</span><br><span class="line">    float_getset,                               &#x2F;* tp_getset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_base *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dict *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_get *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_set *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dictoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_init 对象创建相关(tp_init 函数指针在这为空，因为float对象简单，只需要tp_new赋值就行)*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_alloc 对象创建相关*&#x2F;</span><br><span class="line">    float_new,                                  &#x2F;* tp_new 对象创建相关*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PyFloat_Type 中保存了很多关于浮点对象的 <strong>元信息</strong></p>
<p>PyFloat_Type 很重要，作为浮点 <strong>类型对象</strong>
，它决定了<strong>浮点 实例对象 的 生死和行为</strong> 。</p>
<h1><span id="dui-xiang-de-chuang-jian">对象的创建</span><a href="#dui-xiang-de-chuang-jian" class="header-anchor">#</a></h1>
<p>调用<strong>类型对象 float 创建实例对象</strong>: Python 执行的是
type 类型对象中的 <strong>tp_call</strong> 函数。 tp_call 函数进而调用
<strong>float 类型对象的 tp_new 函数创建实例对象</strong>， 再调用
<strong>tp_init 函数对其进行初始化</strong>：</p>
<div style="width:95%;margin:auto">
<img src="/2020/11/10/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-float%E8%A7%A3%E6%9E%90/%5Bpython%5Dfloat_create.jpg" class title="Float对象创建图">
</div>
<p>除了通用的流程， Python 为内置对象实现了对象创建 API
，简化调用，提高效率：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyFloat_FromDouble(double fval);  &#x2F;*通过浮点值创建浮点对象*&#x2F;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyFloat_FromString(PyObject *v);  &#x2F;*通过字符串对象创建浮点对象*&#x2F;</span><br></pre></td></tr></table></figure></p>
<p>以 <strong>PyFloat_FromDouble</strong> 为例，特化的对象创建流程如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyFloat_FromDouble(double fval)</span><br><span class="line">&#123;</span><br><span class="line">    PyFloatObject *op &#x3D; free_list;</span><br><span class="line">    &#x2F;*为对象 分配内存空间，优先使用空闲对象缓存池 *&#x2F;</span><br><span class="line">    if (op !&#x3D; NULL) &#123;                 </span><br><span class="line">        free_list &#x3D; (PyFloatObject *) Py_TYPE(op);</span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;*空闲对象缓存池为空，调用PyObject_MALLOC申请内存 *&#x2F;</span><br><span class="line">    else &#123;</span><br><span class="line">        op &#x3D; (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));</span><br><span class="line">        if (!op)</span><br><span class="line">            return PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* Inline PyObject_New *&#x2F;</span><br><span class="line">    (void)PyObject_INIT(op, &amp;PyFloat_Type);</span><br><span class="line"></span><br><span class="line">    &#x2F;*将 ob_fval 字段初始化为指定 浮点值 *&#x2F;</span><br><span class="line">    op-&gt;ob_fval &#x3D; fval;    </span><br><span class="line">    return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面用到的宏 PyObject_INIT 在头文件 Include/objimpl.h 中定义为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define PyObject_INIT(op, typeobj) \</span><br><span class="line">    ( Py_TYPE(op) &#x3D; (typeobj), _Py_NewReference((PyObject *)(op)), (op) )  &#x2F;&#x2F;前半部分调用  Py_TYPE(op) 初始化 对象类型 字段 ob_type，后面语句初始化 引用计数 字段 ob_refcnt</span><br></pre></td></tr></table></figure></p>
<p>上面提到的宏定义 <strong>Py_TYPE</strong>，位于 Include/object.h
头文件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define Py_TYPE(ob) (((PyObject*)(ob))&amp;ob_type)</span><br></pre></td></tr></table></figure>
它的作用是：将 <strong>给定对象的类型对象取出,
返回对象的ob_type字段</strong>。</p>
<p>宏 _Py_NewReference，在 Include/Object.h 中定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define _Py_NewReference(op) (                          \</span><br><span class="line">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</span><br><span class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</span><br><span class="line">    Py_REFCNT(op) &#x3D; 1)   &#x2F;*将对象引用计数初始化为 1*&#x2F;</span><br></pre></td></tr></table></figure></p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%">
</colgroup>
<tbody>
<tr>
<td># 对象的销毁 当对象不再需要时， Python 通过 <strong>Py_DECREF 或者
Py_XDECREF 宏减少引用计数</strong>； 当引用计数降为 0 时， Python 通过
**_Py_Dealloc** 宏回收对象：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define _Py_Dealloc(op) (                               \</span><br><span class="line">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span><br><span class="line">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))   &#x2F;*调用类型对象 **PyFloat_Type 中的 tp_dealloc 函数指针*&#x2F;</span><br></pre></td></tr></table></figure>
因此，实际调用的函数是 float_dealloc (代码在下一小节 空闲对象缓存池
中解析)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">float_dealloc(PyFloatObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    if (PyFloat_CheckExact(op)) &#123;</span><br><span class="line">      &#x2F;*空闲对象缓存池满了，直接销毁*&#x2F;</span><br><span class="line">        if (numfree &gt;&#x3D; PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">            PyObject_FREE(op);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        numfree++;</span><br><span class="line">        Py_TYPE(op) &#x3D; (struct _typeobject *)free_list;</span><br><span class="line">        free_list &#x3D; op;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
总结起来，对象从创建到销毁整个生命周期所涉及的
<strong>关键函数、宏及调用关系</strong> 如下：</td>
</tr>
</tbody>
</table>
<h1><span id="kong-xian-dui-xiang-huan-cun-chi">空闲对象缓存池</span><a href="#kong-xian-dui-xiang-huan-cun-chi" class="header-anchor">#</a></h1>
<p>浮点运算背后涉及 大量临时对象创建以及销毁 ，以下面计算为例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; area &#x3D; pi * r ** 2</span><br></pre></td></tr></table></figure>
这个语句首先计算半径 r **
2，中间结果由一个<strong>临时对象</strong>来保存，假设是 t ；
然后计算圆周率 <strong>pi 与 t 的乘积</strong>，得到最终结果并赋值给变量
area ； 最后，销毁<strong>临时对象 t</strong> 。
这么简单的语句，背后居然都隐藏着一个
<strong>临时对象的创建以及销毁</strong>操作！</p>
<p>创建对象时需要分配内存，销毁对象时又需要回收内存。
大量临时对象创建销毁 ，意味着 大量内存分配回收操作
，这显然是是不可接受的。</p>
<p>因此 <strong>Python
在浮点对象销毁后，并不急于回收内存</strong>，而是<strong>将对象放入一个
空闲链表</strong> 。
后续需要创建浮点对象时，先到空闲链表中取，省去分配内存的开销。</p>
浮点对象的空闲链表同样在 Objects/floatobject.c 中定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef PyFloat_MAXFREELIST</span><br><span class="line">#define PyFloat_MAXFREELIST    100           &#x2F;*该宏  限制空闲链表的 最大长度 ，避免占用过多内存*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">static int numfree &#x3D; 0;                     &#x2F;*维护空闲链表 当前长度*&#x2F;</span><br><span class="line">static PyFloatObject *free_list &#x3D; NULL;    &#x2F;*指向空闲链表 头节点 的指针*&#x2F;</span><br></pre></td></tr></table></figure>
为了保持简洁， Python 把 <strong>ob_type 字段当作 next
指针来用</strong>，将 <strong>空闲对象串成链表</strong>：
<div style="width:95%;margin:auto">

</div>
<p>因此创建浮点对象时，可以从 <strong>链表中取出空闲对象</strong>，省去
<strong>申请内存的开销</strong>！ 以 PyFloat_FromDouble 为例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PyFloatObject *op &#x3D; free_list;                  &#x2F;*op指向第一个 空闲对象*&#x2F;</span><br><span class="line">if (op !&#x3D; NULL) &#123;</span><br><span class="line">    free_list &#x3D; (PyFloatObject *) Py_TYPE(op);  &#x2F;*free_list指向第一个 空闲对象(op)的ob_type所指向的 下一个空闲对象(相当于链表的头部删除)*&#x2F;</span><br><span class="line">    numfree--;                                  &#x2F;*更新空闲链表维护的数量*&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    op &#x3D; (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));    &#x2F;*free_list为空时，重新分配内存*&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象销毁时， Python 将其缓存在空闲链表中，以备后用。考察
float_dealloc 函数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (numfree &gt;&#x3D; PyFloat_MAXFREELIST)  &#123;   &#x2F;*销毁时，判断free_list是否达到最大容量*&#x2F;</span><br><span class="line">    PyObject_FREE(op);                   &#x2F;*回收对象内*&#x2F;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">numfree++;                                      </span><br><span class="line">Py_TYPE(op) &#x3D; (struct _typeobject *)free_list;  &#x2F;*op的ob_type指向当前 第一个空闲对象*&#x2F;</span><br><span class="line">free_list &#x3D; op;                                 &#x2F;* free_list指向op(相当于链表的头部插入)*&#x2F;</span><br></pre></td></tr></table></figure>
空闲对象缓存池在 <strong>提高对象分配效率</strong>
方面发挥着至关重要的作用。</p>
<h1><span id="dui-xiang-de-xing-wei">对象的行为</span><a href="#dui-xiang-de-xing-wei" class="header-anchor">#</a></h1>
<p>PyFloat_Type 中定义了很多函数指针，包括 tp_repr 、 tp_str 、 tp_hash
等。 这些函数指针将一起决定 float 对象的行为，例如 tp_hash
函数决定浮点哈希值的计算：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pi &#x3D; 3.14</span><br><span class="line">&gt;&gt;&gt; hash(pi)</span><br><span class="line">322818021289917443</span><br></pre></td></tr></table></figure>
tp_hash 函数指针指向 <strong>float_hash 函数</strong>，实现了
<strong>针对浮点对象的哈希值算法</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static Py_hash_t</span><br><span class="line">float_hash(PyFloatObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    return _Py_HashDouble(v-&gt;ob_fval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## 数值操作集 由于加减乘除等数值操作很常见， Python 将其抽象成数值操作集
<strong>PyNumberMethods</strong> 。 数值操作集 PyNumberMethods 在头文件
<strong>Include/object.h</strong> 中定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    &#x2F;* Number implementations must check *both*</span><br><span class="line">    arguments for proper type and implement the necessary conversions</span><br><span class="line">    in the slot functions themselves. *&#x2F;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>
PyNumberMethods
定义了各种数学算子的处理函数，数值计算最终由这些函数执行。
处理函数根据参数个数可以分为： <strong>一元函数 ( unaryfunc )、 二元函数
( binaryfunc )</strong>等。</p>
<ul>
<li>一元函数 ( unaryfunc ): 需要传入一个参数的函数。</li>
<li>二元函数 ( binaryfunc): 需要传入两个参数的函数。</li>
</ul>
<p>回到 Objects/floatobject.c 观察浮点对象数值操作集 float_as_number
是如何初始化的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static PyNumberMethods float_as_number &#x3D; &#123;</span><br><span class="line">    float_add,          &#x2F;* nb_add *&#x2F;</span><br><span class="line">    float_sub,          &#x2F;* nb_subtract *&#x2F;</span><br><span class="line">    float_mul,          &#x2F;* nb_multiply *&#x2F;</span><br><span class="line">    float_rem,          &#x2F;* nb_remainder *&#x2F;</span><br><span class="line">    float_divmod,       &#x2F;* nb_divmod *&#x2F;</span><br><span class="line">    float_pow,          &#x2F;* nb_power *&#x2F;</span><br><span class="line">    (unaryfunc)float_neg, &#x2F;* nb_negative *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    0,                  &#x2F;* nb_inplace_add *&#x2F;</span><br><span class="line">    0,                  &#x2F;* nb_inplace_subtract *&#x2F;</span><br><span class="line">    0,                  &#x2F;* nb_inplace_multiply *&#x2F;</span><br><span class="line">    0,                  &#x2F;* nb_inplace_remainder *&#x2F;</span><br><span class="line">    0,                  &#x2F;* nb_inplace_power *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
以加法为例，以下语句在 Python 内部最终由 float_add 函数执行：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1.5</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1.1</span><br><span class="line">&gt;&gt;&gt; a + b</span><br><span class="line">2.6</span><br></pre></td></tr></table></figure>
float_add 是一个 二元函数 ，位于 Objects/floatobject.h 中：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">float_add(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    double a,b;</span><br><span class="line">    &#x2F;&#x2F;将两个参数对象转化成浮点值，CONVERT_TO_DOUBLE是一个宏，将PyFloatObject里面的ob_fval抽出来给double变量</span><br><span class="line">    CONVERT_TO_DOUBLE(v, a);</span><br><span class="line">    CONVERT_TO_DOUBLE(w, b);</span><br><span class="line">    PyFPE_START_PROTECT(&quot;add&quot;, return 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对两个浮点值求和</span><br><span class="line">    a &#x3D; a + b;</span><br><span class="line">    PyFPE_END_PROTECT(a)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个新浮点对象保存计算结果并返回</span><br><span class="line">    return PyFloat_FromDouble(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
浮点数计算一般都遵循
<strong>IEEE-754</strong>标准，如果计算时出现了错误，那么需要
<strong>将IEEE-754异常转换成Python中的异常</strong>，而
<strong>PyFPE_START_PROTECT和PyFPE_END_PROTECT</strong>这两个宏就是用来干这件事情的。
它们的定义在Include/pyfpe.h中，并且Python3.9的时候会被删除掉。</p>
<p>所以如果是 <strong>C中的两个浮点数相加，直接a +
b就可以了，编译之后就是一条简单的机器指令</strong>，然而
<strong>Python则需要额外做很多其它工作</strong>。从一个简单的加法上面就可以看出来Python为什么会比C慢几十倍了。</p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/read/76/article/1902" title="小试牛刀，解剖浮点对象 float">小试牛刀，解剖浮点对象
float</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/u/4355012/blog/4464067" title="浮点数的底层实现">浮点数的底层实现</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/27/cocos-%E5%B8%B8%E7%94%A8API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/27/cocos-%E5%B8%B8%E7%94%A8API/" class="post-title-link" itemprop="url">[Cocos]常用API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-27 10:13:41" itemprop="dateCreated datePublished" datetime="2020-10-27T10:13:41+08:00">2020-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="cocosapi-xue-xi">cocosApi学习</span><a href="#cocosapi-xue-xi" class="header-anchor">#</a></h1>
<p>这篇博客记录一下工作中遇到的Cocos相关api。</p>
<h2><span id="eventlistenertouchonebyone-create">EventListenerTouchOneByOne::create()</span><a href="#eventlistenertouchonebyone-create" class="header-anchor">#</a></h2>
<p><strong>单点触摸</strong>监听
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listener &#x3D; cc.EventListenerTouchOneByOne.create()</span><br></pre></td></tr></table></figure></p>
<h2><span id="cc-fadeto">cc.fadeTo</span><a href="#cc-fadeto" class="header-anchor">#</a></h2>
<p>修改 <strong>透明度</strong>到指定值</p>
<h2><span id="rong-qi-dong-zuo">容器动作</span><a href="#rong-qi-dong-zuo" class="header-anchor">#</a></h2>
<h3><span id="shun-xu-dong-zuo-cc-sequence">顺序动作 cc.sequence</span><a href="#shun-xu-dong-zuo-cc-sequence" class="header-anchor">#</a></h3>
<p>顺序动作可以让一系列子动作按顺序一个个执行
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 让节点左右来回移动</span><br><span class="line">var seq &#x3D; cc.sequence(cc.moveBy(0.5, 200, 0), cc.moveBy(0.5, -200, 0));</span><br><span class="line">node.runAction(seq);</span><br></pre></td></tr></table></figure></p>
<h3><span id="tong-bu-dong-zuo-cc-spawn">同步动作 cc.spawn</span><a href="#tong-bu-dong-zuo-cc-spawn" class="header-anchor">#</a></h3>
<p>同步动作可以同步执行对一系列子动作，子动作的执行结果会叠加起来修改节点的属性。示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 让节点在向上移动的同时缩放</span><br><span class="line">var spawn &#x3D; cc.spawn(cc.moveBy(0.5, 0, 50), cc.scaleTo(0.5, 0.8, 1.4));</span><br><span class="line">node.runAction(spawn);</span><br></pre></td></tr></table></figure></p>
<h3><span id="chong-fu-dong-zuo-cc-repeat">重复动作 cc.repeat</span><a href="#chong-fu-dong-zuo-cc-repeat" class="header-anchor">#</a></h3>
<p>重复动作用来多次重复一个动作。示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 让节点左右来回移动，并重复 5 次</span><br><span class="line">var seq &#x3D; cc.repeat(</span><br><span class="line">            cc.sequence(</span><br><span class="line">                cc.moveBy(2, 200, 0),</span><br><span class="line">                cc.moveBy(2, -200, 0)</span><br><span class="line">            ), 5);</span><br><span class="line">node.runAction(seq);</span><br></pre></td></tr></table></figure></p>
<h2><span id="ccc-callfunc-create-func">ccc.CallFunc.create(func)</span><a href="#ccc-callfunc-create-func" class="header-anchor">#</a></h2>
<p>调用当前不带参数的函数</p>
<h2><span id="cc-delaytime-create-float-delaytime">cc.DelayTime.create(float
delaytime)</span><a href="#cc-delaytime-create-float-delaytime" class="header-anchor">#</a></h2>
<p>延迟当前的action</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.runAction(cc.Sequence.create([cc.DelayTime.create(1), cc.CallFunc.create(callback)]))</span><br><span class="line"></span><br><span class="line">def callback():</span><br><span class="line">    print &quot;just test&quot;</span><br></pre></td></tr></table></figure>
<h1><span id="ccui">ccui</span><a href="#ccui" class="header-anchor">#</a></h1>
<h3><span id="ccui-touch-event-moved-dang-qian-wei-hong-ping-yi-dong-zhuang-tai">ccui.TOUCH_EVENT_MOVED当前为触屏移动状态</span><a href="#ccui-touch-event-moved-dang-qian-wei-hong-ping-yi-dong-zhuang-tai" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ccui.TOUCH_EVENT_MOVED &#x3D;&#x3D; evtType:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h3><span id="ccui-touch-event-ended-dang-qian-wei-hong-ping-tai-qi-zhuang-tai">ccui.TOUCH_EVENT_ENDED
当前为触屏抬起状态</span><a href="#ccui-touch-event-ended-dang-qian-wei-hong-ping-tai-qi-zhuang-tai" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if evtType &#x3D;&#x3D; ccui.TOUCH_EVENT_ENDED:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h2><span id="button-an-niu">button按钮</span><a href="#button-an-niu" class="header-anchor">#</a></h2>
<h3><span id="button-tu-pian-she-zhi">button图片设置</span><a href="#button-tu-pian-she-zhi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn.loadTextureNormal(&quot;....png&quot;)  # 正常状态</span><br><span class="line">btn.loadTexturePressed(&quot;....png&quot;)  # 按下状态</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/22/python-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/22/python-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">[python]常用API记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-22 10:58:05" itemprop="dateCreated datePublished" datetime="2020-10-22T10:58:05+08:00">2020-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章用来记录工作和学习过程中遇到的一些python常用api方法。</p>
<h2><span id="os-mo-kuai">os模块</span><a href="#os-mo-kuai" class="header-anchor">#</a></h2>
<h3><span id="os-walk">os.walk()</span><a href="#os-walk" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.walk(top[, topdown&#x3D;True[, onerror&#x3D;None[, followlinks&#x3D;False]]])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong> top -- 是你所要遍历的目录的地址,
<strong>返回的是一个三元组(root,dirs,files)</strong>。 - root
所指的是当前正在遍历的这个文件夹的本身的地址 - dirs 是一个 list
，内容是该文件夹中所有的目录的名字(不包括子目录) - files 同样是 list ,
内容是该文件夹中所有的文件(不包括子目录)</p>
<p>topdown --可选，为 True，则优先遍历 top 目录，否则优先遍历 top
的子目录(默认为开启)。如果 topdown 参数为 True，walk
会遍历top文件夹，与top 文件夹中每一个子目录。</p>
<p>onerror -- 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。
followlinks -- 可选，如果为 True，则会遍历目录下的快捷方式(linux
下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为
False，则优先遍历 top 的子目录。</p>
<h3><span id="os-getenv-key-default-none">os.getenv(key, default = None)</span><a href="#os-getenv-key-default-none" class="header-anchor">#</a></h3>
<p>返回环境变量键的值(如果存在)，否则返回默认值。</p>
<h3><span id="os-path-abspath-file">os.path.abspath(<strong>file</strong>)</span><a href="#os-path-abspath-file" class="header-anchor">#</a></h3>
<ul>
<li><strong>获取的当前执行脚本的完整路径</strong></li>
<li>只有当在脚本中执行的时候，os.path.abspath(<strong>file</strong>)才会起作用，因为该命令是获取的当前执行脚本的完整路径，如果在交互模式或者terminate
终端中运行会报没有__file__这个错误</li>
</ul>
<h3><span id="os-path-dirname-path">os.path.dirname(path)</span><a href="#os-path-dirname-path" class="header-anchor">#</a></h3>
<p>去掉文件名，返回目录</p>
<h3><span id="os-environ-get">os.environ.get（）</span><a href="#os-environ-get" class="header-anchor">#</a></h3>
<p>是python中os模块获取环境变量的一个方法</p>
<h2><span id="getattr-object-name-default">getattr(object, name[,
default])</span><a href="#getattr-object-name-default" class="header-anchor">#</a></h2>
<p>getattr() 函数用于返回一个<strong>对象属性值</strong>。 - object --
对象。 - name -- 字符串，对象属性。 - default --
默认返回值，如果不提供该参数，在没有对应属性时，将触发
AttributeError。</p>
<h2><span id="shutil-copyfile-src-dst">shutil.copyfile(src, dst)</span><a href="#shutil-copyfile-src-dst" class="header-anchor">#</a></h2>
<p><strong>复制文件内容</strong>（不包含元数据）<strong>从src到dst</strong>。
<strong>dst必须是完整的目标文件名</strong>; 如果src和dst是
<strong>同一文件，就会引发错误shutil.Error</strong>。
<strong>dst必须是可写的</strong>，否则将引发异常IOError。如果dst已经存在，它会被替换。</p>
<h2><span id="property"><span class="citation" data-cites="property">@property</span></span><a href="#property" class="header-anchor">#</a></h2>
<p>Python内置的@property装饰器就是负责<strong>把一个方法变成属性调用</strong>的.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&#39;score must be an integer!&#39;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&#39;score must between 0 ~ 100!&#39;)</span><br><span class="line">        self._score &#x3D; value</span><br></pre></td></tr></table></figure>
<span class="citation" data-cites="property的实现比较复杂">@property的实现比较复杂</span>，我们先考察如何使用。<strong>把一个getter方法变成属性</strong>，只需要加上@property就可以了，此时，<span class="citation" data-cites="property本身">@property本身</span><strong>又创建了另一个装饰器@score.setter</strong>，负责<strong>把一个setter方法变成属性赋值</strong>，于是，我们就拥有一个可控的属性操作：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; Student()</span><br><span class="line">&gt;&gt;&gt; s.score &#x3D; 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.score &#x3D; 9999</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure></p>
<p>还可以<strong>定义只读属性</strong>，<strong>只定义getter方法，不定义setter方法就是一个只读属性</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        return self._birth</span><br><span class="line"></span><br><span class="line">    @birth.setter</span><br><span class="line">    def birth(self, value):</span><br><span class="line">        self._birth &#x3D; value</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2014 - self._birth</span><br></pre></td></tr></table></figure>
上面的<strong>birth是可读可写的</strong>，而<strong>age就是一个只读属性</strong>。</p>
<h2><span id="python-zhong-han-shu-qian-tian-jia-yi-ji-de-yong-fa">python中函数前添加*以及**的用法</span><a href="#python-zhong-han-shu-qian-tian-jia-yi-ji-de-yong-fa" class="header-anchor">#</a></h2>
<p>转自：http://blog.csdn.net/delphiwcdj/article/details/5746560
当要使函数接收元组或字典形式的参数
的时候，有一种特殊的方法，它分别使用*和**前缀
。这种方法在函数需要获取可变数量的参数 的时候特别有用。</p>
<p>[注意] [1] 由于在args变量前有*前缀
，所有多余的函数参数都会作为一个元组存储在args中
。如果使用的是<strong>前缀 ，多余的参数则会被认为是一个字典的健/值对 。
[2] 对于def func(<em>args):，</em>args表示把传进来的位置参数存储在
</strong>tuple（元组）args里面<strong>。例如，调用func(1, 2, 3)
，args就表示(1, 2, 3)这个元组 。 [3] 对于 def
func(</strong>args):，<strong>args表示把参数
</strong>作为字典的健-值对存储在dict（字典）args里面**。例如，调用func(a='I',
b='am', c='wcdj') ，args就表示{'a':'I', 'b':'am', 'c':'wcdj'}这个字典 。
[4]
注意普通参数与*和**参数公用的情况，一般将*和**参数放在参数列表最后。</p>
<h2><span id="globals">globals()</span><a href="#globals" class="header-anchor">#</a></h2>
<p>以字典类型返回<strong>当前位置的全部全局变量</strong></p>
<h2><span id="locals-han-shu">locals() 函数</span><a href="#locals-han-shu" class="header-anchor">#</a></h2>
<p>locals() 函数会
<strong>以字典类型返回当前位置的全部局部变量</strong>。 对于函数, 方法,
lambda 函式, 类, 以及实现了 <strong>call</strong> 方法的类实例, 它都返回
True。</p>
<h2><span id="lambad-han-shu-yong-fa">lambad函数用法</span><a href="#lambad-han-shu-yong-fa" class="header-anchor">#</a></h2>
<p>####（1）直接赋给一个变量，然后再像一般函数那样调用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c&#x3D;lambda x,y,z:x*y*z</span><br><span class="line">c(2,3,4)</span><br><span class="line"></span><br><span class="line">24</span><br></pre></td></tr></table></figure>
当然，也可以在函数后面直接传递实参
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lambda x:x**2)(3)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
####（2）将lambda函数作为参数传递给其他函数比如说结合map、filter、sorted、reduce等一些Python内置函数使用，下面举例说明。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fliter(lambda x:x%3&#x3D;&#x3D;0,[1,2,3,4,5,6])</span><br><span class="line"></span><br><span class="line">[3,6]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">squares &#x3D; map(lambda x:x**2,range(5)</span><br><span class="line">print(lsit(squares))</span><br><span class="line">[0,1,4,9,16]</span><br></pre></td></tr></table></figure>
与sorted函数结合使用，比如：创建由元组构成的列表：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;[(&#39;b&#39;,3),(&#39;a&#39;,2),(&#39;d&#39;,4),(&#39;c&#39;,1)]</span><br></pre></td></tr></table></figure>
按照第一个元素排序
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted(a,key&#x3D;lambda x:x[0])</span><br><span class="line">[(&#39;a&#39;,2),(&#39;b&#39;,3),(&#39;c&#39;,1),(&#39;d&#39;,4)]</span><br></pre></td></tr></table></figure>
按照第二个元素排序
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted(a,key&#x3D;lambda x:x[1])</span><br><span class="line">[(&#39;c&#39;,1),(&#39;a&#39;,2),(&#39;b&#39;,3),(&#39;d&#39;,4)]</span><br></pre></td></tr></table></figure>
与reduce函数结合使用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">print(reduce(lambda a,b:&#39;&#123;&#125;,&#123;&#125;&#39;.format(a,b),[1,2,3,4,5,6,7,8,9]))</span><br><span class="line"></span><br><span class="line">1,2,3,4,5,6,7,8,9</span><br></pre></td></tr></table></figure>
####（3）嵌套使用将lambda函数嵌套到普通函数中，lambda函数本身做为return的值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def increment(n):</span><br><span class="line">    return lambda x:x+n</span><br><span class="line"></span><br><span class="line">f&#x3D;increment(4)</span><br><span class="line">f(2)</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
####（4）字符串联合，有默认值，也可以用x=(lambda...)这种格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;(lambda x&#x3D;&#39;Boo&#39;,y&#x3D;&#39;Too&#39;,z&#x3D;&#39;Z00&#39;：x+y+z)</span><br><span class="line">print(x(&#39;Foo&#39;))</span><br><span class="line"></span><br><span class="line">&#39;FooTooZoo&#39;</span><br></pre></td></tr></table></figure>
####（5）在tkinter中定义内联的callback函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from tkinter import Button,mainloop</span><br><span class="line"></span><br><span class="line">x&#x3D;Button(text&#x3D;&#39;Press me&#39;,command&#x3D;(lambda :sys.stdout.write(&#39;Hello,World\n&#39;)))</span><br><span class="line">x.pack()</span><br><span class="line">x.mainloop()</span><br></pre></td></tr></table></figure>
这段代码还是挺有意思的，希望小伙伴们可以复制粘贴运行一下哈。
####（6）判断字符串是否以某个字母开头有
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Names &#x3D; [&#39;Anne&#39;, &#39;Amy&#39;, &#39;Bob&#39;, &#39;David&#39;, &#39;Carrie&#39;, &#39;Barbara&#39;, &#39;Zach&#39;]</span><br><span class="line">B_Name&#x3D; filter(lambda x: x.startswith(&#39;B&#39;),Names)</span><br><span class="line">print(B_Name)</span><br><span class="line"></span><br><span class="line">[&#39;Bob&#39;, &#39;Barbara&#39;]</span><br></pre></td></tr></table></figure>
####（7）求两个列表元素的和
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [1,2,3,4]</span><br><span class="line">b &#x3D; [5,6,7,8]</span><br><span class="line">print(list(map(lambda x,y:x+y, a,b)))</span><br><span class="line"></span><br><span class="line">[6,8,10,12]</span><br></pre></td></tr></table></figure>
####（8）求字符串每个单词的长度
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentence &#x3D; &quot;Welcome To Beijing!&quot;</span><br><span class="line">words &#x3D; sentence.split()</span><br><span class="line">lengths  &#x3D; map(lambda x:len(x),words)</span><br><span class="line">print(list(lengths))</span><br><span class="line">[7,2,8]</span><br></pre></td></tr></table></figure></p>
<h2><span id="for-else-jie-gou">for else结构</span><a href="#for-else-jie-gou" class="header-anchor">#</a></h2>
<p>for else 结构还是第一次见，于是记录一下。如果for循环
<strong>正常结束，else中语句执行</strong>。如果是
<strong>break</strong>的，则 <strong>不执行</strong>。</p>
<p>简单使用场景:寻找100以内的素数之和
(这个应该是较暴力算法，这里不讨论算法问题)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum&#x3D;0</span><br><span class="line">for n in range(2,100):</span><br><span class="line">    for i in range(2,n):</span><br><span class="line">        if n%i&#x3D;&#x3D;0:          # 不是素数</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        sum+&#x3D;n              # 加上素数</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure></p>
<h2><span id="shan-yong-san-mu-yun-suan">善用三目运算</span><a href="#shan-yong-san-mu-yun-suan" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num &#x3D; 3 if res &gt; 3 else 1</span><br></pre></td></tr></table></figure>
<h2><span id="jie-shou-dong-tai-can-shu-sys-argv">接受动态参数sys.argv</span><a href="#jie-shou-dong-tai-can-shu-sys-argv" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># test.py</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">def main(argv)</span><br><span class="line">    print(argv)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test.py 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2><span id="binascii-er-jin-zhi-he-ascii-ma-hu-zhuan">binascii --- 二进制和 ASCII
码互转</span><a href="#binascii-er-jin-zhi-he-ascii-ma-hu-zhuan" class="header-anchor">#</a></h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/binascii.html" title="binascii --- 二进制和 ASCII 码互转">binascii介绍</a> ###
返回二进制数据 data 的十六进制表示形式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binascii.b2a_hex(data[, sep[, bytes_per_sep&#x3D;1]])</span><br><span class="line">binascii.hexlify(data[, sep[, bytes_per_sep&#x3D;1]])</span><br></pre></td></tr></table></figure>
data
的每个字节都被转换为相应的2位十六进制表示形式。因此返回的字节对象的长度是
data 的两倍。</p>
<h3><span id="fan-hui-you-shi-liu-jin-zhi-zi-fu-chuan-hexstr-biao-shi-de-er-jin-zhi-shu-ju">返回由十六进制字符串
hexstr 表示的二进制数据</span><a href="#fan-hui-you-shi-liu-jin-zhi-zi-fu-chuan-hexstr-biao-shi-de-er-jin-zhi-shu-ju" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binascii.a2b_hex(hexstr)</span><br><span class="line">binascii.unhexlify(hexstr)</span><br></pre></td></tr></table></figure>
<p>此函数功能与 b2a_hex() 相反。 hexstr 必须包含
<strong>偶数个十六进制数字</strong>（可以是大写或小写），否则会引发
Error 异常。</p>
<h2><span id="zlip">zlip</span><a href="#zlip" class="header-anchor">#</a></h2>
<ul>
<li><p>字符串：使用 <strong>zlib.compress</strong>可以压缩字符串。使用
<strong>zlib.decompress</strong>可以解压字符串。</p></li>
<li><p>数据流：压缩：<strong>compressobj</strong>，解压：<strong>decompressobj</strong></p></li>
</ul>
<h2><span id="cpickle">cPickle</span><a href="#cpickle" class="header-anchor">#</a></h2>
<h4><span id="cpickle-dump">cPickle.dump</span><a href="#cpickle-dump" class="header-anchor">#</a></h4>
<p>将python对象序列化
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cPickle.dump(obj, file, protocol&#x3D;None, *, fix_imports&#x3D;True, buffer_callback&#x3D;None)</span><br></pre></td></tr></table></figure></p>
<h4><span id="cpickle-load">cPickle.load</span><a href="#cpickle-load" class="header-anchor">#</a></h4>
<p>载入本地文件，恢复python对象
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data &#x3D; cPickle.load(open(&quot;test\\data.pkl&quot;,&quot;rb&quot;))</span><br></pre></td></tr></table></figure></p>
<h4><span id="cpickle-dumps">cPickle.dumps</span><a href="#cpickle-dumps" class="header-anchor">#</a></h4>
<p>将python对象序列化保存到一个字符串变量中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data_string &#x3D; cPickle.dumps(data)</span><br></pre></td></tr></table></figure></p>
<h4><span id="cpickle-loads">cPickle.loads</span><a href="#cpickle-loads" class="header-anchor">#</a></h4>
<p>从字符串变量中载入python对象
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data &#x3D; cPickle.loads(data_string)</span><br></pre></td></tr></table></figure></p>
<h2><span id="pyflakes">pyflakes</span><a href="#pyflakes" class="header-anchor">#</a></h2>
<p>检查加载字符串代码是否有错
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from pyflakes.api import checkCode</span><br><span class="line">a &#x3D; f.read()</span><br><span class="line">checkCode(a, my_Reporter(sys.stdout, sys.stderr)) # my_Reporter是pyflakes.reporter的拓展</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">[Protobuf&gRPC] 2.gRPC简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-18 15:49:34" itemprop="dateCreated datePublished" datetime="2020-10-18T15:49:34+08:00">2020-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Protobuf-gRPC/" itemprop="url" rel="index"><span itemprop="name">Protobuf&gRPC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2><span id="rpc-kuang-jia-yuan-li">RPC 框架原理</span><a href="#rpc-kuang-jia-yuan-li" class="header-anchor">#</a></h2>
<p>RPC 框架的目标就是让远程服务调用更加简单、透明，RPC
框架负责<strong>屏蔽底层的传输方式（TCP 或者
UDP）、序列化方式（XML/Json/
二进制）和通信细节</strong>。服务<strong>调用者可以像调用本地接口一样调用远程的服务提供者</strong>，而不需要关心底层通信细节和调用过程。</p>
<div style="width:90%;margin:auto">
<img src="/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/rpc%E7%AE%80%E4%BB%8B.png" class title="rpc简介图">
</div>
<p>业界主流的 RPC 框架整体上分为三类：</p>
<ul>
<li>支持多语言的 RPC 框架，比较成熟的有 <strong>Google 的
gRPC、Apache（Facebook）的 Thrift</strong>；</li>
<li>只支持<strong>特定语言的 RPC 框架</strong>，例如新浪微博的
<strong>Motan</strong>；</li>
<li>支持<strong>服务治理等服务化特性的分布式服务框架</strong>，其底层内核仍然是
RPC 框架, 例如阿里的 Dubbo。</li>
</ul>
<h2><span id="grpc-jian-jie">gRPC 简介</span><a href="#grpc-jian-jie" class="header-anchor">#</a></h2>
<p>gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端，基于
HTTP/2 设计。</p>
<div style="width:90%;margin:auto">
<img src="/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/grpc%E7%AE%80%E4%BB%8B.png" class title="grpc简介图">
</div>
<p>gRPC 客户端和服务端<strong>可以在多种环境中运行和交互</strong> - 从
google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC
支持的语言来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用
Go、Python、Ruby 来创建客户端。此外，<strong>Google 最新 API 将有 gRPC
版本的接口</strong>，使你很容易地将 Google 的功能集成到你的应用里。</p>
<p>gRPC 特点 - 语言中立，支持多种语言； - 基于 IDL 文件定义服务，通过
proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub； -
通信协议基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单 TCP
的多路复用、服务端推送等特性，这些特性使得 gRPC
在移动端设备上更加省电和节省网络流量； - 序列化支持 PB（Protocol
Buffer）和 JSON，PB 是一种语言无关的高性能序列化框架，基于 HTTP/2 + PB,
保障了 RPC 调用的高性能。</p>
<h2><span id="grpc-you-shi-me-hao-chu-yi-ji-zai-shi-me-chang-jing-xia-xu-yao-yong-grpc">gRPC有什么好处以及在什么场景下需要用gRPC</span><a href="#grpc-you-shi-me-hao-chu-yi-ji-zai-shi-me-chang-jing-xia-xu-yao-yong-grpc" class="header-anchor">#</a></h2>
<p>gRPC vs. Restful API gRPC和restful
API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说,
gRPC使用的http2.0，而restful
api则不一定)。不过gRPC还是有些特有的优势，如下：</p>
<ul>
<li>gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。</li>
<li>通过protobuf可以将数据<strong>序列化为二进制编码</strong>，这会<strong>大幅减少需要传输的数据量，从而大幅提高性能</strong>。</li>
<li>gRPC可以方便地<strong>支持流式通信</strong>(理论上通过http2.0就可以使用streaming模式,
但是通常web服务的restful
api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）</li>
<li>proto文件生成目标代码，简单易用</li>
<li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li>
<li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li>
<li>Netty等一些框架集成</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、GRPC尚未提供连接池，需要自行实现</li>
<li>2、尚未提供“服务发现”、“负载均衡”机制</li>
<li>3、因为基于HTTP2，绝大部多数HTTP
Server、Nginx都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求。（nginx1.9版本已支持）</li>
<li>4、Protobuf二进制可读性差（貌似提供了Text_Fromat功能）</li>
<li>5、默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
</ul>
<h3><span id="shi-yong-protocol-buffers">使用 protocol buffers</span><a href="#shi-yong-protocol-buffers" class="header-anchor">#</a></h3>
<p>gRPC 默认使用 protocol buffers（protobuf），这是 Google
开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如
JSON）。正如你将在下方例子里所看到的，你用 proto files 创建 gRPC
服务，用 protobuf 消息类型来定义方法参数和返回类型。protobuf相关可以看
<a target="_blank" rel="noopener" href="http://liuw.tech/2020/10/17/Protobuf-gRPC-1-protobuf%E7%AE%80%E4%BB%8B/" title="[Protobuf&amp;gRPC] 1.protobuf简介">protobuf简介</a></p>
<h3><span id="ji-yu-http-2-0-biao-zhun-she-ji">基于HTTP 2.0标准设计</span><a href="#ji-yu-http-2-0-biao-zhun-she-ji" class="header-anchor">#</a></h3>
<p>由于gRPC<strong>基于HTTP
2.0</strong>标准设计，带来了更多强大功能，如<strong>多路复用、二进制帧、头部压缩、推送机制</strong>。这些功能给设备带来重大益处，如<strong>节省带宽、降低TCP连接次数、节省CPU使用</strong>等。gRPC既能够在客户端应用，也能够在服务器端应用，从而<strong>以透明的方式实现两端的通信和简化通信系统的构建</strong>。</p>
<p>HTTP 版本分为HTTP 1.X、 HTTP 2.0，其中HTTP
1.X是当前使用最广泛的HTTP协议，<strong>HTTP
2.0称为超文本传输协议第二代</strong>。HTTP
1.X定义了四种与服务器交互的方式，分别为：<strong>GET、POST、PUT、DELETE</strong>，这些在HTTP
2.0中均保留。我们再来看看HTTP 2.0的新特性：</p>
<h4><span id="1-shuang-xiang-liu-duo-lu-fu-yong">1.双向流、多路复用</span><a href="#1-shuang-xiang-liu-duo-lu-fu-yong" class="header-anchor">#</a></h4>
<p>在HTTP
1.X协议中，客户端在同一时间访问同一域名的请求数量是有限制的，当超过阈值时请求会被阻断，但是这种情况在HTTP
2.0中将被忽略。由于HTTP 1.X传输的是纯文本数据，传输体积较大，而HTTP
2.0传输的基本单元为帧，每个帧都包含消息，并且由于HTTP
2.0允许同时通过一条连接发起多个“请求-响应”消息，无需建立多个TCP链接的同时实现多条流并行，提高吞吐性能，并且在一个连接内对多个消息进行优先级的管理和流控。</p>
<h4><span id="2-er-jin-zhi-zheng">2.二进制帧</span><a href="#2-er-jin-zhi-zheng" class="header-anchor">#</a></h4>
<p>相对于<strong>HTTP 1.X的纯文本传输</strong>，HTTP
2.0传输的是<strong>二进制数据</strong>，与Protocol
Buffers相辅相成。使得<strong>传输数据体积小、负载低</strong>，保持<strong>更加紧凑和高效</strong>。</p>
<h4><span id="3-tou-bu-ya-suo">3.头部压缩</span><a href="#3-tou-bu-ya-suo" class="header-anchor">#</a></h4>
<p>因为HTTP是<strong>无状态协议</strong>，对于业务的处理没有记忆能力，每一次请求都需要携带设备的所有细节，特别是<strong>在头部都会包含大量的重复数据</strong>，对于设备来说就是在不断地做无意义的重复性工作。HTTP
2.0中<strong>使用“头表”来跟踪之前发送的数据</strong>，对于<strong>相同的数据将不再使用重复请求和发送</strong>，进而<strong>减少数据的体积</strong>。</p>
<hr>
<h2><span id="grpc-you-si-chong-tong-xin-fang-shi">gRPC有四种通信方式:</span><a href="#grpc-you-si-chong-tong-xin-fang-shi" class="header-anchor">#</a></h2>
<h3><span id="1-simple-rpc">1、 Simple RPC</span><a href="#1-simple-rpc" class="header-anchor">#</a></h3>
<p>简单rpc 这就是一般的rpc调用，一个请求对象对应一个返回对象 proto语法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc simpleHello(Person) returns (Result) &#123;&#125;</span><br></pre></td></tr></table></figure>
### 2、 Server-side streaming RPC 服务端流式rpc
一个请求对象，服务端可以传回多个结果对象 proto语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc serverStreamHello(Person) returns (stream Result) &#123;&#125;</span><br></pre></td></tr></table></figure>
### 3、 Client-side streaming RPC 客户端流式rpc
客户端传入多个请求对象，服务端返回一个响应结果 proto语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc clientStreamHello(stream Person) returns (Result) &#123;&#125;</span><br></pre></td></tr></table></figure>
### 4、 Bidirectional streaming RPC 双向流式rpc
结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象
proto语法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc biStreamHello(stream Person) returns (stream Result) &#123;&#125;</span><br></pre></td></tr></table></figure>
--- ## 服务端创建流程 gRPC 服务端创建采用 <strong>Build
模式</strong>，对<strong>底层服务绑定、transportServer 和 NettyServer
的创建和实例化</strong>做了<strong>封装和屏蔽</strong>，让服务调用者不用关心
RPC 调用细节，整体上分为三个过程：</p>
<ul>
<li>创建 Netty HTTP/2 服务端；</li>
<li>将需要调用的服务端接口实现类注册到内部的 Registry 中，RPC
调用时，可以根据 RPC 请求消息中的服务定义信息查询到服务接口实现类；</li>
<li>创建 gRPC Server，它是 gRPC 服务端的抽象，聚合了各种 Listener，用于
RPC 消息的统一调度和处理。</li>
</ul>
<div style="width:90%;margin:auto">
<img src="/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/grpc%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA.png" class title="grpc服务端创建图">
</div>
<h2><span id="grpc-fu-wu-duan-chuang-jian-guan-jian-liu-cheng-fen-xi">gRPC 服务端创建关键流程分析：</span><a href="#grpc-fu-wu-duan-chuang-jian-guan-jian-liu-cheng-fen-xi" class="header-anchor">#</a></h2>
<ul>
<li>NettyServer 实例创建：gRPC 服务端创建，首先需要<strong>初始化
NettyServer</strong>，它是 gRPC 基于 <strong>Netty 4.1 HTTP/2
协议栈之上封装的 HTTP/2 服务端</strong>。NettyServer 实例<strong>由
NettyServerBuilder 的 buildTransportServer
方法构建</strong>，NettyServer 构建完成之后，<strong>监听指定的 Socket
地址，即可实现基于 HTTP/2 协议的请求消息接入</strong>。</li>
<li>绑定 IDL 定义的服务接口实现类：gRPC 与其它一些 RPC
框架的差异点是<strong>服务接口实现类的调用并不是通过动态代理和反射机制</strong>，而是通过
<strong>proto 工具生成代码，在服务端启动时，将服务接口实现类实例注册到
gRPC
内部的服务注册中心上</strong>。请求消息接入之后，可以<strong>根据服务名和方法名，直接调用启动时注册的服务实例</strong>，而不需要通过反射的方式进行调用，性能更优。</li>
<li>gRPC 服务实例（ServerImpl）构建：<strong>ServerImpl 负责整个 gRPC
服务端消息的调度和处理</strong>，创建 ServerImpl
实例过程中，会<strong>对服务端依赖的对象进行初始化</strong>，例如
<strong>Netty 的线程池资源、gRPC
的线程池、内部的服务注册类（InternalHandlerRegistry）</strong>等，ServerImpl
初始化完成之后，就可以<strong>调用 NettyServer 的 start 方法启动 HTTP/2
服务端</strong>，接收 gRPC 客户端的服务调用请求</li>
</ul>
<h2><span id="grpc-helloworld-shi-li-xiang-jie">gRPC HelloWorld实例详解</span><a href="#grpc-helloworld-shi-li-xiang-jie" class="header-anchor">#</a></h2>
<p>gRPC的使用通常包括如下几个步骤：</p>
<ol type="1">
<li>通过protobuf来定义接口和数据类型</li>
<li>使用gRPC protobuf生成工具生成对应语言的库函数</li>
<li>编写gRPC server端代码</li>
<li>编写gRPC client端代码 下面来通过一个实例来详细讲解上述的三步。
下边的hello world实例完成之后，其目录结果如下：</li>
</ol>
<h3><span id="1-ding-yi-jie-kou-he-shu-ju-lei-xing">1. 定义接口和数据类型</span><a href="#1-ding-yi-jie-kou-he-shu-ju-lei-xing" class="header-anchor">#</a></h3>
<p>通过protobuf定义接口和数据类型
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package rpc_package;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端发送rpc方法，response &#x3D; stub.SayHello(HelloRequest(name&#x3D;&#39;eric&#39;))</span><br><span class="line">&#x2F;&#x2F; 服务端返回response，是HelloReply类型</span><br><span class="line"></span><br><span class="line">service HelloWorldService &#123;</span><br><span class="line">    &#x2F;&#x2F; define the interface and data type</span><br><span class="line">    rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; define the data type of request</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; define the data type of response</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">    string message &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3><span id="2-shi-yong-grpc-protobuf-sheng-cheng-gong-ju-sheng-cheng-dui-ying-yu-yan-de-ku-han-shu">2.使用gRPC
protobuf生成工具生成对应语言的库函数</span><a href="#2-shi-yong-grpc-protobuf-sheng-cheng-gong-ju-sheng-cheng-dui-ying-yu-yan-de-ku-han-shu" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I&#x3D;.&#x2F;protos --python_out&#x3D;.&#x2F;rpc_package --grpc_python_out&#x3D;.&#x2F;rpc_package</span><br></pre></td></tr></table></figure>
<p>这个指令会自动生成rpc_package文件夹中的<strong>helloworld_pb2.py和helloworld_pb2_grpc.py</strong>，但是不会自动生成__init__.py文件，需要我们手动添加</p>
<h3><span id="3-bian-xie-grpc-server-duan-dai-ma">3. 编写gRPC server端代码</span><a href="#3-bian-xie-grpc-server-duan-dai-ma" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*-coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from concurrent import futures</span><br><span class="line">import grpc</span><br><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">from rpc_package.helloworld_pb2_grpc import add_HelloWorldServiceServicer_to_server, \ </span><br><span class="line">    HelloWorldServiceServicer</span><br><span class="line">from rpc_package.helloworld_pb2 import HelloRequest, HelloReply</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Hello(HelloWorldServiceServicer):</span><br><span class="line"></span><br><span class="line">    # 这里实现我们定义的接口</span><br><span class="line">    def SayHello(self, request, context):</span><br><span class="line">        return HelloReply(message&#x3D;&#39;Hello, %s!&#39; % request.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def serve():</span><br><span class="line">    # 这里通过thread pool来并发处理server的任务</span><br><span class="line">    server &#x3D; grpc.server(futures.ThreadPoolExecutor(max_workers&#x3D;10))</span><br><span class="line"></span><br><span class="line">    # 将对应的任务处理函数添加到rpc server中</span><br><span class="line">    add_HelloWorldServiceServicer_to_server(Hello(), server)</span><br><span class="line"></span><br><span class="line">    # 这里使用的非安全接口，世界gRPC支持TLS&#x2F;SSL安全连接，以及各种鉴权机制</span><br><span class="line">    server.add_insecure_port(&#39;[::]:50000&#39;)</span><br><span class="line">    server.start()</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            time.sleep(60 * 60 * 24)</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        server.stop(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure>
<h3><span id="4-grpc-client-duan-dai-ma">4.gRPC client端代码</span><a href="#4-grpc-client-duan-dai-ma" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from __future__ import print_function</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">import grpc</span><br><span class="line">from rpc_package.helloworld_pb2 import HelloRequest, HelloReply</span><br><span class="line">from rpc_package.helloworld_pb2_grpc import HelloWorldServiceStub</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    # 使用with语法保证channel自动close</span><br><span class="line">    with grpc.insecure_channel(&#39;localhost:50000&#39;) as channel:</span><br><span class="line">        # 客户端通过stub来实现rpc通信</span><br><span class="line">        # 传入通信channel</span><br><span class="line">        stub &#x3D; HelloWorldServiceStub(channel)</span><br><span class="line"></span><br><span class="line">        # 客户端必须使用定义好的类型，这里是HelloRequest类型</span><br><span class="line">        # 客户端发&#x2F;请求</span><br><span class="line">        response &#x3D; stub.SayHello(HelloRequest(name&#x3D;&#39;eric&#39;))</span><br><span class="line">    print (&quot;hello client received: &quot; + response.message)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>
<h3><span id="demo">demo</span><a href="#demo" class="header-anchor">#</a></h3>
<p>运行server端代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python hello_server.py</span><br></pre></td></tr></table></figure>
接着执行client端代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  grpc_test python hello_client.py</span><br><span class="line">hello client received: Hello, eric!</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://grpc.io/" title="gRPC官网">gRPC官网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9e57da13b737" title="grpc原理">grpc原理</a></li>
<li><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1633335936037018920&amp;wfr=spider&amp;for=pc" title="grpc特性分析">grpc特性分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/linuxarmsummary/article/details/79467412" title="gRPC 官方文档中文版">gRPC 官方文档中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7392406e2450" title="grpc应用详解与实例剖析">grpc应用详解与实例剖析</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/17/Protobuf-gRPC-1-protobuf%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/17/Protobuf-gRPC-1-protobuf%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">[Protobuf&gRPC] 1.protobuf简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-17 21:21:34" itemprop="dateCreated datePublished" datetime="2020-10-17T21:21:34+08:00">2020-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Protobuf-gRPC/" itemprop="url" rel="index"><span itemprop="name">Protobuf&gRPC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3><span id="mu-lu">目录</span><a href="#mu-lu" class="header-anchor">#</a></h3>
<p>[TOC]</p>
<h2><span id="protobuf-shi-shi-me">Protobuf是什么</span><a href="#protobuf-shi-shi-me" class="header-anchor">#</a></h2>
<p>Protobuf全称是Google Protocol
Buffer，是一种高效轻便的<strong>结构化数据存储方式</strong>，可用于网络通信、数据存储等。</p>
<p>其具有以下优点：</p>
<ul>
<li>平台无关、语言无关</li>
<li>支持Java, C++, Python等多种语言，支持多平台。</li>
<li>轻便高效，比XML更小（3~10倍），更快（20 ~ 100倍），更为简单。</li>
<li>扩展性，兼容性好</li>
<li>序列化数据结构的协议，可以更新数据结构，而不影响和破坏原有的旧程序。</li>
</ul>
<div style="width:90%;margin:auto">
<img src="/2020/10/17/Protobuf-gRPC-1-protobuf%E7%AE%80%E4%BB%8B/protobuf%E7%AE%80%E4%BB%8B.png" class title="protobuf简介图">
</div>
<h3><span id="xu-lie-hua">序列化</span><a href="#xu-lie-hua" class="header-anchor">#</a></h3>
<p>将数据结构或对象转换成能够被存储和传输（例如网络传输）的格式（网络传输传输的是<strong>二进制数据</strong>），同时应当要保证这个序列化结果在之后（可能是另一个计算环境中）能够<strong>被重建回原来的数据结构或对象</strong>。</p>
<h2><span id="protobuf-yu-fa-jie-shao">protobuf语法介绍</span><a href="#protobuf-yu-fa-jie-shao" class="header-anchor">#</a></h2>
<p>目前有Protobuf2和Protobuf3。</p>
<h3><span id="protobuf2-yu-fa-jian-jie">protobuf2语法简介</span><a href="#protobuf2-yu-fa-jian-jie" class="header-anchor">#</a></h3>
<p>.proto文件中数据类型可以分为两大类:</p>
<ul>
<li>复合数据类型包括：<strong>枚举和message类型</strong></li>
<li>标准数据类型包含：<strong>整型，浮点，字符串</strong>等</li>
</ul>
<p>数据类型前面修饰词：</p>
<ul>
<li>required:
<strong>必须赋值</strong>，不能为空，否则该条message会被认为是“uninitialized”。除此之外，“required”字段跟“optional”字段并无差别。</li>
<li>optional:字段<strong>可以赋值，也可以不赋值</strong>。假如没有赋值的话，会被赋上默认值。</li>
<li>repeated:
该字段<strong>可以重复任意次数</strong>，包括0次。重复数据的顺序将会保存在protocol
buffer中，将这个字段想象成一个可以自动设置size的数组就可以了。</li>
</ul>
<p>注：<strong>每个字段要给数字</strong>
<strong>该Number是用来标记该字段在序列化后的二进制数据中所在的field</strong>，每个字段的<strong>Number在message内部都是独一无二的</strong>。也<strong>不能进行改变</strong>，否则数据就不能正确的解包</p>
<p>关于 proto2 定义 message
消息的更多语法细节，例如具有支持哪些类型，字段编号分配、import
导入定义，reserved 保留字段等知识请参阅 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6f68fb2c7d19" title="ProtoBuf 官方文档（二）- 语法指引（proto2）">ProtoBuf
官方文档（二）- 语法指引（proto2）</a></p>
<p>关于定义时的一些规范请参阅 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c55fb0a09b5" title="[翻译] ProtoBuf 官方文档（四）- 规范指引">[翻译] ProtoBuf
官方文档（四）- 规范指引</a></p>
<h3><span id="protobuf3-yu-fa-jie-shao">protobuf3语法介绍</span><a href="#protobuf3-yu-fa-jie-shao" class="header-anchor">#</a></h3>
<ul>
<li><p>字段前取消了required和optional两个关键字，目前可用的只有repeated关键字。</p></li>
<li><p>不可以设置默认值了。</p>
<ol type="1">
<li>string默认为空串</li>
<li>枚举默认为第一个枚举定义的第一个值。并且必须是0,必须有有一个0值，我们可以用这个0值作为默认值。这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。</li>
<li>bytes默认为空bytes</li>
<li>bool默认为false</li>
<li>数字类型默认为0</li>
</ol></li>
<li><p>protoType类型如下：
double、float、int32、int64、uint32、uint64、sint32、sint64、fixed32、fixed64、sfixed32、sfixed64、bool、string、bytes</p></li>
<li><p>分配标识号
正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留
[1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p></li>
<li><p>标识号区间[1，2^29 -
1]。<strong>不可以使用其中的[19000－19999]</strong>(从FieldDescriptor::kFirstReservedNumber
到 FieldDescriptor::kLastReservedNumber)的标识号，
Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。</p></li>
<li><p>指定字段规则 所指定的消息字段修饰符必须是如下之一：
<strong>singular</strong>：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。
<strong>repeated</strong>：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。
在proto3中，repeated的标量域默认情况下使用packed。</p></li>
</ul>
<h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h2>
<p>使用Python的话简便的安装方法如下（linux）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install protobuf    # 安装protobuf库</span><br><span class="line">sudo apt-get install protobuf-compiler  # 安装protobuf编译器</span><br></pre></td></tr></table></figure>
<h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor">#</a></h2>
<p>目前有Protobuf2和Protobuf3，本文以Protobuf3为例。</p>
<h3><span id="di-yi-bu-chuang-jian-proto-wen-jian-ding-yi-shu-ju-jie-gou">第一步，创建.proto文件，定义数据结构</span><a href="#di-yi-bu-chuang-jian-proto-wen-jian-ding-yi-shu-ju-jie-gou" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指定正在使用proto3语法：如果没有指定这个，编译器会使用proto2</span><br><span class="line">&#x2F;&#x2F;这个指定语法行必须是文件的非空非注释的第一个行</span><br><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">  int32 id &#x3D; 2;</span><br><span class="line">  string email &#x3D; 3;</span><br><span class="line">  float money &#x3D; 4;</span><br><span class="line">  bool work_status &#x3D; 5;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones &#x3D; 6;</span><br><span class="line">  MyMessage maps &#x3D; 7;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message PhoneNumber &#123;</span><br><span class="line">    string number &#x3D; 1;</span><br><span class="line">    PhoneType type &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    MOBILE &#x3D; 0;</span><br><span class="line">    HOME &#x3D; 1;</span><br><span class="line">    WORK &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message MyMessage &#123;</span><br><span class="line">  map&lt;int32, int32&gt; mapfield &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="di-er-bu-protoc-bian-yi-proto-wen-jian-sheng-cheng-du-xie-jie-kou">第二步，protoc 编译
.proto 文件生成读写接口</span><a href="#di-er-bu-protoc-bian-yi-proto-wen-jian-sheng-cheng-du-xie-jie-kou" class="header-anchor">#</a></h3>
<p>我们在 .proto
文件中定义了数据结构，这些数据结构是<strong>面向开发者和业务程序的</strong>，并不面向存储和传输。</p>
<p>当需要把这些数据进行存储或传输时，就需要<strong>将这些结构数据进行序列化、反序列化以及读写</strong>。那么如何实现呢？答案就是通过
<strong>protoc</strong> 这个编译器。</p>
<p>利用protoc.exe编译proto文件，cmd切换到当前目录，执行以下命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $SRC_DIR: .proto 所在的源目录</span><br><span class="line">&#x2F;&#x2F; --python_out: 生成 python 代码</span><br><span class="line">&#x2F;&#x2F; $DST_DIR: 生成代码的目标目录</span><br><span class="line">&#x2F;&#x2F; xxx.proto: 要针对哪个 proto 文件生成接口代码</span><br><span class="line">protoc -I&#x3D;$SRC_DIR --python_out&#x3D;$DST_DIR xxx.proto</span><br></pre></td></tr></table></figure>
这里我们使用如下编译语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I&#x3D;. --python_out&#x3D;.&#x2F; addressbook.proto</span><br></pre></td></tr></table></figure></p>
<p>编译好之后你就会在目标目录里面看到输出的结果文件，如下：addressbook_pb2.py</p>
<h3><span id="di-san-bu-bian-yi-py-wen-jian-jin-xing-xu-lie-hua-he-fan-xu-lie-hua">第三步，编译.py文件，进行序列化和凡序列化</span><a href="#di-san-bu-bian-yi-py-wen-jian-jin-xing-xu-lie-hua-he-fan-xu-lie-hua" class="header-anchor">#</a></h3>
<p>add_person.py
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from tutorial import addressbook_pb2</span><br><span class="line"></span><br><span class="line">address_book &#x3D; addressbook_pb2.AddressBook()</span><br><span class="line">person &#x3D; address_book.people.add()</span><br><span class="line"></span><br><span class="line">person.id &#x3D; 1</span><br><span class="line">person.name &#x3D; &quot;safly&quot;</span><br><span class="line">person.email &#x3D; &quot;safly@qq.com&quot;</span><br><span class="line">person.money &#x3D; 1000.11</span><br><span class="line">person.work_status &#x3D; True</span><br><span class="line"></span><br><span class="line">phone_number &#x3D; person.phones.add()</span><br><span class="line">phone_number.number &#x3D; &quot;123456&quot;</span><br><span class="line">phone_number.type &#x3D; addressbook_pb2.MOBILE</span><br><span class="line"></span><br><span class="line">maps &#x3D; person.maps</span><br><span class="line">maps.mapfield[1] &#x3D; 1</span><br><span class="line">maps.mapfield[2] &#x3D; 2</span><br><span class="line"></span><br><span class="line">#序列化</span><br><span class="line">serializeToString &#x3D; address_book.SerializeToString()</span><br><span class="line">print(serializeToString,type(serializeToString))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">address_book.ParseFromString(serializeToString)</span><br><span class="line"></span><br><span class="line">for person in address_book.people:</span><br><span class="line">  print(&quot;p_id&#123;&#125;,p_name&#123;&#125;,p_email&#123;&#125;,p_money&#123;&#125;,p_workstatu&#123;&#125;&quot;</span><br><span class="line">        .format(person.id,person.name,person.email,person.money,person.work_status))</span><br><span class="line"></span><br><span class="line">  for phone_number in person.phones:</span><br><span class="line">    print(phone_number.number,phone_number.type)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for key in person.maps.mapfield:</span><br><span class="line">    print(key,person.maps.mapfield[key])</span><br></pre></td></tr></table></figure>
编译该py文件，输出结果如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b&#39;\n6\n\x05safly\x10\x01\x1a\x0csafly@qq.com%\n\x07zD(\x012\x08\n\x06123456:\x0c\n\x04\x08\x01\x10\x01\n\x04\x08\x02\x10\x02&#39; &lt;class &#39;bytes&#39;&gt;</span><br><span class="line"></span><br><span class="line">p_id1,p_namesafly,p_emailsafly@qq.com,p_money1000.1099853515625,p_workstatuTrue</span><br><span class="line">123456 0</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
我们就看到了序列化和反序列化的结果</p>
<p>这篇简介就介绍到这，后期会继续</p>
<h2><span id="jin-jie-shi-yong">进阶使用</span><a href="#jin-jie-shi-yong" class="header-anchor">#</a></h2>
<p>addressbook.proto内容如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package tutorial;</span><br><span class="line">&#x2F;&#x2F;引入外部proto</span><br><span class="line">import &quot;emu.proto&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">  int32 id &#x3D; 2;</span><br><span class="line">  string email &#x3D; 3;</span><br><span class="line">  float money &#x3D; 4;</span><br><span class="line">  bool work_status &#x3D; 5;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones &#x3D; 6;</span><br><span class="line">  &#x2F;&#x2F;外部引用map</span><br><span class="line">  repeated MyMessage maps &#x3D; 7;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;内部嵌套message</span><br><span class="line">  repeated Hobby hobby &#x3D; 8;</span><br><span class="line">  message Hobby&#123;</span><br><span class="line">    string interest &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message PhoneNumber &#123;</span><br><span class="line">    string number &#x3D; 1;</span><br><span class="line">    PhoneType type &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    MOBILE &#x3D; 0;</span><br><span class="line">    HOME &#x3D; 1;</span><br><span class="line">    WORK &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们将addressbook.proto中的repeated MyMessage maps = 7;进行了外部引用，
emu.proto如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message MyMessage &#123;</span><br><span class="line">  map&lt;int32, int32&gt; mapfield &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后首先对emu.proto进行编译， protoc ./emu.proto --python_out=./</p>
<p>然后会addressbook.proto进行编译 protoc ./addressbook.proto
--python_out=./
然后会默认生成上述截图中的emu_pb2.py、addressbook_pb2.py文件</p>
<p>我们接下来看看add_person.py代码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from tutorial import addressbook_pb2</span><br><span class="line"></span><br><span class="line">address_book &#x3D; addressbook_pb2.AddressBook()</span><br><span class="line">person &#x3D; address_book.people.add()</span><br><span class="line"></span><br><span class="line">person.id &#x3D; 1</span><br><span class="line">person.name &#x3D; &quot;safly&quot;</span><br><span class="line">person.email &#x3D; &quot;safly@qq.com&quot;</span><br><span class="line">person.money &#x3D; 1000.11</span><br><span class="line"></span><br><span class="line">person.work_status &#x3D; True</span><br><span class="line"></span><br><span class="line">phone_number &#x3D; person.phones.add()</span><br><span class="line">phone_number.number &#x3D; &quot;123456&quot;</span><br><span class="line">phone_number.type &#x3D; addressbook_pb2.MOBILE</span><br><span class="line"></span><br><span class="line">maps &#x3D; person.maps.add()</span><br><span class="line">maps.mapfield[1] &#x3D; 1</span><br><span class="line">maps.mapfield[2] &#x3D; 2</span><br><span class="line"></span><br><span class="line">hobby &#x3D; person.hobby.add()</span><br><span class="line">hobby.interest &#x3D; &quot;python&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#序列化</span><br><span class="line">serializeToString &#x3D; address_book.SerializeToString()</span><br><span class="line">print(serializeToString,type(serializeToString))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">address_book.ParseFromString(serializeToString)</span><br><span class="line"></span><br><span class="line">for person in address_book.people:</span><br><span class="line">  print(&quot;p_id&#123;&#125;,p_name&#123;&#125;,p_email&#123;&#125;,p_money&#123;&#125;,p_workstatu&#123;&#125;&quot;</span><br><span class="line">        .format(person.id,person.name,person.email,person.money,person.work_status))</span><br><span class="line"></span><br><span class="line">  for phone_number in person.phones:</span><br><span class="line">    print(phone_number.number,phone_number.type)</span><br><span class="line">  print(person.phones[0].number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for map in person.maps:</span><br><span class="line">    for key in map.mapfield:</span><br><span class="line">      print(key,&#39;-------&#39;,map.mapfield[key])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for hobby in person.hobby:</span><br><span class="line">    print(hobby.interest)</span><br></pre></td></tr></table></figure>
最后输出结果如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Users&#x2F;zhiliao&#x2F;miniconda3&#x2F;bin&#x2F;python &#x2F;Users&#x2F;zhiliao&#x2F;zhiliao&#x2F;untitled1&#x2F;tutorial&#x2F;add_person.py</span><br><span class="line">b&#39;\n@\n\x05safly\x10\x01\x1a\x0csafly@qq.com%\n\x07zD(\x012\x08\n\x06123456:\x0c\n\x04\x08\x01\x10\x01\n\x04\x08\x02\x10\x02B\x08\n\x06python&#39; &lt;class &#39;bytes&#39;&gt;</span><br><span class="line">p_id1,p_namesafly,p_emailsafly@qq.com,p_money1000.1099853515625,p_workstatuTrue</span><br><span class="line">123456 0</span><br><span class="line">123456</span><br><span class="line">2 ------- 2</span><br><span class="line">1 ------- 1</span><br><span class="line">python</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013210620/article/details/81317731" title="python基础--protobuf的使用(一)">python基础--protobuf的使用(一)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2265f56805fa" title="Protobuf学习">Protobuf学习</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/31a6b4b2c3ab" title="Protobuf Python 示例">Protobuf Python 示例</a></li>
</ol>
<h2><span id="tuo-zhan-yue-du">拓展阅读</span><a href="#tuo-zhan-yue-du" class="header-anchor">#</a></h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/73c9ed3a4877" title="深入 ProtoBuf - 编码">深入 ProtoBuf - 编码</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/62f0238beec8" title="深入 ProtoBuf - 序列化源码解析">深入 ProtoBuf -
序列化源码解析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ddc1aaca3691" title="深入 ProtoBuf - 反射原理解析">深入 ProtoBuf -
反射原理解析</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">[python源码分析] 2.对象的生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-11 14:13:31" itemprop="dateCreated datePublished" datetime="2020-10-11T14:13:31+08:00">2020-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">python源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="c-api">C API</span><a href="#c-api" class="header-anchor">#</a></h1>
<p>开始讨论对象创建前，先介绍 Python 提供的 C API 。 Python 是用 C
写成的，对外提供了 C API ，让用户可以从 C 环境中与其交互。 Python
内部也大量使用这些 API ，为了更好研读源码，先系统了解 API
组成结构很有必要。 C API 分为两类： <strong>泛型 API 以及 特型
API</strong>。</p>
<h2><span id="fan-xing-api">泛型 API</span><a href="#fan-xing-api" class="header-anchor">#</a></h2>
<p>泛型 API 与类型无关，属于 抽象对象层 ( Abstract Object Layer )，简称
AOL 。 这类 API 参数是 PyObject*
，<strong>可处理任意类型的对象</strong>， API 内部根据对象类型区别处理。
以对象打印函数为例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int PyObject_Print(PyObject *op, FILE *fp, int flags)</span><br></pre></td></tr></table></figure></p>
<p>接口第一个参数为待打印对象，可以是任意类型的对象，因此参数类型是
PyObject* 。 Python 内部一般都是通过 PyObject*
引用对象，以达到泛型化的目的。 <strong>对于任意类型的对象，均可调用
PyObject_Print 将其打印出来</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印浮点对象</span><br><span class="line">PyObject *fo &#x3D; PyFloatObject_FromDouble(3.14);</span><br><span class="line">PyObject_Print(fo, stdout, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印整数对象</span><br><span class="line">PyObject *lo &#x3D; PyFloatObject_FromLong(100);</span><br><span class="line">PyObject_Print(lo, stdout, 0);</span><br><span class="line">PyObject_Print 接口内部根据对象类型，决定如何输出对象。</span><br></pre></td></tr></table></figure></p>
<h2><span id="te-xing-api">特型 API</span><a href="#te-xing-api" class="header-anchor">#</a></h2>
<p>特型 API 与类型相关，属于 具体对象层 ( Concrete Object Layer )，简称
COL 。 这类 API 只能作用于某种类型的对象，例如浮点对象 PyFloatObject 。
Python 内部为每一种内置对象提供了这样一组 API ，举例如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyObject * PyFloat_FromDouble(double fval)</span><br></pre></td></tr></table></figure>
PyFloat_FromDouble 创建一个浮点对象，并将它初始化为给定值 fval 。</p>
<h1><span id="dui-xiang-de-chuang-jian">对象的创建</span><a href="#dui-xiang-de-chuang-jian" class="header-anchor">#</a></h1>
<p>经过前面的理论学习，我们知道对象的 <strong>元数据</strong>
保存在对应的 <strong>类型对象</strong> 中，元数据当然也包括
<strong>对象如何创建 的信息</strong>。 因此，有理由相信 <strong>实例对象
由 类型对象</strong> 创建。 不管创建对象的流程如何，最终的关键步骤都是
<strong>分配内存</strong> 。 Python 对 内建对象
是无所不知的，因此可以提供 C API ，直接分配内存并执行初始化。 以
PyFloat_FromDouble 为例，在接口内部为 PyFloatObject
结构体分配内存，并初始化相关字段即可。 对于用户自定义的类型 class
Dog(object) ， Python 就无法事先提供 PyDog_New 这样的 C API 了。
这种情况下，就只能通过 Dog 所对应的类型对象创建实例对象了。
至于需要分配多少内存，如何进行初始化，答案就需要在
<strong>类型对象</strong> 中找了。 总结起来，Python
内部一般通过这两种方法创建对象： - 通过 <strong>C API</strong> ，例如
PyFloat_FromDouble ，多用于内建类型； -
通过<strong>类型对象</strong>，例如 Dog ，多用于自定义类型；
通过类型对象创建实例对象，是一个更通用的流程，<strong>同时支持内置类型和自定义类型</strong>。
以创建浮点对象为例，我们还可以通过浮点类型 PyFloat_Type 来创建：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pi &#x3D; float(&#39;3.14&#39;)</span><br><span class="line">&gt;&gt;&gt; pi</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>
例子中我们通过调用类型对象 float ，实例化了一个浮点实例 pi
，<strong>对象居然还可以调用！</strong>在 Python
中，可以被调用的对象就是 <strong>可调用对象</strong> 。</p>
<p>问题来了，可调用对象被调用时，执行什么函数呢？
由于类型对象保存着实例对象的元信息， float 类型对象的类型是 type
，因此秘密应该就隐藏在 type 中。 再次考察 PyType_Type ，我们找到了
<strong>tp_call 字段</strong>，这是一个 <strong>函数指针</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyType_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;type&quot;,                                     &#x2F;* tp_name *&#x2F;</span><br><span class="line">    sizeof(PyHeapTypeObject),                   &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    sizeof(PyMemberDef),                        &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    (ternaryfunc)type_call,                     &#x2F;* tp_call *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当实例对象被调用时，便执行 tp_call 字段保存的处理函数。 因此，
float(‘3.14’) 在 C 层面等价于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyFloat_Type.ob_type.tp_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>
即：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyType_Type.tp_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>
最终执行， type_call 函数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>
调用参数通过 args 和 kwargs
两个对象传递，先不展开，留到函数机制中详细介绍。 接着围观 type_call
函数，定义于 Include/typeobject.c ，关键代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *obj;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    obj &#x3D; type-&gt;tp_new(type, args, kwds);   &#x2F;&#x2F;为对象分配内存</span><br><span class="line">    obj &#x3D; _Py_CheckFunctionResult((PyObject*)type, obj, NULL);</span><br><span class="line">    if (obj &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    type &#x3D; Py_TYPE(obj);                     &#x2F;&#x2F;获取PyType_Type</span><br><span class="line">    if (type-&gt;tp_init !&#x3D; NULL) &#123;</span><br><span class="line">        int res &#x3D; type-&gt;tp_init(obj, args, kwds);   &#x2F;&#x2F;初始化对象</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            assert(PyErr_Occurred());</span><br><span class="line">            Py_DECREF(obj);                  &#x2F;&#x2F;引用减一</span><br><span class="line">            obj &#x3D; NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            assert(!PyErr_Occurred());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，关键的步骤有两个： 1. 调用类型对象 tp_new 函数指针 申请内存
(第 7 行)； 2. 必要时调用类型对象 tp_init 函数指针对对象进行 初始化 (第
15 行)； 至此，对象的创建过程已经非常清晰了：</p>
<div style="width:80%;margin:auto">
<img src="/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%5Bpython%5D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png" class title="PyVarObject图">
</div>
<hr>
<p>总结一下，float 类型对象是 可调用对象 ，调用 float 即可创建实例对象：
1. 调用 float ， Python 最终执行其类型对象 type 的 tp_call 函数； 2.
tp_call 函数调用 float 的 tp_new 函数为实例对象分配 内存空间 ； 3.
tp_call 函数必要时进一步调用 tp_init 函数对实例对象进行 初始化 ；</p>
<h1><span id="dui-xiang-de-duo-tai-xing">对象的多态性</span><a href="#dui-xiang-de-duo-tai-xing" class="header-anchor">#</a></h1>
<p>Python 创建一个对象，比如 PyFloatObject ，会分配内存，并进行初始化。
此后， Python 内部 <strong>统一通过一个 PyObject*
变量来保存和维护这个对象</strong>，而不是通过 PyFloatObject* 变量。 通过
PyObject* 变量保存和维护对象，可以
<strong>实现更抽象的上层逻辑</strong>，而不用关心对象的实际类型和实现细节。
以对象哈希值计算为例，假设有这样一个函数接口：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Py_hash_t PyObject_Hash(PyObject *v);</span><br></pre></td></tr></table></figure>
该函数可以计算任意对象的哈希值，不管对象类型是啥。
例如，计算浮点对象哈希值：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PyObject *fo &#x3D; PyFloatObject_FromDouble(3.14);</span><br><span class="line">PyObject_Hash(fo);</span><br></pre></td></tr></table></figure>
对于其他类型，例如整数对象，也是一样的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PyObject *lo &#x3D; PyLongObject_FromLong(100);</span><br><span class="line">PyObject_Hash(lo);</span><br></pre></td></tr></table></figure>
然而，对象类型不同，其行为也千差万别，哈希值计算方法便是如此。
PyObject_Hash 函数如何解决这个问题呢？ 到 Object/object.c 中寻找答案：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Py_hash_t</span><br><span class="line">PyObject_Hash(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;类似强制类型转换，但是不像c++一样，用父类指针调用子类就行</span><br><span class="line">    &#x2F;&#x2F;这里的结构体里面指针有ob_type和tp_hash，标记了类型和哈希函数</span><br><span class="line">    PyTypeObject *tp &#x3D; Py_TYPE(v);</span><br><span class="line">    if (tp-&gt;tp_hash !&#x3D; NULL)</span><br><span class="line">        return (*tp-&gt;tp_hash)(v);</span><br><span class="line">    &#x2F;* To keep to the general practice that inheriting</span><br><span class="line">    * solely from object in C code should work without</span><br><span class="line">    * an explicit call to PyType_Ready, we implicitly call</span><br><span class="line">    * PyType_Ready here and then check the tp_hash slot again</span><br><span class="line">    * 隐式调用PyType_Ready，然后再次检查tp_hash插槽</span><br><span class="line">    *&#x2F;</span><br><span class="line">    if (tp-&gt;tp_dict &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        if (PyType_Ready(tp) &lt; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        if (tp-&gt;tp_hash !&#x3D; NULL)</span><br><span class="line">            return (*tp-&gt;tp_hash)(v);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* Otherwise, the object can&#39;t be hashed *&#x2F;</span><br><span class="line">    return PyObject_HashNotImplemented(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数先通过 <strong>ob_type 指针找到对象的类型</strong> (第 4 行)；
然后通过类型对象的 <strong>tp_hash
函数指针，调用对应的哈希值计算函数</strong> (第 6 行)。 换句话讲，
PyObject_Hash 根据对象的类型，调用不同的函数版本。 这不就是 多态 吗？
通过 ob_type 字段， <strong>Python 在 C 语言层面实现了对象的 多态
特性</strong>， 思路跟 C++ 中的 虚表指针 有异曲同工之妙。</p>
<h1><span id="dui-xiang-de-xing-wei">对象的行为</span><a href="#dui-xiang-de-xing-wei" class="header-anchor">#</a></h1>
<p>不同对象的行为不同，比如哈希值计算方法就不同，由类型对象中 tp_hash
字段决定。 除了 tp_hash ，我们看到 PyTypeObject
结构体还定义了很多函数指针，这些指针最终都会指向某个函数，或者为空。
这些函数指针可以看做是 <strong>类型对象（PyTypeObject）</strong>
中定义的 操作 ，这些操作决定对应 <strong>实例对象 在运行时的
行为</strong> 。 尽管如此，不同对象也有一些共性。 举个例子，整数对象 和
浮点对象 都支持加减乘除等 数值型操作 ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3.14 * 3.14</span><br><span class="line">9.8596</span><br></pre></td></tr></table></figure>
元组对象 tuple 和 列表对象 list 都支持下标操作：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; (&#39;apple&#39;, &#39;banana&#39;, &#39;car&#39;, &#39;dog&#39;)</span><br><span class="line">&gt;&gt;&gt; t[-1]</span><br><span class="line">&#39;dog&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l &#x3D; [&#39;alpha&#39;, &#39;beta&#39;]</span><br><span class="line">&gt;&gt;&gt; l[-1]</span><br><span class="line">&#39;beta&#39;</span><br></pre></td></tr></table></figure>
因此，以对象行为为依据，可以 <strong>对对象进行分类</strong>：</p>
<div style="width:80%;margin:auto">
<img src="/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%5Bpython%5D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png" class title="PyVarObject图">
</div>
<hr>
<p>Python 便以此为依据，为每个类别都定义了一个 标准操作集 ： -
PyNumberMethods 结构体定义了 数值型 操作； - PySequenceMethods
结构体定义了 序列型 操作； - PyMappingMethods 结构体定义了 关联型
操作；</p>
<p>只要 类型对象 提供相关 操作集 ， 实例对象 便具备对应的 行为 。
操作集字段如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    const char *tp_name; &#x2F;* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; *&#x2F;</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; &#x2F;* For allocation *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;* Method suites for standard classes *&#x2F;</span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;* Functions to access object as input&#x2F;output buffer *&#x2F;</span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>
以 float 为例，类型对象 PyFloat_Type 相关字段是这样初始化的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static PyNumberMethods float_as_number &#x3D; &#123;</span><br><span class="line">    float_add,          &#x2F;* nb_add *&#x2F;</span><br><span class="line">    float_sub,          &#x2F;* nb_subtract *&#x2F;</span><br><span class="line">    float_mul,          &#x2F;* nb_multiply *&#x2F;</span><br><span class="line">    float_rem,          &#x2F;* nb_remainder *&#x2F;</span><br><span class="line">    float_divmod,       &#x2F;* nb_divmod *&#x2F;</span><br><span class="line">    float_pow,          &#x2F;* nb_power *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;PyFloat_Type是PyTypeObject结构体类型，只是重写了</span><br><span class="line">&#x2F;&#x2F;注意与c++父类区分开，这里只是重定义了一些具体参数</span><br><span class="line">PyTypeObject PyFloat_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;float&quot;,</span><br><span class="line">    sizeof(PyFloatObject),</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &amp;float_as_number,                           &#x2F;* tp_as_number *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>字段 <strong>tp_as_number 非空</strong>，因此 float 对象
<strong>支持数值型操作</strong> ；</li>
<li>字段 <strong>tp_as_sequence 为空</strong>，因此 float 对象
<strong>不支持序列型操作</strong> ；</li>
<li>字段 tp_as_mapping 为空，因此 float 对象
<strong>不支持关联型操作</strong> ； 注意到， float_as_number
变量中相关函数指针都初始化为对应的 float 版本操作函数。</li>
</ul>
<h1><span id="yin-yong-ji-shu">引用计数</span><a href="#yin-yong-ji-shu" class="header-anchor">#</a></h1>
<p>C/C++
赋予程序员极大的自由，可以任意申请内存，并按自己的意图灵活管理。
然而，权利的另一面则对应着 责任 ，一旦内存不再使用，程序员必须将其释放。
这给程序员带来极大的 工作负担 ，并导致大量问题： <strong>内存泄露 、
野指针 、 越界访问</strong> 等。 许多后来兴起的开发语言，如 Java 、
Golang 等，选择 由语言本身负责内存的管理 。 垃圾回收机制
的引入，程序员摆脱了内存管理的噩梦，可以更专注于业务逻辑。
于此同时，开发人员失去了灵活使用内存的机会，也牺牲了一定的执行效率。
随着垃圾回收机制日益完善，可在大部分对性能要求不苛刻的场景中引入，利大于弊。
Python 也采用垃圾回收机制，代替程序员进行繁重的内存管理，提升开发效率
的同时，降低 bug 发生的几率。 Python 垃圾回收机制的关键是对象的
<strong>引用计数</strong> ，它决定了一个对象的生死。 我们知道每个 Python
对象都有一个 <strong>ob_refcnt</strong> 字段，记录着对象当前的引用计数。
当对象被其他地方引用时， ob_refcnt 加一； 当引用解除时， ob_refcnt
减一。 当 ob_refcnt 为零，说明对象已经没有任何引用了，这时便可将其回收。
Python 对象创建后，引用计数设为 1 ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 3.14</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<strong>这里引用计数为啥是 2 呢</strong>？ 对象
<strong>作为函数参数传递，需要将引用计数加一(重)，避免对象被提前销毁</strong>；函数返回时，再将引用计数减一。
因此，例子中 getrefcount 函数看到的对象引用计数为 2 。
接着，变量赋值让对象多了一个引用，这很好理解：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
将对象放在容器对象中，引用计数也增加了，符合预期：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l &#x3D; [a]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[3.14]</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
我们将 b 变量删除，引用计数减少了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del b</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
接着，将列表清空，引用计数进一步下降：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l.clear()</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
最后，将变量 a 删除后，引用计数降为 0 ，便不复存在了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del a</span><br></pre></td></tr></table></figure>
在 Python 中，很多场景都涉及引用计数的调整，例如： -
<strong>容器操作</strong>； - <strong>变量赋值</strong>； -
<strong>函数参数传递</strong>； - <strong>属性操作</strong>；</p>
<p>为此， Python 定义了两个非常重要的宏，用于维护对象应用计数。 其中，
Py_INCREF 将对象应用计数加一 ( 3 行)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define Py_INCREF(op) (                         \</span><br><span class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="line">    ((PyObject *)(op))-&gt;ob_refcnt++)</span><br></pre></td></tr></table></figure>
Py_DECREF 将引用计数减一 ( 5 行)，并在引用计数为 0 是回收对象 ( 8 行)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define Py_DECREF(op)                                   \</span><br><span class="line">    do &#123;                                                \</span><br><span class="line">        PyObject *_py_decref_tmp &#x3D; (PyObject *)(op);    \</span><br><span class="line">        if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="line">        --(_py_decref_tmp)-&gt;ob_refcnt !&#x3D; 0)             \</span><br><span class="line">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span><br><span class="line">        else</span><br><span class="line">            \\ 调用对象对应的析构函数销毁对象 </span><br><span class="line">            _Py_Dealloc(_py_decref_tmp);                \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure>
当一个对象引用计数为 0 ， Python
便调用对象对应的析构函数销毁对象，但这并不意味着对象内存一定会回收。
为了提高内存分配效率， Python 为一些
<strong>常用对象维护了内存池</strong>，
<strong>对象回收后内存进入内存池中</strong>，以便下次使用，由此
避免频繁申请、释放内存 。 内存池
技术作为程序开发的高级话题，需要更大的篇幅，放在后续章节中介绍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">[python源码分析] 1.对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-11 14:03:26" itemprop="dateCreated datePublished" datetime="2020-10-11T14:03:26+08:00">2020-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">python源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>面向对象理论中 <strong>“ 类 ”和“ 对象 ”</strong> 这两个重要概念，在
Python 内部均 <strong>以对象的形式存在</strong>。
<strong>“类”是一种对象</strong>，称为 <strong>类型对象</strong>
；“类”实例化生成的“对象”也是对象，称为 <strong>实例对象</strong> 。</p>
<p>根据对象不同特点还可进一步分类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>可变对象</td>
<td>对象创建后可以修改</td>
</tr>
<tr>
<td>不可变对象</td>
<td>对象创建后不能修改</td>
</tr>
<tr>
<td>定长对象</td>
<td>对象大小固定</td>
</tr>
<tr>
<td>变长对象</td>
<td>对象大小不固定</td>
</tr>
</tbody>
</table>
<p>那么，对象在 Python 内部到底长啥样呢？ 由于 Python 是由 C
语言实现的，因此 Python 对象在 C 语言层面应该是一个
<strong>结构体</strong> ，组织对象占用的内存。
不同类型的对象，数据及行为均可能不同，因此可以大胆猜测：<strong>不同类型的对象由不同的结构体表示</strong>。
对象也有一些共性，比如每个对象都需要有一个 <strong>引用计数 ，用于实现
垃圾回收机制</strong> 。 因此，还可以进一步猜测：表示对象的结构体有一个
<strong>公共头部</strong> 。</p>
<h2><span id="pyobject-dui-xiang-de-ji-shi">PyObject，对象的基石</span><a href="#pyobject-dui-xiang-de-ji-shi" class="header-anchor">#</a></h2>
<p>在 Python 内部，对象都由 <strong>PyObject 结构体</strong>表示，
对象引用则是指针 PyObject * 。 PyObject 结构体定义于头文件 object.h
，路径为 Include/object.h ，代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _object &#123;</span><br><span class="line">    _PyObject_HEAD_EXTRA   &#x2F;&#x2F;公共头部</span><br><span class="line">    Py_ssize_t ob_refcnt;  &#x2F;&#x2F;引用计数</span><br><span class="line">    struct _typeobject *ob_type;  &#x2F;&#x2F;类型指针</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
除了 _PyObject_HEAD_EXTRA 宏，结构体包含以下两个字段： - 引用计数 (
ob_refcnt ) - 类型指针 ( ob_type )</p>
<p><strong>引用计数</strong>
很好理解：对象被其他地方引用时加一，引用解除时减一；
当引用计数为零，便可将对象回收，这是最简单的垃圾回收机制。 类型指针
指向对象的 类型对象 ，类型对象 描述 实例对象 的数据及行为。</p>
<p>回过头来看 _PyObject_HEAD_EXTRA 宏的定义，同样在 Include/object.h
头文件内：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifdef Py_TRACE_REFS</span><br><span class="line">&#x2F;* Define pointers to support a doubly-linked list of all live heap objects. *&#x2F;</span><br><span class="line">#define _PyObject_HEAD_EXTRA            \</span><br><span class="line">    struct _object *_ob_next;           \</span><br><span class="line">    struct _object *_ob_prev;</span><br><span class="line"></span><br><span class="line">#define _PyObject_EXTRA_INIT 0, 0,</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">#define _PyObject_HEAD_EXTRA</span><br><span class="line">#define _PyObject_EXTRA_INIT</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>如果 <strong>Py_TRACE_REFS 有定义，宏展开为两个指针，看名字是用来实现
双向链表</strong> 的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct _object *_ob_next;</span><br><span class="line">struct _object *_ob_prev;</span><br></pre></td></tr></table></figure>
结合注释，双向链表用于 <strong>跟踪所有 活跃堆对象</strong>
，一般不启用，不深入介绍。 对于 变长对象 ，需要在 PyObject
基础上加入长度信息，这就是 <strong>PyVarObject</strong> ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; &#x2F;* Number of items in variable part *&#x2F;</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>
<strong>变长对象比普通对象多一个字段 ob_size
，用于记录元素个数</strong>：</p>
<table style="width:29%;">
<colgroup>
<col style="width: 29%">
</colgroup>
<tbody>
<tr>
<td>于具体对象，视其大小是否固定，需要包含头部 PyObject 或 PyVarObject
。 为此，头文件准备了两个宏定义，方便其他对象使用：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define PyObject_HEAD          PyObject ob_base;</span><br><span class="line">#define PyObject_VAR_HEAD      PyVarObject ob_base;</span><br></pre></td></tr></table></figure>
例如，对于大小固定的 浮点对象 ，只需在 PyObject 头部基础上， 用一个
双精度浮点数 double 加以实现：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD  &#x2F;&#x2F;浮点数是定长对象</span><br><span class="line"></span><br><span class="line">    double ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure></td>
</tr>
</tbody>
</table>
<div style="width:100%;margin:auto">
<img src="/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%AF%B9%E8%B1%A1/%5Bpython%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5D1.%E5%AF%B9%E8%B1%A12.png" class title="PyVarFloat图">
</div>
<table style="width:24%;">
<colgroup>
<col style="width: 23%">
</colgroup>
<thead>
<tr>
<th>而对于大小不固定的 列表对象 ，则需要在 PyVarObject 头部基础上，
用一个动态数组加以实现，数组存储列表包含的对象，即 PyObject 指针：</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如图， PyListObject 底层
<strong>由一个数组实现</strong>，关键字段是以下 3 个： ob_item ，指向
<strong>动态数组 的指针</strong>，数组保存元素对象指针； allocated
，<strong>动态数组总长度</strong>，即列表当前的 容量 ； ob_size
，<strong>当前元素个数</strong>，即列表当前的 长度 ；
列表容量不足时，<strong>Python 会自动扩容</strong>，具体做法在讲解 list
源码时再详细介绍。 最后，介绍两个用于初始化对象头部的宏定义。
其中，PyObject_HEAD_INIT 一般用于 定长对象 ，将<strong>引用计数
ob_refcnt 设置为 1 并将对象类型 ob_type 设置成给定类型</strong>：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PyObject_HEAD_INIT(type)        \</span><br><span class="line">    &#123; _PyObject_EXTRA_INIT              \</span><br><span class="line">    1, type &#125;,</span><br></pre></td></tr></table></figure>
PyVarObject_HEAD_INIT 在 PyObject_HEAD_INIT 基础上进一步设置 长度字段
ob_size ，一般用于 变长对象 ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define PyVarObject_HEAD_INIT(type, size)       \</span><br><span class="line">    &#123; PyObject_HEAD_INIT(type) size &#125;,</span><br></pre></td></tr></table></figure>
后续在研读源码过程中，将经常见到这两个宏定义。</p>
<h1><span id="pytypeobject-lei-xing-de-ji-shi">PyTypeObject，类型的基石</span><a href="#pytypeobject-lei-xing-de-ji-shi" class="header-anchor">#</a></h1>
<p>在 PyObject 结构体，我们看到了 Python 中所有对象共有的信息。
对于内存中的任一个对象，不管是何类型，它刚开始几个字段肯定符合我们的预期：
<strong>引用计数 、 类型指针 以及变长对象特有的 元素个数</strong> 。
随着研究不断深入，我们发现有一些棘手的问题没法回答：
不同类型的对象所需内存空间不同，创建对象时从哪得知内存信息呢？
对于给定对象，怎么判断它支持什么操作呢？ 对于我们初步解读过的
PyFloatObject 和 PyListObject ，并不包括这些信息。
事实上，这些作为对象的 <strong>元信息</strong>
，应该由一个独立实体保存，与对象所属 类型 密切相关。 注意到， PyObject
中包含一个指针 ob_type ，指向一个 类型对象 ，秘密就藏在这里。类型对象
<strong>PyTypeObject</strong> 也在 Include/object.h
中定义，字段较多，只讨论关键部分：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    const char *tp_name; &#x2F;* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; *&#x2F;</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; &#x2F;* For allocation *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Methods to implement standard operations *&#x2F;</span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line"></span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;* Attribute descriptor and subclassing stuff *&#x2F;</span><br><span class="line">    struct _typeobject *tp_base;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ......</span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>
可见 类型对象 PyTypeObject 是一个 <strong>变长对象</strong>
，包含变长对象头部。 专有字段有： - 类型名称 ，即 tp_name 字段； -
类型的继承信息，例如 tp_base 字段指向基类对象； - 创建实例对象时所需的
内存信息 ，即 tp_basicsize 和 tp_itemsize 字段； - 该类型支持的相关
操作信息 ，即 tp_print 、 tp_getattr 等函数指针；</p>
<p>PyTypeObject 就是 <strong>类型对象 在 Python
中的表现形式</strong>，对应着<strong>面向对象中“类”的概念</strong>。
PyTypeObject 结构很复杂，但是我们不必在此刻完全弄懂它。
先有个大概的印象，知道 PyTypeObject 保存着对象的 元信息 ，描述对象的
类型 即可。 接下来，以 浮点 为例，考察 类型对象 和 实例对象
在内存中的形态和关系：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; float</span><br><span class="line">&lt;class &#39;float&#39;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; pi &#x3D; 3.14</span><br><span class="line">&gt;&gt;&gt; e &#x3D; 2.71</span><br><span class="line">&gt;&gt;&gt; type(pi) is float</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
float 为
<strong>浮点类型对象，系统中只有唯一一个，保存了所有浮点实例对象的元信息</strong>。
而浮点实例对象就有很多了，圆周率 pi 是一个，自然对数 e
是另一个，当然还有其他。 代码中各个对象在内存的形式如下图所示：</p>
<p>其中，两个浮点 实例对象 都是 <strong>PyFloatObject 结构体</strong>，
除了公共头部字段 ob_refcnt 和 ob_type ，专有字段
<strong>ob_fval</strong> 保存了对应的数值。 浮点 类型对象 是一个
PyTypeObject 结构体， 保存了类型名、内存分配信息以及浮点相关操作。
实例对象 ob_type 字段指向类型对象， Python 据此判断对象类型，
进而获悉关于对象的元信息，如操作方法等。 再次提一遍，float 、 pi 以及 e
等变量只是一个指向实际对象的指针。 由于浮点 <strong>类型对象
全局唯一</strong>，在 C 语言层面
<strong>作为一个全局变量静态定义</strong>即可，Python 的确就这么做。
浮点类型对象就藏身于 Object/floatobject.c 中， PyFloat_Type 是也：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyFloat_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;float&quot;,</span><br><span class="line">    sizeof(PyFloatObject),</span><br><span class="line">    0,</span><br><span class="line">    (destructor)float_dealloc,                  &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    (reprfunc)float_repr,                       &#x2F;* tp_repr *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
其中，第 2 行初始化 ob_refcnt 、 ob_type 以及 ob_size 三个字段； 第 3
行将 tp_name 字段初始化成类型名称 float ；再往下是各种操作的函数指针。
注意到 ob_type 指针指向 PyType_Type ，这也是一个静态定义的全局变量。
由此可见，代表“ 类型的类型 ” 即 type 的那个对象应该就是 PyType_Type
了。</p>
<h1><span id="pytype-type-lei-xing-de-lei-xing">PyType_Type，类型的类型</span><a href="#pytype-type-lei-xing-de-lei-xing" class="header-anchor">#</a></h1>
<p>我们初步考察了 float 类型对象，知道它在 C 语言层面是 PyFloat_Type
全局静态变量。 类型是一种对象，它也有自己的类型，也就是 Python 中的 type
：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; float.__class__</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br></pre></td></tr></table></figure>
自定义类型也是如此：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Foo(object):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Foo.__class__</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br></pre></td></tr></table></figure>
那么， type 在 C 语言层面又长啥样呢？ 围观 PyFloat_Type 时，我们通过
ob_type 字段揪住了 <strong>PyType_Type</strong> 。 的确，它就是 type
的肉身。 PyType_Type 在 Object/typeobject.c 中定义（也是
<strong>重写PyTypeObject结构体</strong>）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyType_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;type&quot;,                                     &#x2F;* tp_name *&#x2F;</span><br><span class="line">    sizeof(PyHeapTypeObject),                   &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    sizeof(PyMemberDef),                        &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    (destructor)type_dealloc,                   &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    (reprfunc)type_repr,                        &#x2F;* tp_repr *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
内建类型和自定义类对应的 <strong>PyTypeObject</strong> 对象都是这个通过
PyType_Type 创建的。 PyType_Type 在 Python
的类型机制中是一个至关重要的对象，它是所有类型的类型，称为
<strong>元类型 ( meta class )。
借助元类型</strong>，你可以实现很多神奇的高级操作。 注意到，
<strong>PyType_Type 将自己的 ob_type 字段设置成它自己</strong>(第 2
行)，这跟我们在 Python 中看到的行为是吻合的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type.__class__</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type.__class__ is type</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
至此，元类型 type 在对象体系里的位置非常清晰了：</p>
<table style="width:8%;">
<colgroup>
<col style="width: 8%">
</colgroup>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h1><span id="pybaseobject-type-lei-xing-zhi-ji">PyBaseObject_Type，类型之基</span><a href="#pybaseobject-type-lei-xing-zhi-ji" class="header-anchor">#</a></h1>
<p>object 是另一个特殊的类型，它是 <strong>所有类型的基类</strong>。
那么，怎么找到它背后的实体呢？ 理论上，通过 PyFloat_Type 中 tp_base
字段顺藤摸瓜即可。 然而，我们发现这个字段在并没有初始化：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,                                          &#x2F;* tp_base *&#x2F;</span><br></pre></td></tr></table></figure>
这又是什么鬼？ 接着查找代码中 PyFloat_Type 出现的地方，我们在
Object/object.c 发现了蛛丝马迹：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (PyType_Ready(&amp;PyFloat_Type) &lt; 0)</span><br><span class="line">    Py_FatalError(&quot;Can&#39;t initialize float type&quot;);</span><br></pre></td></tr></table></figure>
敢情 PyFloat_Type 静态定义后还是个半成品呀！ PyType_Ready
对它做进一步加工，将 PyFloat_Type 中 tp_base 字段初始化成
PyBaseObject_Type ：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">PyType_Ready(PyTypeObject *type)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    base &#x3D; type-&gt;tp_base;</span><br><span class="line">    if (base &#x3D;&#x3D; NULL &amp;&amp; type !&#x3D; &amp;PyBaseObject_Type) &#123;</span><br><span class="line">        base &#x3D; type-&gt;tp_base &#x3D; &amp;PyBaseObject_Type;</span><br><span class="line">        Py_INCREF(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
PyBaseObject_Type 就是 PyTypeObject 背后的实体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyBaseObject_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;object&quot;,                                   &#x2F;* tp_name *&#x2F;</span><br><span class="line">    sizeof(PyObject),                           &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    object_dealloc,                             &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    object_repr,                                &#x2F;* tp_repr *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到， ob_type 字段指向 PyType_Type 跟 object 在 Python
中的行为时相吻合的：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; object.__class__</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br></pre></td></tr></table></figure>
又注意到 PyType_Ready 函数初始化 PyBaseObject_Type 时，不设置 tp_base
字段。
因为继承链必须有一个终点，不然对象沿着继承链进行属性查找时便陷入死循环。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(object.__base__)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
至此，我们完全弄清了 Python
对象体系中的所有实体以及关系，得到一幅完整的图画：</p>
<table style="width:8%;">
<colgroup>
<col style="width: 8%">
</colgroup>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>创建一个对象时, 先创建一个
<strong>类型对象PyTypeObject</strong>(类型对象自始至终都是
<strong>只要一个的, 在C源码中, 就是定义了一个全局的变量</strong>),
保存要创建对象的类型信息, 接着再在
<strong>该类型对象的方法中创建指定的对象</strong>, 并将类型对象
PyTypeObject 置为该对象的属性之一, 如创建一个int对象,
先在PyInt_Type对象创建封装了信息之后再创建PyIntObject对象。</p></li>
<li><p>Python相比较于其他语言的好处是
<strong>其doc文档就在程序之中</strong>,
通过<strong>PyTypeObject结构体中的doc属性</strong>可以看到。</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/18/unity-shader-2-GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/unity-shader-2-GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/" class="post-title-link" itemprop="url">[unity shader] 2.GPU渲染管线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-18 18:35:10" itemprop="dateCreated datePublished" datetime="2020-08-18T18:35:10+08:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="gpu-xuan-ran-guan-xian">GPU渲染管线</span><a href="#gpu-xuan-ran-guan-xian" class="header-anchor">#</a></h1>
<p>当GPU从CPU得到渲染命令后，就会进行一系列流水线操作，最终把图元渲染到屏幕上。</p>
<p>对于<strong>几何阶段和光栅化阶段</strong>，开发者无法拥有绝对的控制权，其实现的载体是GPU。GPU通过<strong>实现流水线化，大大加快了渲染速度</strong>。</p>
<p>几何阶段和光栅化阶段<strong>可以分成若干更小的流水线阶段</strong>，这些流水线阶段由GPU实现，每个阶段GPU提供了不同的可配置性或可编程性。</p>
<div style="width:100%;margin:auto">
<img src="/2020/08/18/unity-shader-2-GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.png" class title="GPU渲染管线图">
</div>
<p>从图中可以看出，GPU的渲染流水线接收顶点数据作为输入。这些顶点数据是由应用阶段加载到显存中，再由DrawCall指定的。这些数据随后被传递给顶点着色器。</p>
<h3><span id="1-ding-dian-zhao-se-qi-vertex-shader-wan-quan-ke-bian-cheng">1.顶点着色器（Vertex
Shader）：完全可编程</span><a href="#1-ding-dian-zhao-se-qi-vertex-shader-wan-quan-ke-bian-cheng" class="header-anchor">#</a></h3>
<p>通常用于实现顶点的空间变换、顶点着色等功能。</p>
<p>顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身并不会创建或者销毁顶点，而且无法得到顶点与顶点之间的关系。</p>
<p>例如：我们无法得知两个顶点是否属于一个三角网格。正因为这样的相互独立性，GPU可以利用本身的特性并行化处理每一个顶点。</p>
<p>顶点着色器需要完成的工作主要有：坐标变换和顶点光照。当然还可以输出后续阶段所需的数据。</p>
<h3><span id="2-cai-jian-clipping-ke-pei-zhi">2.裁剪（Clipping）：可配置</span><a href="#2-cai-jian-clipping-ke-pei-zhi" class="header-anchor">#</a></h3>
<p>这一阶段的目的是将那些不再摄像机视野内的顶点裁减掉，并剔除某些三角图元的面片。</p>
<p>目的：处理不在摄像机视野范围内的物体。</p>
<p>一个图元和摄像机视野有三种关系：完全在视野内、部分在视野内、完全在视野外。完全在视野内的图元即系传递给下一个流水线阶段，完全在视野外的图元就不会向下传递，因为不需要被渲染。而那些部分在视野内的图元就需要进行一个处理，那就是裁剪。</p>
<p>和顶点着色器不同，这一步是不可编程的。无法通过编程来控制裁剪的过程，是硬件上的固定操作</p>
<p>但是可以自定义一个剪裁操作来对这一步进行配置</p>
<h3><span id="3-ping-mu-ying-she-screen-mapping-bu-ke-pei-zhi-he-bian-cheng-de">3.屏幕映射（Screen
Mapping）：不可配置和编程的</span><a href="#3-ping-mu-ying-she-screen-mapping-bu-ke-pei-zhi-he-bian-cheng-de" class="header-anchor">#</a></h3>
<p>这一步输入的坐标仍然是三维坐标系下的坐标。</p>
<p>负责把每个图元的坐标转换到屏幕坐标系中。</p>
<h3><span id="4-san-jiao-xing-she-zhi-triangle-setup-he-san-jiao-xing-bian-liang-triangle-traversal-jie-duan-du-shi-gu-ding-han-shu-fixed-function-de-jie-duan">4.三角形设置（Triangle
Setup）和三角形变量（Triangle
Traversal）阶段都是固定函数（Fixed-Function）的阶段</span><a href="#4-san-jiao-xing-she-zhi-triangle-setup-he-san-jiao-xing-bian-liang-triangle-traversal-jie-duan-du-shi-gu-ding-han-shu-fixed-function-de-jie-duan" class="header-anchor">#</a></h3>
<p>这一阶段开始进入光栅化阶段。从上一个阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的额外信息，如：深度值（Z）、法线方向、视角方向等。</p>
<p>光栅化阶段有两个重要的目标：计算每个图元的覆盖了哪些像素，以及为这些像素计算颜色。</p>
<p>三角形设置：计算光栅化一个三角网格所需的信息。具体来讲，上一个阶段输出的都是三角网格的顶点，即我们得到的是三角网格每条边的两个顶点。但是如果要得到整个三角形网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个计算三角形网格表示数据的过程叫做三角形设置。</p>
<p>三角形遍历：检查每个像素是否被一个三角网格所覆盖。如果覆盖的话，就会生成一个片段（fragment）。这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换（Scan
Conversion）。</p>
<p>片段并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。</p>
<h3><span id="5-pian-duan-zhao-se-qi-fragment-shader-wan-quan-ke-bian-cheng">5.片段着色器（Fragment
Shader）：完全可编程</span><a href="#5-pian-duan-zhao-se-qi-fragment-shader-wan-quan-ke-bian-cheng" class="header-anchor">#</a></h3>
<p>用于实现逐片元（Per-Fragment）的着色操作。</p>
<p>片段着色器的输入是上一个阶段对顶点信息插值得到的结果，更具体来说，是根据那些从顶点着色器中输出的数据插值得到的。输出的是一个或者多个颜色值。</p>
<p>这一个阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样。为了在片段着色器中进行纹理采样，通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理进行插值后，就可以得到其覆盖的片段的纹理坐标了。</p>
<h3><span id="6-zhu-pian-yuan-cao-zuo-per-fragment-operations-bu-ke-bian-cheng-dan-ju-you-hen-gao-de-ke-pei-zhi-xing">6.逐片元操作（Per-Fragment
Operations）：不可编程，但具有很高的可配置性</span><a href="#6-zhu-pian-yuan-cao-zuo-per-fragment-operations-bu-ke-bian-cheng-dan-ju-you-hen-gao-de-ke-pei-zhi-xing" class="header-anchor">#</a></h3>
<p>负责执行很多重要的操作，例如：修改颜色、深度缓冲、进行混合等。</p>
<p>这一阶段OpenGL-逐片元操作 DirectX-输出合并阶段</p>
<p>这一阶段有几个重要的任务：</p>
<p>（1）
决定每个片元的可见性：这涉及了很多测试工作，例如：深度测试、模板测试</p>
<p>（2）
如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经储存在颜色缓冲区中的颜色进行合并，混合</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/18/unity-shader-graph-1-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/unity-shader-graph-1-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">[unity shader] 1.概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-18 15:23:32" itemprop="dateCreated datePublished" datetime="2020-08-18T15:23:32+08:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shader/" itemprop="url" rel="index"><span itemprop="name">shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="1-gai-shu">1. 概述</span><a href="#1-gai-shu" class="header-anchor">#</a></h1>
<div style="width:70%;margin:auto">
<img src="/2020/08/18/unity-shader-graph-1-%E6%A6%82%E8%BF%B0/Shader_sum_up.png" class title="shader概述图">
</div>
<h2><span id="1-1-shader-chong-lei">1.1 shader种类</span><a href="#1-1-shader-chong-lei" class="header-anchor">#</a></h2>
<p>shader主要有：<strong>固定管线着色器，顶点片元着色器，表面着色器</strong></p>
<ul>
<li>固定管线着色器（逐渐淘汰）</li>
<li>顶点shader：干预<strong>模型形态的shader（顶点变换）</strong></li>
<li>像素shader：干预<strong>像素着色的shader(不同纹理贴图）</strong></li>
</ul>
<h2><span id="1-2-gpu-bian-cheng-yu-yan">1.2 GPU编程语言</span><a href="#1-2-gpu-bian-cheng-yu-yan" class="header-anchor">#</a></h2>
<ol type="1">
<li><strong>Dirext3D-----微软（windows）</strong></li>
<li><strong>OpenGL-----Linux（Android）</strong></li>
</ol>
<p>目前面向GPU的编程有三种高级图像语言：<strong>HLSL语言，GLSL语言，Cg语言</strong>。</p>
<ol type="1">
<li><p>HLSL语言：High Level Shading
Language，由<strong>Microsoft公司提供，通过Direct3D图形软件库</strong>来编写的着色器语言。</p></li>
<li><p>GLSL语言：<strong>OpenGL Shading
Language，由OpenGL安委会提供</strong>，在OpenGL中进行着色器编程的语言。</p></li>
<li><p>Cg语言：C for
Graphics，由<strong>NVIDIA公司和Microsoft公司合作提供</strong>，有自己的一套关键字和函数库，独立于三维编程接口，<strong>在Direct3D和OpenGL上都可工作</strong>。</p></li>
</ol>
<h1><span id="2-shader-lab-ji-chu-yu-fa">2. shader lab基础语法</span><a href="#2-shader-lab-ji-chu-yu-fa" class="header-anchor">#</a></h1>
<h2><span id="2-1-shaderlab-jian-jie">2.1 ShaderLab简介</span><a href="#2-1-shaderlab-jian-jie" class="header-anchor">#</a></h2>
<p>ShaderLab: <strong>Unity
自己又封装了一层CG/HLSL/GLSL的接口</strong>，但为了实现跨平台，Unity<strong>重点支持Cg着色器语言</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shader &quot;主色器名称&quot;&#123;</span><br><span class="line">    Properties&#123;&#125; &#x2F;&#x2F;属性定义</span><br><span class="line">    SubShader&#123;&#125; &#x2F;&#x2F;子主色器</span><br><span class="line">    SubShader&#123;&#125; &#x2F;&#x2F;子主色器2</span><br><span class="line">    …………</span><br><span class="line">    FallBack &quot;备用着色器名称&quot; &#x2F;&#x2F;如果所有子着色器不能运行，则使用备用着色器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的shader示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; colored vertex lighting</span><br><span class="line">Shader &quot;Simple colored lighting&quot;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; a single color property</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Main Color&quot;, Color) &#x3D; (1,.5,.5,1)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; define one subshader</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; a single pass in our subshader</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; use fixed function per-vertex lighting</span><br><span class="line">            Material</span><br><span class="line">            &#123;</span><br><span class="line">                Diffuse [_Color]</span><br><span class="line">            &#125;</span><br><span class="line">            Lighting On</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Shader "name"{ }定义了一个名字为“name”的shader。</p>
<h3><span id="2-1-1-properties-shu-xing-ding-yi">2.1.1 properties属性定义</span><a href="#2-1-1-properties-shu-xing-ding-yi" class="header-anchor">#</a></h3>
<p>用来定义<strong>主色器中使用的贴图资源或者数值参数</strong>等。这些属性<strong>会在inspector视图的材质界面中显示</strong>，可以方便的进行设置和修改。</p>
<h3><span id="2-1-2-subshader-shu-xing-ding-yi">2.1.2 SubShader属性定义</span><a href="#2-1-2-subshader-shu-xing-ding-yi" class="header-anchor">#</a></h3>
<p>一个着色器<strong>包含一个或者多个子着色器</strong>。当Unity使用着色器渲染的时，会<strong>从上到下遍历子着色器，找到第一个被用户设备支持的子着色器</strong>，并<strong>使用该子着色器进行渲染</strong>。如果<strong>没有子着色器可以使用，则使用备用着色器</strong>。</p>
<h3><span id="2-1-3-fallback-shu-xing-ding-yi">2.1.3 Fallback属性定义</span><a href="#2-1-3-fallback-shu-xing-ding-yi" class="header-anchor">#</a></h3>
<p>备用着色器一般<strong>会指定一个对硬件要求最低的shader</strong>。当所有子着色器不能运行的时候，unity会启用备用着色器来进行渲染。</p>
<h2><span id="2-2-properties-shu-xing">2.2 Properties属性</span><a href="#2-2-properties-shu-xing" class="header-anchor">#</a></h2>
<p>properties一般定义<strong>在着色器的起始部分</strong>，我们可以在Shader书写的时候定义多种多样的属性，而使用Shader的时候可以直接在材质检视面板(Material
Inspector)里编辑这些属性，<strong>取不同的值或者纹理</strong>。这可以说是Unity贴心&amp;可见即所得的又一体现吧。</p>
<p>定义了一些属性参数，可在Unity编辑器的“Inspector”面板中编辑和调整。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_Name(&quot;Display Name&quot;, type) &#x3D; defaultValue[&#123;options&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Properties &#123;</span><br><span class="line">        _Color是变量名 (&quot;Main Color&quot;是在“Inspector”中的名字, Color是变量类型) &#x3D; (1,.5,.5,1)是默认值　 　　　　　　　　</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="2-2-1-properties-lei-xing">2.2.1 Properties 类型</span><a href="#2-2-1-properties-lei-xing" class="header-anchor">#</a></h3>
<p>类型|说明 -:-|-:- Range（min,max）| 在（min，max）范围内的浮点数
Float |浮点数 Int |整型 Color |颜色 RGBA Vector |四维向量 2D |2D纹理 3D
|3D纹理 Cube |立方体贴图纹理 Rect |矩形纹理</p>
<ul>
<li>**_Name**
属性的名字，简单说就是变量名，在之后<strong>整个Shader代码中将使用这个名字来获取该属性的内容</strong>。Unity中用下划线开始_Name</li>
<li><strong>Display Name</strong> -
这个字符串<strong>将显示在Unity的材质编辑器中作为Shader的使用者可读的内容</strong></li>
<li><strong>type</strong> -
这个属性的类型，可能的type所表示的内容有以下几种：
<ul>
<li>Color - 一种颜色，由RGBA（红绿蓝和透明度）四个量来定义；</li>
<li>2D -
一张2的阶数大小（256，512之类）的贴图。这张贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终被显示出来；</li>
<li>Rect - 一个非2阶数大小的贴图；</li>
<li>Cube - 即Cube map
texture（立方体纹理），简单说就是6张有联系的2D贴图的组合，主要用来做反射效果（比如天空盒和动态反射），也会被转换为对应点的采样；</li>
<li>Range(min, max) -
一个介于最小值和最大值之间的浮点数，一般用来当作调整Shader某些特性的参数（比如透明度渲染的截止值可以是从0至1的值等）；</li>
<li>Float - 任意一个浮点数；</li>
<li>Vector - 一个四维数；</li>
</ul></li>
<li><strong>defaultValue</strong>
定义了这个属性的默认值，通过输入一个符合格式的默认值来指定对应属性的初始值（某些效果可能需要某些特定的参数值来达到需要的效果，虽然这些值可以在之后在进行调整，但是如果默认就指定为想要的值的话就省去了一个个调整的时间，方便很多）。
<ul>
<li>Color - 以0～1定义的rgba颜色，比如(1,1,1,1)；</li>
<li>2D/Rect/Cube -
对于贴图来说，默认值可以为一个代表默认tint颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump”中的一个</li>
<li>Float，Range - 某个指定的浮点数</li>
<li>Vector - 一个4维数，写为 (x,y,z,w)</li>
</ul></li>
<li>另外还有一个{option}，它只对2D，Rect或者Cube贴图有关，在写输入时我们最少要在贴图之后写一对什么都不含的空白的{}，当我们需要打开特定选项时可以把其写在这对花括号内。如果需要同时打开多个选项，可以使用空白分隔。可能的选择有ObjectLinear,
EyeLinear, SphereMap, CubeReflect,
CubeNormal中的一个，这些都是OpenGL中TexGen的模式，</li>
</ul>
<h2><span id="2-3-subshader">2.3 SubShader</span><a href="#2-3-subshader" class="header-anchor">#</a></h2>
<h3><span id="2-3-1-ding-yi-yu-fa">2.3.1 定义语法</span><a href="#2-3-1-ding-yi-yu-fa" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Subshader &#123; </span><br><span class="line"> [Tags] </span><br><span class="line">   [CommonState] </span><br><span class="line">    Passdef [Passdef ...] &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-biao-qian-tags">2.3.2 标签（Tags）</span><a href="#2-3-2-biao-qian-tags" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;写在SubShader的第一句</span><br><span class="line">Tags &#123; &quot;TagName1&quot; &#x3D; &quot;Value1&quot; &quot;TagName2&quot; &#x3D; &quot;Value2&quot; &#125;</span><br><span class="line">&#x2F;&#x2F;比如</span><br><span class="line">Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125;</span><br></pre></td></tr></table></figure>
<h4><span id="zuo-yong">作用</span><a href="#zuo-yong" class="header-anchor">#</a></h4>
<p><strong>SubShaders使用标签来告诉引擎如何以及何时将其渲染。</strong></p>
<p><strong>Unity识别的以下标记必须在SubShader节内，而不是Pass！</strong></p>
<ol type="1">
<li><strong>“Queue”标签</strong>。定义<strong>渲染顺序</strong>-队列标签。预制的值为
（1）”Background”。值为1000。比如用于天空盒。
（2）”Geometry”。值为2000。大部分物体在这个队列。不透明的物体也在这里。这个队列内部的物体的渲染顺序会有进一步的优化（应该是从近到远，early-z
test可以剔除不需经过FS处理的片元）。其他队列的物体都是按空间位置的从远到近进行渲染。
（3）”AlphaTest”。值为2450。已进行AlphaTest的物体在这个队列。
（4）”Transparent”。值为3000。透明物体。
（5）”Overlay”。值为4000。比如镜头光晕。
（6）用户可以定义任意值，比如”Queue”=”Geometry+10”</li>
<li><strong>“RenderType”标签</strong>。Unity可以运行时<strong>替换符合特定RenderType的所有Shader</strong>。<strong>Camera.RenderWithShader或者Camera.SetReplacementShader配合使用</strong>。Unity内置的RenderType包括：
（1）”Opaque”：绝大部分<strong>不透明的物体都使用这个</strong>；
（2）”Transparent”：<strong>绝大部分透明的物体、包括粒子特效都使用这个</strong>；
（3）”Background”：<strong>天空盒都使用这个</strong>；
（4）”Overlay”：<strong>GUI、镜头光晕</strong>都使用这个；
（5）还有其他可参考Rendering with Replaced
Shaders；用户也可以定义任意自己的RenderType字符串。</li>
<li><strong>”ForceNoShadowCasting”，值为”true”时，表示不接受阴影</strong>。</li>
<li><strong>”IgnoreProjector”</strong>，值为”true”时，表示<strong>不接受Projector组件的投影</strong>。</li>
</ol>
<h3><span id="2-3-3-pass-tong-dao-cha-ru-dao-xuan-ran-liu-shui-xian-de-ding-yi-yu-fa">2.3.3
Pass(通道：插入到渲染流水线)的定义语法</span><a href="#2-3-3-pass-tong-dao-cha-ru-dao-xuan-ran-liu-shui-xian-de-ding-yi-yu-fa" class="header-anchor">#</a></h3>
<p><strong>subshader包装了一个渲染方案，这些方案由一个个通道（pass）来执行的，subshader可以包含很多通道块，每个Pass都能使几何体渲染一次</strong>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line"> [Name and Tags名称和标签]</span><br><span class="line">  [Render Setup 渲染设置]</span><br><span class="line">   [Texture setup 纹理设置]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例代码</span><br><span class="line">Shader &quot;Custom&#x2F;Shader_01&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Name &quot;ONE&quot;</span><br><span class="line">            Material&#123;</span><br><span class="line">                Diffuse(1,0.7,0.4,1)</span><br><span class="line">                Ambient(1,0.7,0.4,1)</span><br><span class="line">            &#125;</span><br><span class="line">            Lighting On</span><br><span class="line">            SetTexture[_]&#123; combine primary &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="2-3-4-pass-ming-cheng-he-biao-qian-name-and-tags">2.3.4 pass名称和标签（Name and
tags）</span><a href="#2-3-4-pass-ming-cheng-he-biao-qian-name-and-tags" class="header-anchor">#</a></h3>
<p>可以定义<strong>Pass的名字以及任意数量的标签</strong>。为Pass命名后，可以在<strong>别的着色器中通过Pass名称来引用它，减少重复操作</strong>。Name<strong>命名必须大写</strong></p>
<h3><span id="2-3-5-pass-xuan-ran-she-zhi-render-setup">2.3.5 pass渲染设置（Render
Setup）</span><a href="#2-3-5-pass-xuan-ran-she-zhi-render-setup" class="header-anchor">#</a></h3>
<p>pass里可以<strong>设置图形硬件的各种状态</strong>，例如<strong>开启Alpha混合，开启雾效</strong>等。</p>
<h4><span id="regularpass-xuan-ran-she-zhi">RegularPass渲染设置</span><a href="#regularpass-xuan-ran-she-zhi" class="header-anchor">#</a></h4>
<p>命令 |说明 -:-|-:- Meterial{} |材质，定义一个使用顶点光照管线的材质
Lighting |光照，设置光照，取值为off或on Cull
|裁剪，设置裁剪模式，模式包括：back、Front、off ZTest
|深度测试，设置深度测试，包括：Less、Greater、LEqual、GEqual、Equal、NotEqual、Always。
ZWrite |深度缓存写入，设置深度缓存写入的开关，取值为Off或On Fog{}
|雾效，设置雾效参数 AlphaTest
|<strong>Alpha测试</strong>，设置Alpha测试，包括：Less、Greater、LEqual、GEqual、Equal、NotEqual、Always。
Blend |Alpha混合，设置Alpha混合模式 Stencil|
蒙版，用蒙版来实现像素的取舍操作，选项有：keep、Zero、Replace、Incrsat、DecrSat、Invert、Incrwrap和DecrWrap
Color |颜色，是指顶点光照关闭时使用的颜色值 ColorMask
|颜色遮罩，设置<strong>颜色遮罩</strong>，当值为0时关闭所有的颜色通道的渲染，取值为RGB
offset |深度偏移，设置深度偏移 SeparateSpecular
|高光颜色。开启或关闭顶点光照的独立高光颜色，取值为On或Off ColorMaterial
|颜色集，当计算顶点光照时使用每个顶点的颜色。</p>
<h4><span id="te-shu-tong-dao">特殊通道</span><a href="#te-shu-tong-dao" class="header-anchor">#</a></h4>
<ol type="1">
<li><p><strong>UsePass 命令 使用 来自另一个着色器的命名通道</strong>。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**UsePass &quot;Shader&#x2F;Name&quot;**</span><br></pre></td></tr></table></figure>
插入<strong>所有来自给定着色器中的给定名字的通道</strong>。Shader/Name包含了<strong>通过斜杠字符分割的着色器的名字和通道的名字</strong>
某些着色器重用其他着色器中已存在的通道，减少重复的代码。例如，在许多像素光照着色器中，阴影色或顶点光照通道在在相应的顶点光照着色器中是相同的。UsePass命令只是包含了另一个着色器的给定通道。例如当如下的命令可以使用内置的高光着色器中的名叫"Base"的通道：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsePass &quot;Specular&#x2F;BASE&quot;</span><br></pre></td></tr></table></figure>
为了让UsePass能正常工作，必须给希望使用的通道命名。通道中的Name命令将提供这个名字：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name &quot;MyPassName&quot;</span><br></pre></td></tr></table></figure>
注意，所有通道名字都是大写开头，因此<strong>UsePass必须使用大写开头的名字来书写索引</strong>。</p></li>
<li><p>GrabPass是一种特殊的通道类型 -
<strong>捕获物体所在位置的屏幕的内容并写入到一个纹理中</strong>。这个纹理能<strong>被用于后续的通道中完成一些高级图像特效。</strong>
有两种方式将GrabPass放入一个 subshader中：</p></li>
</ol>
<ul>
<li>GrabPass {}
能<strong>捕获当前屏幕的内容到一个纹理中</strong>。纹理能在后续通道中通过
_GrabTexture
进行访问。注意：这种形式的捕获通道将在每一个使用该通道的对象渲染过程中执行昂贵的屏幕捕获操作</li>
<li>GrabPass { "TextureName" }
能捕获屏幕内容到一个纹理中，但只会在每帧中处理第一个使用给定纹理名的纹理的对象的渲染过程中产生捕获操作。纹理在未来的通道中可以通过给定的纹理名访问。当你在一个场景中拥有多个使用GrabPass的对象时将提高性能。</li>
</ul>
<p>GrabPass能使用<strong>Name 和 Tags命令。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;GrabPassInvert&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        &#x2F;&#x2F; Draw ourselves after all opaque geometry </span><br><span class="line">        &#x2F;&#x2F; 在所有不透明几何体之后自画</span><br><span class="line">        Tags &#123; &quot;Queue&quot; &#x3D; &quot;Transparent&quot; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Grab the screen behind the object into _GrabTexture</span><br><span class="line">        &#x2F;&#x2F; 捕获对象后的屏幕到_GrabTexture</span><br><span class="line">        GrabPass &#123; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Render the object with the texture generated above, and invert it&#39;s colors</span><br><span class="line">        &#x2F;&#x2F; 用前面捕获的纹理渲染对象，并反相它的颜色</span><br><span class="line">        Pass &#123;</span><br><span class="line">            SetTexture [_GrabTexture] &#123; combine one-texture &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-6-pass-wen-li-she-zhi-texture-setup">2.3.6 pass纹理设置（Texture
Setup）</span><a href="#2-3-6-pass-wen-li-she-zhi-texture-setup" class="header-anchor">#</a></h3>
<p>纹理设置语法：<strong>setTexture 纹理属性{[命令选项}</strong>
纹理设置用于<strong>固定功能管线</strong>，如果<strong>使用表面着色器或者自定义的顶点或者片段着色器，那么纹理设置将会被忽略</strong>。
setTexture的命令选项包括三种： 1.
<strong>Conbine</strong>:将两个颜色源混合，混合源可以是previous（上一次setTexture的结果）、constant（常量颜色值）、primary（顶点颜色）和texture（纹理颜色中的一种）
2. <strong>ConstantColor设置一个颜色常量</strong> 3.
<strong>matrix:设置矩阵对纹理坐标进行变换</strong></p>
<h2><span id="2-4-fallback-bei-yong-zhao-se-qi">2.4 Fallback备用着色器</span><a href="#2-4-fallback-bei-yong-zhao-se-qi" class="header-anchor">#</a></h2>
<h3><span id="yu-fa">语法：</span><a href="#yu-fa" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）Fallback “备用着色器名称”</span><br><span class="line">（2）Fallback off</span><br></pre></td></tr></table></figure>
<h2><span id="2-5-unity-nei-zhi-surface-shader-guan-zhao-xiao-guo-ji-suan-de-xing-neng-kai-xiao-pai-xu">2.5
unity内置Surface shader关照效果计算的性能开销排序</span><a href="#2-5-unity-nei-zhi-surface-shader-guan-zhao-xiao-guo-ji-suan-de-xing-neng-kai-xiao-pai-xu" class="header-anchor">#</a></h2>
<ol type="1">
<li>Unlit:仅适用<strong>纹理颜色，不受光照影响</strong></li>
<li>VertexLit:顶点光照</li>
<li>Diffuse：漫反射</li>
<li>Specular：在满反射的基础上增加了高光计算</li>
<li>Normal Mapped：法线贴图，增加了一张法线贴图和几个着色器指令</li>
<li>Normal Mapped Specular：<strong>带高光的法线贴图</strong></li>
<li>Parallax Normal
Mapped：<strong>视差法线贴图</strong>，增加了视察贴图的计算开销。</li>
<li>Parallax Normal Mapped
Specular：<strong>带高光的视差法线贴图</strong></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/15/c-c-%E4%B8%AD%E7%9A%84Lazy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liu Wen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuWen's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/15/c-c-%E4%B8%AD%E7%9A%84Lazy/" class="post-title-link" itemprop="url">[c#]c#中的Lazy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-15 13:20:18" itemprop="dateCreated datePublished" datetime="2020-08-15T13:20:18+08:00">2020-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-13 11:36:19" itemprop="dateModified" datetime="2024-10-13T11:36:19+08:00">2024-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2><span id="xian-cheng-an-quan-dan-li-zui-jia-shi-jian-c-zhong-de-lazy-shi-ru-he-bao-zheng-xian-cheng-an-quan-de">线程安全单例最佳实践，C#中的Lazy是如何保证线程安全的</span><a href="#xian-cheng-an-quan-dan-li-zui-jia-shi-jian-c-zhong-de-lazy-shi-ru-he-bao-zheng-xian-cheng-an-quan-de" class="header-anchor">#</a></h2>
<p>在.NET 4.0之后，.NET
Framework中提供了一种<strong>安全的延迟加载类型Lazy</strong>。Lazy能够<strong>在多线程环境下，保证GetValue函数只执行一次</strong>，从而实现单例模式。</p>
<p>在过去，实现单例模式我们通常使用二次判断锁，或者利用类的静态初始化函数利用Lazy类型，能够简化这一过程，并且性能上更好。</p>
<p>Lazy创建的时候可以指定线程安装模式，目前有两种模式，<strong>PublicationOnly，ExcutionAndPublication。</strong></p>
<p><strong>延迟初始化，在第一次使用该对象时再对其进行初始化，如果没有用到则不需要进行初始化,这样的话，使用延迟初始化就提高程序的效率，从而使程序占用更少的内存。</strong></p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%">
</colgroup>
<tbody>
<tr>
<td>#### PublicationOnly模式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boxed &#x3D; CreateValue(); &#x2F;&#x2F;1</span><br><span class="line">if (boxed &#x3D;&#x3D; null ||</span><br><span class="line">  &#x2F;&#x2F;比较m_boxed与null，如果不相等，什么都不做；如果m_boxed与null相等，则用boxed替换m_boxed的值。</span><br><span class="line">   &#x2F;&#x2F;无论比较结果相等与否，返回值都是m_boxed中原有的值。</span><br><span class="line">    Interlocked.CompareExchange(ref m_boxed, boxed, null) !&#x3D; null) &#x2F;&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line">    boxed &#x3D; (Boxed)m_boxed; &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    m_valueFactory &#x3D; ALREADY_INVOKED_SENTINEL; &#x2F;&#x2F;4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr>
<td>1.
运行<strong>初始化函数，装箱到一个内部Box类型中，解决null值判断的问题</strong>，如果已经创建的情况，会返回null，该过程是线程不安全的</td>
</tr>
<tr>
<td>2.
判断m_boxed是否为空，m_boxed是value保存的字段，如果等于空则设置为boxed，该方法能保证原子性，该过程是线程安全的</td>
</tr>
<tr>
<td>3.
如果<strong>CreateValue返回空，表示其他线程已经创建有实例，则设置为已经创建好的实例</strong></td>
</tr>
<tr>
<td>4.
将初始化方法标记为已经初始化，一般发生在并发运行情况下，多次运行CreateValue</td>
</tr>
<tr>
<td><strong>PublicationOnly模式下使用基于Interlocked.CompareExchange（原子性运算）实现的乐观锁</strong>，该类包含了原子性方法
CAS(Compare and swap)</td>
</tr>
<tr>
<td><strong>CAS</strong>是利用CPU提供的原子性指令来实现，不同运行时版本可能有不一样实现。Interlocked具体的实现在Native方法中，有兴趣的朋友可以通过coreclr/jvm代码查看具体实现</td>
</tr>
<tr>
<td>这种模式下，单例函数可能多次运行，但是最终能保证获取到的实例只有一个</td>
</tr>
</tbody>
</table>
<h4><span id="excutionandpublication-mo-shi">ExcutionAndPublication模式</span><a href="#excutionandpublication-mo-shi" class="header-anchor">#</a></h4>
<p><strong>ExcutionAndPublication模式下使用的是Volatile+Monitor</strong>，Monitor就是lock语句的实现，Monitor实现在Native代码中，是重量级的锁</p>
<p>Monitor支持<strong>队列和线程睡眠</strong>，能够保证一<strong>整个方法块处于单线程执行状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">object threadSafeObj &#x3D; Volatile.Read(ref m_threadSafeObj); &#x2F;&#x2F;强制从主内存空间同步变量到线程内存空间副本</span><br><span class="line">bool lockTaken &#x3D; false;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    if (threadSafeObj !&#x3D; (object)ALREADY_INVOKED_SENTINEL) &#x2F;&#x2F;此时会有多个线程获取到正确值，抢夺开始</span><br><span class="line">        Monitor.Enter(threadSafeObj, ref lockTaken); &#x2F;&#x2F;尝试等待锁，进入成功设置lockTaken为true</span><br><span class="line">    else</span><br><span class="line">        Contract.Assert(m_boxed !&#x3D; null);</span><br><span class="line">　　　　　　　　　　　 &#x2F;&#x2F;单线程代码块 Start</span><br><span class="line">    if (m_boxed &#x3D;&#x3D; null) &#x2F;&#x2F;没有设置值的情况</span><br><span class="line">    &#123;</span><br><span class="line">        boxed &#x3D; CreateValue(); &#x2F;&#x2F;获取值</span><br><span class="line">        m_boxed &#x3D; boxed; &#x2F;&#x2F;设置到字段中</span><br><span class="line">        Volatile.Write(ref m_threadSafeObj, ALREADY_INVOKED_SENTINEL); &#x2F;&#x2F;强制将线程内存空间副本写入到主内存空间</span><br><span class="line">    &#125;</span><br><span class="line">    else &#x2F;&#x2F; got the lock but the value is not null anymore, check if it is created by another thread or faulted and throw if so</span><br><span class="line">    &#123;</span><br><span class="line">        boxed &#x3D; m_boxed as Boxed;</span><br><span class="line">        if (boxed &#x3D;&#x3D; null) &#x2F;&#x2F; it is not Boxed, so it is a LazyInternalExceptionHolder</span><br><span class="line">        &#123;</span><br><span class="line">            LazyInternalExceptionHolder exHolder &#x3D; m_boxed as LazyInternalExceptionHolder;</span><br><span class="line">            Contract.Assert(exHolder !&#x3D; null);</span><br><span class="line">            exHolder.m_edi.Throw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">　　　　　　　　　　　　&#x2F;&#x2F;单线程代码块End</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    if (lockTaken) &#x2F;&#x2F;进入成功需要释放，避免死锁</span><br><span class="line">        Monitor.Exit(threadSafeObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liu Wen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sysuleo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sysuleo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/leo666-40" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;leo666-40" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>zhihu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Wen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  


</body>
</html>
