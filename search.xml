<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Markdown]进阶用法</title>
    <url>/2024/01/30/Markdown-%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>记录最近用到的一些markdown进阶用法备忘 <a id="more"></a></p>
<h1><span id="mu-lu">目录</span><a href="#mu-lu" class="header-anchor">#</a></h1>
<ul>
<li><p>TOC自动生成，但markdown导html后打印pdf不友好
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用<a href="https://ecotrust-canada.github.io/markdown-toc/">GitHub目录自动生成工具</a>生成目录</p></li>
</ul>
<h1><span id="ye-mian-guan-li">页面管理</span><a href="#ye-mian-guan-li" class="header-anchor">#</a></h1>
<ul>
<li>转pdf的分页符
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div STYLE&#x3D;&quot;page-break-after: always;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1><span id="zi-ti">字体</span><a href="#zi-ti" class="header-anchor">#</a></h1>
<h2><span id="da-xiao-yan-se-zi-ti">大小、颜色、字体</span><a href="#da-xiao-yan-se-zi-ti" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;red&gt;我是红色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;#008000&gt;我是绿色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;Blue&gt;我是蓝色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font size&#x3D;5&gt;我是尺寸&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;黑体&quot; color&#x3D;green size&#x3D;5&gt;我是黑体，绿色，尺寸为5&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>
<p><font face="黑体">我是黑体字</font>
<font face="微软雅黑">我是微软雅黑</font>
<font face="STCAIYUN">我是华文彩云</font>
<font color="red">我是红色</font> <font color="#008000">我是绿色</font>
<font color="Blue">我是蓝色</font> <font size="5">我是尺寸</font>
<font face="黑体" color="green" size="5">我是黑体，绿色，尺寸为5</font></p>
<h2><span id="bei-jing-se">背景色</span><a href="#bei-jing-se" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;yellow&gt;背景色yellow&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>
<table>
<tr>
<td bgcolor="yellow">
背景色yellow
</td>
</tr>
</table>
<h1><span id="tu-pian">图片</span><a href="#tu-pian" class="header-anchor">#</a></h1>
<h2><span id="she-zhi-tu-pian-da-xiao">设置图片大小</span><a href="#she-zhi-tu-pian-da-xiao" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;xxx  url&quot; width&#x3D;&quot;350&quot; height&#x3D;&quot;350&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>或
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![test image size](url)&#123;:class&#x3D;&quot;img-responsive&quot;&#125;</span><br><span class="line">![test image size](url)&#123;:height&#x3D;&quot;50%&quot; width&#x3D;&quot;50%&quot;&#125;</span><br><span class="line">![test image size](url)&#123;:height&#x3D;&quot;100px&quot; width&#x3D;&quot;400px&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="tu-pian-wei-zhi-she-zhi">图片位置设置</span><a href="#tu-pian-wei-zhi-she-zhi" class="header-anchor">#</a></h2>
<ul>
<li>align: right、left、middle
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div align&#x3D;middle&gt;&lt;img src&#x3D;&quot;xxx url&quot; width&#x3D;&quot;350&quot; height&#x3D;&quot;350&quot; &gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1><span id="biao-ge">表格</span><a href="#biao-ge" class="header-anchor">#</a></h1>
<ul>
<li>指定列宽
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width: 180pt&quot;&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| &lt;div style&#x3D;&quot;width: 180pt&quot;&gt; | &lt;div style&#x3D;&quot;width: 88pt&quot;&gt;full rpc | &lt;div style&#x3D;&quot;width: 88pt&quot;&gt;partial rpc | &lt;div style&#x3D;&quot;width: 88pt&quot;&gt;优化占比 |</span><br><span class="line">| :-: | :-: | :-: | :-: | </span><br><span class="line">| 15048 **ncalls** | 1999 | 1598 | 44.42% |</span><br></pre></td></tr></table></figure>
<h1><span id="plantuml-hua-tu">plantuml画图</span><a href="#plantuml-hua-tu" class="header-anchor">#</a></h1>
<p>参考连接<a href="http://liuw.tech/2022/11/05/vscode-markdown-plantuml%E7%94%BB%E5%9B%BE/#more">[vscode]markdown+plantuml画图</a></p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<ol type="1">
<li><a href="https://markdown.com.cn/basic-syntax/">Markdown
基本语法</a></li>
<li><a href="https://ecotrust-canada.github.io/markdown-toc/">GitHub目录自动生成工具</a></li>
<li><a href="http://liuw.tech/2022/11/05/vscode-markdown-plantuml%E7%94%BB%E5%9B%BE/#more">[vscode]markdown+plantuml画图</a></li>
</ol>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>[CSAPP]汇编篇 1.分段机制与GDT|LDT</title>
    <url>/2021/06/29/CSAPP-%E6%B1%87%E7%BC%96%E7%AF%87-1-%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E4%B8%8EGDT-LDT/</url>
    <content><![CDATA[<h2><span id="fen-duan-ji-zhi">分段机制</span><a href="#fen-duan-ji-zhi" class="header-anchor">#</a></h2>
<p>在32位系统中, 每个进程都认为拥有了2^32
的内存空间。其实这是一种假象,实际上操作系统内核一般占据2GB，剩余的2GB由用户空间的进程共享。其实,操作系统有种
保护方式，就是<strong>段</strong>，使程序能拥有独立的内存空间,又认为占据了4GB空间。
<a id="more"></a>
段的特征有以下三个：<strong>段基址（base，长度32位），段限长（单位为2^12即4k，长度为20位），段属性(访问属性，12位)</strong>。
这三个特征存储在<strong>段描述符（segmentdescriptor）</strong>之中。</p>
<h3><span id="quan-ju-miao-shu-fu-biao-gdt">全局描述符表GDT</span><a href="#quan-ju-miao-shu-fu-biao-gdt" class="header-anchor">#</a></h3>
<p>在整个系统中，<strong>全局描述符表GDT只有一张</strong>(一个cpu对应一个GDT)，GDT可以被放在<strong>内存的任何位置</strong>，但CPU必须知道GDT的入口，也就是基地址在哪。Intel的设计者提供了一个<strong>寄存器GDTR用来存放GDT的入口地址</strong>，程序员将GDT设定在内存中某个位置之后，可以通过<strong>LGDT指令</strong>将<strong>GDT的入口地址装入此寄存器</strong>，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的<strong>基地址和其表长界限</strong>。</p>
<p>指令<strong>LGDT和SGDT</strong>分别用于<strong>加载和保存GDTR寄存器</strong>的内容。</p>
<h3><span id="duan-xuan-ze-zi">段选择子</span><a href="#duan-xuan-ze-zi" class="header-anchor">#</a></h3>
<p>由GDTR访问全局描述符表是通过“段选择子”（实模式下的段寄存器）来完成的。段选择子是一个16位的寄存器（同实模式下的段寄存器相同）</p>
<h2><span id="need-to-do-later">NEED TO DO LATER</span><a href="#need-to-do-later" class="header-anchor">#</a></h2>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>[Protobuf&amp;gRPC] 2.gRPC简介</title>
    <url>/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2><span id="rpc-kuang-jia-yuan-li">RPC 框架原理</span><a href="#rpc-kuang-jia-yuan-li" class="header-anchor">#</a></h2>
<p>RPC 框架的目标就是让远程服务调用更加简单、透明，RPC
框架负责<strong>屏蔽底层的传输方式（TCP 或者
UDP）、序列化方式（XML/Json/
二进制）和通信细节</strong>。服务<strong>调用者可以像调用本地接口一样调用远程的服务提供者</strong>，而不需要关心底层通信细节和调用过程。</p>
<div style="width:90%;margin:auto">
<img src="/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/rpc%E7%AE%80%E4%BB%8B.png" class title="rpc简介图">
</div>
<p>业界主流的 RPC 框架整体上分为三类：</p>
<ul>
<li>支持多语言的 RPC 框架，比较成熟的有 <strong>Google 的
gRPC、Apache（Facebook）的 Thrift</strong>；</li>
<li>只支持<strong>特定语言的 RPC 框架</strong>，例如新浪微博的
<strong>Motan</strong>；</li>
<li>支持<strong>服务治理等服务化特性的分布式服务框架</strong>，其底层内核仍然是
RPC 框架, 例如阿里的 Dubbo。</li>
</ul>
<h2><span id="grpc-jian-jie">gRPC 简介</span><a href="#grpc-jian-jie" class="header-anchor">#</a></h2>
<p>gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端，基于
HTTP/2 设计。</p>
<div style="width:90%;margin:auto">
<img src="/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/grpc%E7%AE%80%E4%BB%8B.png" class title="grpc简介图">
</div>
<p>gRPC 客户端和服务端<strong>可以在多种环境中运行和交互</strong> - 从
google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC
支持的语言来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用
Go、Python、Ruby 来创建客户端。此外，<strong>Google 最新 API 将有 gRPC
版本的接口</strong>，使你很容易地将 Google 的功能集成到你的应用里。</p>
<p>gRPC 特点 - 语言中立，支持多种语言； - 基于 IDL 文件定义服务，通过
proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub； -
通信协议基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单 TCP
的多路复用、服务端推送等特性，这些特性使得 gRPC
在移动端设备上更加省电和节省网络流量； - 序列化支持 PB（Protocol
Buffer）和 JSON，PB 是一种语言无关的高性能序列化框架，基于 HTTP/2 + PB,
保障了 RPC 调用的高性能。</p>
<h2><span id="grpc-you-shi-me-hao-chu-yi-ji-zai-shi-me-chang-jing-xia-xu-yao-yong-grpc">gRPC有什么好处以及在什么场景下需要用gRPC</span><a href="#grpc-you-shi-me-hao-chu-yi-ji-zai-shi-me-chang-jing-xia-xu-yao-yong-grpc" class="header-anchor">#</a></h2>
<p>gRPC vs. Restful API gRPC和restful
API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说,
gRPC使用的http2.0，而restful
api则不一定)。不过gRPC还是有些特有的优势，如下：</p>
<ul>
<li>gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。</li>
<li>通过protobuf可以将数据<strong>序列化为二进制编码</strong>，这会<strong>大幅减少需要传输的数据量，从而大幅提高性能</strong>。</li>
<li>gRPC可以方便地<strong>支持流式通信</strong>(理论上通过http2.0就可以使用streaming模式,
但是通常web服务的restful
api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）</li>
<li>proto文件生成目标代码，简单易用</li>
<li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li>
<li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li>
<li>Netty等一些框架集成</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、GRPC尚未提供连接池，需要自行实现</li>
<li>2、尚未提供“服务发现”、“负载均衡”机制</li>
<li>3、因为基于HTTP2，绝大部多数HTTP
Server、Nginx都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求。（nginx1.9版本已支持）</li>
<li>4、Protobuf二进制可读性差（貌似提供了Text_Fromat功能）</li>
<li>5、默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
</ul>
<h3><span id="shi-yong-protocol-buffers">使用 protocol buffers</span><a href="#shi-yong-protocol-buffers" class="header-anchor">#</a></h3>
<p>gRPC 默认使用 protocol buffers（protobuf），这是 Google
开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如
JSON）。正如你将在下方例子里所看到的，你用 proto files 创建 gRPC
服务，用 protobuf 消息类型来定义方法参数和返回类型。protobuf相关可以看
<a href="http://liuw.tech/2020/10/17/Protobuf-gRPC-1-protobuf%E7%AE%80%E4%BB%8B/" title="[Protobuf&amp;gRPC] 1.protobuf简介">protobuf简介</a></p>
<h3><span id="ji-yu-http-2-0-biao-zhun-she-ji">基于HTTP 2.0标准设计</span><a href="#ji-yu-http-2-0-biao-zhun-she-ji" class="header-anchor">#</a></h3>
<p>由于gRPC<strong>基于HTTP
2.0</strong>标准设计，带来了更多强大功能，如<strong>多路复用、二进制帧、头部压缩、推送机制</strong>。这些功能给设备带来重大益处，如<strong>节省带宽、降低TCP连接次数、节省CPU使用</strong>等。gRPC既能够在客户端应用，也能够在服务器端应用，从而<strong>以透明的方式实现两端的通信和简化通信系统的构建</strong>。</p>
<p>HTTP 版本分为HTTP 1.X、 HTTP 2.0，其中HTTP
1.X是当前使用最广泛的HTTP协议，<strong>HTTP
2.0称为超文本传输协议第二代</strong>。HTTP
1.X定义了四种与服务器交互的方式，分别为：<strong>GET、POST、PUT、DELETE</strong>，这些在HTTP
2.0中均保留。我们再来看看HTTP 2.0的新特性：</p>
<h4><span id="1-shuang-xiang-liu-duo-lu-fu-yong">1.双向流、多路复用</span><a href="#1-shuang-xiang-liu-duo-lu-fu-yong" class="header-anchor">#</a></h4>
<p>在HTTP
1.X协议中，客户端在同一时间访问同一域名的请求数量是有限制的，当超过阈值时请求会被阻断，但是这种情况在HTTP
2.0中将被忽略。由于HTTP 1.X传输的是纯文本数据，传输体积较大，而HTTP
2.0传输的基本单元为帧，每个帧都包含消息，并且由于HTTP
2.0允许同时通过一条连接发起多个“请求-响应”消息，无需建立多个TCP链接的同时实现多条流并行，提高吞吐性能，并且在一个连接内对多个消息进行优先级的管理和流控。</p>
<h4><span id="2-er-jin-zhi-zheng">2.二进制帧</span><a href="#2-er-jin-zhi-zheng" class="header-anchor">#</a></h4>
<p>相对于<strong>HTTP 1.X的纯文本传输</strong>，HTTP
2.0传输的是<strong>二进制数据</strong>，与Protocol
Buffers相辅相成。使得<strong>传输数据体积小、负载低</strong>，保持<strong>更加紧凑和高效</strong>。</p>
<h4><span id="3-tou-bu-ya-suo">3.头部压缩</span><a href="#3-tou-bu-ya-suo" class="header-anchor">#</a></h4>
<p>因为HTTP是<strong>无状态协议</strong>，对于业务的处理没有记忆能力，每一次请求都需要携带设备的所有细节，特别是<strong>在头部都会包含大量的重复数据</strong>，对于设备来说就是在不断地做无意义的重复性工作。HTTP
2.0中<strong>使用“头表”来跟踪之前发送的数据</strong>，对于<strong>相同的数据将不再使用重复请求和发送</strong>，进而<strong>减少数据的体积</strong>。</p>
<hr>
<h2><span id="grpc-you-si-chong-tong-xin-fang-shi">gRPC有四种通信方式:</span><a href="#grpc-you-si-chong-tong-xin-fang-shi" class="header-anchor">#</a></h2>
<h3><span id="1-simple-rpc">1、 Simple RPC</span><a href="#1-simple-rpc" class="header-anchor">#</a></h3>
<p>简单rpc 这就是一般的rpc调用，一个请求对象对应一个返回对象 proto语法：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpc simpleHello(Person) returns (Result) &#123;&#125;</span><br></pre></td></tr></table></figure>
### 2、 Server-side streaming RPC 服务端流式rpc
一个请求对象，服务端可以传回多个结果对象 proto语法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpc serverStreamHello(Person) returns (stream Result) &#123;&#125;</span><br></pre></td></tr></table></figure>
### 3、 Client-side streaming RPC 客户端流式rpc
客户端传入多个请求对象，服务端返回一个响应结果 proto语法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpc clientStreamHello(stream Person) returns (Result) &#123;&#125;</span><br></pre></td></tr></table></figure>
### 4、 Bidirectional streaming RPC 双向流式rpc
结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象
proto语法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpc biStreamHello(stream Person) returns (stream Result) &#123;&#125;</span><br></pre></td></tr></table></figure>
--- ## 服务端创建流程 gRPC 服务端创建采用 <strong>Build
模式</strong>，对<strong>底层服务绑定、transportServer 和 NettyServer
的创建和实例化</strong>做了<strong>封装和屏蔽</strong>，让服务调用者不用关心
RPC 调用细节，整体上分为三个过程：</p>
<ul>
<li>创建 Netty HTTP/2 服务端；</li>
<li>将需要调用的服务端接口实现类注册到内部的 Registry 中，RPC
调用时，可以根据 RPC 请求消息中的服务定义信息查询到服务接口实现类；</li>
<li>创建 gRPC Server，它是 gRPC 服务端的抽象，聚合了各种 Listener，用于
RPC 消息的统一调度和处理。</li>
</ul>
<div style="width:90%;margin:auto">
<img src="/2020/10/18/Protobuf-gRPC-2-gRPC%E7%AE%80%E4%BB%8B/grpc%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA.png" class title="grpc服务端创建图">
</div>
<h2><span id="grpc-fu-wu-duan-chuang-jian-guan-jian-liu-cheng-fen-xi">gRPC 服务端创建关键流程分析：</span><a href="#grpc-fu-wu-duan-chuang-jian-guan-jian-liu-cheng-fen-xi" class="header-anchor">#</a></h2>
<ul>
<li>NettyServer 实例创建：gRPC 服务端创建，首先需要<strong>初始化
NettyServer</strong>，它是 gRPC 基于 <strong>Netty 4.1 HTTP/2
协议栈之上封装的 HTTP/2 服务端</strong>。NettyServer 实例<strong>由
NettyServerBuilder 的 buildTransportServer
方法构建</strong>，NettyServer 构建完成之后，<strong>监听指定的 Socket
地址，即可实现基于 HTTP/2 协议的请求消息接入</strong>。</li>
<li>绑定 IDL 定义的服务接口实现类：gRPC 与其它一些 RPC
框架的差异点是<strong>服务接口实现类的调用并不是通过动态代理和反射机制</strong>，而是通过
<strong>proto 工具生成代码，在服务端启动时，将服务接口实现类实例注册到
gRPC
内部的服务注册中心上</strong>。请求消息接入之后，可以<strong>根据服务名和方法名，直接调用启动时注册的服务实例</strong>，而不需要通过反射的方式进行调用，性能更优。</li>
<li>gRPC 服务实例（ServerImpl）构建：<strong>ServerImpl 负责整个 gRPC
服务端消息的调度和处理</strong>，创建 ServerImpl
实例过程中，会<strong>对服务端依赖的对象进行初始化</strong>，例如
<strong>Netty 的线程池资源、gRPC
的线程池、内部的服务注册类（InternalHandlerRegistry）</strong>等，ServerImpl
初始化完成之后，就可以<strong>调用 NettyServer 的 start 方法启动 HTTP/2
服务端</strong>，接收 gRPC 客户端的服务调用请求</li>
</ul>
<h2><span id="grpc-helloworld-shi-li-xiang-jie">gRPC HelloWorld实例详解</span><a href="#grpc-helloworld-shi-li-xiang-jie" class="header-anchor">#</a></h2>
<p>gRPC的使用通常包括如下几个步骤：</p>
<ol type="1">
<li>通过protobuf来定义接口和数据类型</li>
<li>使用gRPC protobuf生成工具生成对应语言的库函数</li>
<li>编写gRPC server端代码</li>
<li>编写gRPC client端代码 下面来通过一个实例来详细讲解上述的三步。
下边的hello world实例完成之后，其目录结果如下：</li>
</ol>
<h3><span id="1-ding-yi-jie-kou-he-shu-ju-lei-xing">1. 定义接口和数据类型</span><a href="#1-ding-yi-jie-kou-he-shu-ju-lei-xing" class="header-anchor">#</a></h3>
<p>通过protobuf定义接口和数据类型
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package rpc_package;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端发送rpc方法，response &#x3D; stub.SayHello(HelloRequest(name&#x3D;&#39;eric&#39;))</span><br><span class="line">&#x2F;&#x2F; 服务端返回response，是HelloReply类型</span><br><span class="line"></span><br><span class="line">service HelloWorldService &#123;</span><br><span class="line">    &#x2F;&#x2F; define the interface and data type</span><br><span class="line">    rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; define the data type of request</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; define the data type of response</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">    string message &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3><span id="2-shi-yong-grpc-protobuf-sheng-cheng-gong-ju-sheng-cheng-dui-ying-yu-yan-de-ku-han-shu">2.使用gRPC
protobuf生成工具生成对应语言的库函数</span><a href="#2-shi-yong-grpc-protobuf-sheng-cheng-gong-ju-sheng-cheng-dui-ying-yu-yan-de-ku-han-shu" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I&#x3D;.&#x2F;protos --python_out&#x3D;.&#x2F;rpc_package --grpc_python_out&#x3D;.&#x2F;rpc_package</span><br></pre></td></tr></table></figure>
<p>这个指令会自动生成rpc_package文件夹中的<strong>helloworld_pb2.py和helloworld_pb2_grpc.py</strong>，但是不会自动生成__init__.py文件，需要我们手动添加</p>
<h3><span id="3-bian-xie-grpc-server-duan-dai-ma">3. 编写gRPC server端代码</span><a href="#3-bian-xie-grpc-server-duan-dai-ma" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*-coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from concurrent import futures</span><br><span class="line">import grpc</span><br><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">from rpc_package.helloworld_pb2_grpc import add_HelloWorldServiceServicer_to_server, \ </span><br><span class="line">    HelloWorldServiceServicer</span><br><span class="line">from rpc_package.helloworld_pb2 import HelloRequest, HelloReply</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Hello(HelloWorldServiceServicer):</span><br><span class="line"></span><br><span class="line">    # 这里实现我们定义的接口</span><br><span class="line">    def SayHello(self, request, context):</span><br><span class="line">        return HelloReply(message&#x3D;&#39;Hello, %s!&#39; % request.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def serve():</span><br><span class="line">    # 这里通过thread pool来并发处理server的任务</span><br><span class="line">    server &#x3D; grpc.server(futures.ThreadPoolExecutor(max_workers&#x3D;10))</span><br><span class="line"></span><br><span class="line">    # 将对应的任务处理函数添加到rpc server中</span><br><span class="line">    add_HelloWorldServiceServicer_to_server(Hello(), server)</span><br><span class="line"></span><br><span class="line">    # 这里使用的非安全接口，世界gRPC支持TLS&#x2F;SSL安全连接，以及各种鉴权机制</span><br><span class="line">    server.add_insecure_port(&#39;[::]:50000&#39;)</span><br><span class="line">    server.start()</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            time.sleep(60 * 60 * 24)</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        server.stop(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure>
<h3><span id="4-grpc-client-duan-dai-ma">4.gRPC client端代码</span><a href="#4-grpc-client-duan-dai-ma" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from __future__ import print_function</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">import grpc</span><br><span class="line">from rpc_package.helloworld_pb2 import HelloRequest, HelloReply</span><br><span class="line">from rpc_package.helloworld_pb2_grpc import HelloWorldServiceStub</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    # 使用with语法保证channel自动close</span><br><span class="line">    with grpc.insecure_channel(&#39;localhost:50000&#39;) as channel:</span><br><span class="line">        # 客户端通过stub来实现rpc通信</span><br><span class="line">        # 传入通信channel</span><br><span class="line">        stub &#x3D; HelloWorldServiceStub(channel)</span><br><span class="line"></span><br><span class="line">        # 客户端必须使用定义好的类型，这里是HelloRequest类型</span><br><span class="line">        # 客户端发&#x2F;请求</span><br><span class="line">        response &#x3D; stub.SayHello(HelloRequest(name&#x3D;&#39;eric&#39;))</span><br><span class="line">    print (&quot;hello client received: &quot; + response.message)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>
<h3><span id="demo">demo</span><a href="#demo" class="header-anchor">#</a></h3>
<p>运行server端代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python hello_server.py</span><br></pre></td></tr></table></figure>
接着执行client端代码如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  grpc_test python hello_client.py</span><br><span class="line">hello client received: Hello, eric!</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://grpc.io/" title="gRPC官网">gRPC官网</a></li>
<li><a href="https://www.jianshu.com/p/9e57da13b737" title="grpc原理">grpc原理</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1633335936037018920&amp;wfr=spider&amp;for=pc" title="grpc特性分析">grpc特性分析</a></li>
<li><a href="https://blog.csdn.net/linuxarmsummary/article/details/79467412" title="gRPC 官方文档中文版">gRPC 官方文档中文版</a></li>
<li><a href="https://www.jianshu.com/p/7392406e2450" title="grpc应用详解与实例剖析">grpc应用详解与实例剖析</a></li>
</ol>
]]></content>
      <categories>
        <category>Protobuf&amp;gRPC</category>
      </categories>
      <tags>
        <tag>Protobuf&amp;gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] eval,exec,compile等函数</title>
    <url>/2020/12/16/Python-eval-exec-compile%E7%AD%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2><span id="eval-han-shu">eval函数</span><a href="#eval-han-shu" class="header-anchor">#</a></h2>
<h3><span id="eval-zuo-yong-shi-shi-me">eval作用是什么</span><a href="#eval-zuo-yong-shi-shi-me" class="header-anchor">#</a></h3>
<p><strong>计算</strong>指定表达式的值。也就是说它要执行的Python代码只能是单个运算表达式（注意eval不支持任意形式的赋值操作），而不能是复杂的代码逻辑，这一点和lambda表达式比较相似。</p>
<p>函数定义： eval(expression, globals=None, locals=None) 参数说明：
expression：必选参数，可以是字符串，也可以是一个任意的code对象实例（可以通过compile函数创建）。如果它是一个字符串，它会被当作一个（使用globals和locals参数作为全局和本地命名空间的）Python表达式进行分析和解释。
globals：可选参数，表示全局命名空间（存放全局变量），如果被提供，则必须是一个字典对象。
locals：可选参数，表示当前局部命名空间（存放局部变量），如果被提供，可以是任何映射对象。如果该参数被忽略，那么它将会取与globals相同的值。
如果globals与locals都被忽略，那么它们将取eval()函数被调用环境下的全局命名空间和局部命名空间。
返回值：
如果expression是一个code对象，且创建该code对象时，compile函数的mode参数是'exec'，那么eval()函数的返回值是None；
否则，如果expression是一个输出语句，如print()，则eval()返回结果为None；
否则，expression表达式的结果就是eval()函数的返回值； 实例： x = 10</p>
<p>def func(): y = 20 a = eval('x + y') print('a: ', a) b = eval('x +
y', {'x': 1, 'y': 2}) print('b: ', b) c = eval('x + y', {'x': 1, 'y':
2}, {'y': 3, 'z': 4}) print('c: ', c) d = eval('print(x, y)') print('d:
', d)</p>
<p>func() 输出结果：</p>
<p>a: 30 b: 3 c: 4 10 20 d: None 对输出结果的解释：</p>
<p>对于变量a，eval函数的globals和locals参数都被忽略了，因此变量x和变量y都取得的是eval函数被调用环境下的作用域中的变量值，即：x
= 10, y = 20，a = x + y = 30
对于变量b，eval函数只提供了globals参数而忽略了locals参数，因此locals会取globals参数的值，即：x
= 1, y = 2，b = x + y = 3
对于变量c，eval函数的globals参数和locals都被提供了，那么eval函数会先从全部作用域globals中找到变量x,
从局部作用域locals中找到变量y，即：x = 1, y = 3, c = x + y = 4
对于变量d，因为print()函数不是一个计算表达式，没有计算结果，因此返回值为None</p>
<h2><span id="exec">exec</span><a href="#exec" class="header-anchor">#</a></h2>
<p>在python中，变量查找遵循LGB原则，即优先在 <strong>局部作用域(local
scope)</strong>中对变量进行查找，失败则在 <strong>全局作用域(global
scope)</strong>中进行查找,最后尝试再 <strong>内建作用域(build-in
scope)</strong>内查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec code in __main__.dict</span><br><span class="line">相当于</span><br><span class="line">exec code in  globals(), locals()</span><br></pre></td></tr></table></figure>
<p>如果__main__.dict中没有相应的key时，exec执行后会设置的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print __main__.__dict__</span><br><span class="line">&#123;&#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__main__&#39;: &lt;module &#39;__main__&#39; (built-in)&gt;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None&#125;</span><br><span class="line">&gt;&gt;&gt; a &#x3D; 1</span><br><span class="line">&gt;&gt;&gt; exec &quot;print a&quot; in __main__.__dict__</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print __main__.__dict__</span><br><span class="line"># exec执行后设置了a属性</span><br><span class="line">&#123;&#39;a&#39;: 1, &#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;__package__&#39;: None, &#39;__main__&#39;: &lt;module &#39;__main__&#39; (built-in)&gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; exec &#39;print a&#39; in &#123;&#39;a&#39;:1&#125;,&#123;&#39;a&#39;:789&#125;</span><br><span class="line">789</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>[TCP/IP卷一]1.Internet地址结构</title>
    <url>/2020/11/15/TCP-IP%E5%8D%B7%E4%B8%80-1-Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>最近打算读一下计算机网路领域的圣经，并将一些重要知识点总结记录下来。</p>
<h2><span id="1-1-yin-yan">1.1 引言</span><a href="#1-1-yin-yan" class="header-anchor">#</a></h2>
<p>链接到Internet的设备都必须有一个
<strong>IP地址</strong>。基于TCP/IP协议的专用网络中
<strong>使用的设备</strong> 也具有IP地址。
<strong>IP路由器</strong>实现的转发程序使用IP地址来
<strong>识别流量去向</strong>；IP地址也表示流量的来源。
IP地址与电话号码类似，但人们知道电话号码，而 IP地址通常被Internet中的
<strong>DNS</strong>屏蔽在用户视野之外， DNS实现大多数人使用的是
<strong>名字</strong>而非数字化的IP地址。</p>
<p>个人用户通常由Internet <strong>服务商（ISP）分配</strong>
地址，通过支付费用来获得地址和执行路由。</p>
<h2><span id="1-2-biao-shi-ip-di-zhi">1.2 表示IP地址</span><a href="#1-2-biao-shi-ip-di-zhi" class="header-anchor">#</a></h2>
<ul>
<li><p>IPv4地址，通常采用
<strong>点分四组或者点分十进制表示法（192.168.0.1）</strong>。点分四组表示法由
四个用点分隔的十进制数组成。每个数字都是
<strong>[0,255]的非负整数(8位二进制可以表示)</strong>，代表整个IP地址的四分之一（共占32位大小）。</p></li>
<li><p>IPv6，地址长度为
<strong>128位</strong>，是IPv4的四倍，它通常采用成为<strong>块或者字段的四个十六进制数（一个块大小为16位）</strong>，这些数用冒号分隔。
例如一个包含8个块的IPv6可以写成
5f05:2000:80ad:5800:0058:0800:2023:1d71。虽然不像用户熟悉的十进制数，但将十六进制转换为二级制更容易。另外IPv6可以简化成标准化的
<strong>[RFC4291]</strong>:</p></li>
<li><ol type="1">
<li>一个块的前导零不必书写，如上面可以写成：5f05:2000:80ad:5800:58:800:2023:1d71</li>
</ol></li>
<li><ol start="2" type="1">
<li>全零块可以省略，用::代替，例如 0：0：0：0：0：0：0：1可以写成
::1。为了避免歧义，<strong>一个IPv6中::只能使用一次</strong>。</li>
</ol></li>
<li><ol start="3" type="1">
<li>IPv6格式嵌入IPv4地址可使用混合符号形式，如IPv6地址::ffff:10.0.0.1可以表示IPv4地址为10.0.0.1。</li>
</ol></li>
<li><ol start="4" type="1">
<li>IPv6的
<strong>低32位通常用点分四组法</strong>。Ipv6地址::0102::f001相当于地址::1.2.240.1。它被称为IPv4兼容的IPv6地址。</li>
</ol></li>
</ul>
<p>后面<strong>[RFC5952]</strong>做了命名新的优化，这里不细讲了。</p>
<h2><span id="1-3-ji-ben-de-ip-di-zhi-jie-gou">1.3 基本的IP地址结构</span><a href="#1-3-ji-ben-de-ip-di-zhi-jie-gou" class="header-anchor">#</a></h2>
<p>IPv4 地址空间中有 4 294 967 296(2^32)个可能的地址，而
IPv6地址个数为(2^128)：(不列了，实在太大了，根本用不完)。由于拥有大量地址，可以方便将地址空间
<strong>分为一个一个块</strong>。</p>
<h3><span id="1-3-1-dan-bo-di-zhi">1.3.1 单播地址</span><a href="#1-3-1-dan-bo-di-zhi" class="header-anchor">#</a></h3>
<p>大多IPv4地址块被 <strong>最终细分为一个地址</strong>，用于
<strong>识别链接Internet或某些专用的内联网计算机网络接口</strong>。这些就是单播地址(IPv4
<strong>大部分都是单播地址空间</strong>)</p>
<p>除了单播地址，还有 <strong>广播，组播和任播地址</strong>。</p>
<h3><span id="1-3-2-fen-lei-xun-zhi">1.3.2 分类寻址</span><a href="#1-3-2-fen-lei-xun-zhi" class="header-anchor">#</a></h3>
<ul>
<li>每个IP单播地址 =
<strong>网络部分(识别接口使用的iP地址在哪个网络可被发现) +
主机地址(识别网络部分下的特定主机)</strong>。 因此地址中一些连续位称为
<strong>网络号</strong>，其余称为 <strong>主机号</strong>。</li>
<li>现实中 <strong>不同网络下主机数量不一</strong>，
每台主机都需要一个唯一IP。 --
方案1：基于当前或预计主机数量，将不同大小的IP地址空间分配给不同的站点。</li>
</ul>
]]></content>
      <tags>
        <tag>TCP/IP卷一</tag>
      </tags>
  </entry>
  <entry>
    <title>[Protobuf&amp;gRPC] 1.protobuf简介</title>
    <url>/2020/10/17/Protobuf-gRPC-1-protobuf%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3><span id="mu-lu">目录</span><a href="#mu-lu" class="header-anchor">#</a></h3>
<p>[TOC]</p>
<h2><span id="protobuf-shi-shi-me">Protobuf是什么</span><a href="#protobuf-shi-shi-me" class="header-anchor">#</a></h2>
<p>Protobuf全称是Google Protocol
Buffer，是一种高效轻便的<strong>结构化数据存储方式</strong>，可用于网络通信、数据存储等。</p>
<p>其具有以下优点：</p>
<ul>
<li>平台无关、语言无关</li>
<li>支持Java, C++, Python等多种语言，支持多平台。</li>
<li>轻便高效，比XML更小（3~10倍），更快（20 ~ 100倍），更为简单。</li>
<li>扩展性，兼容性好</li>
<li>序列化数据结构的协议，可以更新数据结构，而不影响和破坏原有的旧程序。</li>
</ul>
<div style="width:90%;margin:auto">
<img src="/2020/10/17/Protobuf-gRPC-1-protobuf%E7%AE%80%E4%BB%8B/protobuf%E7%AE%80%E4%BB%8B.png" class title="protobuf简介图">
</div>
<h3><span id="xu-lie-hua">序列化</span><a href="#xu-lie-hua" class="header-anchor">#</a></h3>
<p>将数据结构或对象转换成能够被存储和传输（例如网络传输）的格式（网络传输传输的是<strong>二进制数据</strong>），同时应当要保证这个序列化结果在之后（可能是另一个计算环境中）能够<strong>被重建回原来的数据结构或对象</strong>。</p>
<h2><span id="protobuf-yu-fa-jie-shao">protobuf语法介绍</span><a href="#protobuf-yu-fa-jie-shao" class="header-anchor">#</a></h2>
<p>目前有Protobuf2和Protobuf3。</p>
<h3><span id="protobuf2-yu-fa-jian-jie">protobuf2语法简介</span><a href="#protobuf2-yu-fa-jian-jie" class="header-anchor">#</a></h3>
<p>.proto文件中数据类型可以分为两大类:</p>
<ul>
<li>复合数据类型包括：<strong>枚举和message类型</strong></li>
<li>标准数据类型包含：<strong>整型，浮点，字符串</strong>等</li>
</ul>
<p>数据类型前面修饰词：</p>
<ul>
<li>required:
<strong>必须赋值</strong>，不能为空，否则该条message会被认为是“uninitialized”。除此之外，“required”字段跟“optional”字段并无差别。</li>
<li>optional:字段<strong>可以赋值，也可以不赋值</strong>。假如没有赋值的话，会被赋上默认值。</li>
<li>repeated:
该字段<strong>可以重复任意次数</strong>，包括0次。重复数据的顺序将会保存在protocol
buffer中，将这个字段想象成一个可以自动设置size的数组就可以了。</li>
</ul>
<p>注：<strong>每个字段要给数字</strong>
<strong>该Number是用来标记该字段在序列化后的二进制数据中所在的field</strong>，每个字段的<strong>Number在message内部都是独一无二的</strong>。也<strong>不能进行改变</strong>，否则数据就不能正确的解包</p>
<p>关于 proto2 定义 message
消息的更多语法细节，例如具有支持哪些类型，字段编号分配、import
导入定义，reserved 保留字段等知识请参阅 <a href="https://www.jianshu.com/p/6f68fb2c7d19" title="ProtoBuf 官方文档（二）- 语法指引（proto2）">ProtoBuf
官方文档（二）- 语法指引（proto2）</a></p>
<p>关于定义时的一些规范请参阅 <a href="https://www.jianshu.com/p/8c55fb0a09b5" title="[翻译] ProtoBuf 官方文档（四）- 规范指引">[翻译] ProtoBuf
官方文档（四）- 规范指引</a></p>
<h3><span id="protobuf3-yu-fa-jie-shao">protobuf3语法介绍</span><a href="#protobuf3-yu-fa-jie-shao" class="header-anchor">#</a></h3>
<ul>
<li><p>字段前取消了required和optional两个关键字，目前可用的只有repeated关键字。</p></li>
<li><p>不可以设置默认值了。</p>
<ol type="1">
<li>string默认为空串</li>
<li>枚举默认为第一个枚举定义的第一个值。并且必须是0,必须有有一个0值，我们可以用这个0值作为默认值。这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。</li>
<li>bytes默认为空bytes</li>
<li>bool默认为false</li>
<li>数字类型默认为0</li>
</ol></li>
<li><p>protoType类型如下：
double、float、int32、int64、uint32、uint64、sint32、sint64、fixed32、fixed64、sfixed32、sfixed64、bool、string、bytes</p></li>
<li><p>分配标识号
正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留
[1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p></li>
<li><p>标识号区间[1，2^29 -
1]。<strong>不可以使用其中的[19000－19999]</strong>(从FieldDescriptor::kFirstReservedNumber
到 FieldDescriptor::kLastReservedNumber)的标识号，
Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。</p></li>
<li><p>指定字段规则 所指定的消息字段修饰符必须是如下之一：
<strong>singular</strong>：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。
<strong>repeated</strong>：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。
在proto3中，repeated的标量域默认情况下使用packed。</p></li>
</ul>
<h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h2>
<p>使用Python的话简便的安装方法如下（linux）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install protobuf    # 安装protobuf库</span><br><span class="line">sudo apt-get install protobuf-compiler  # 安装protobuf编译器</span><br></pre></td></tr></table></figure>
<h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor">#</a></h2>
<p>目前有Protobuf2和Protobuf3，本文以Protobuf3为例。</p>
<h3><span id="di-yi-bu-chuang-jian-proto-wen-jian-ding-yi-shu-ju-jie-gou">第一步，创建.proto文件，定义数据结构</span><a href="#di-yi-bu-chuang-jian-proto-wen-jian-ding-yi-shu-ju-jie-gou" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;指定正在使用proto3语法：如果没有指定这个，编译器会使用proto2</span><br><span class="line">&#x2F;&#x2F;这个指定语法行必须是文件的非空非注释的第一个行</span><br><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">  int32 id &#x3D; 2;</span><br><span class="line">  string email &#x3D; 3;</span><br><span class="line">  float money &#x3D; 4;</span><br><span class="line">  bool work_status &#x3D; 5;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones &#x3D; 6;</span><br><span class="line">  MyMessage maps &#x3D; 7;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message PhoneNumber &#123;</span><br><span class="line">    string number &#x3D; 1;</span><br><span class="line">    PhoneType type &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    MOBILE &#x3D; 0;</span><br><span class="line">    HOME &#x3D; 1;</span><br><span class="line">    WORK &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message MyMessage &#123;</span><br><span class="line">  map&lt;int32, int32&gt; mapfield &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="di-er-bu-protoc-bian-yi-proto-wen-jian-sheng-cheng-du-xie-jie-kou">第二步，protoc 编译
.proto 文件生成读写接口</span><a href="#di-er-bu-protoc-bian-yi-proto-wen-jian-sheng-cheng-du-xie-jie-kou" class="header-anchor">#</a></h3>
<p>我们在 .proto
文件中定义了数据结构，这些数据结构是<strong>面向开发者和业务程序的</strong>，并不面向存储和传输。</p>
<p>当需要把这些数据进行存储或传输时，就需要<strong>将这些结构数据进行序列化、反序列化以及读写</strong>。那么如何实现呢？答案就是通过
<strong>protoc</strong> 这个编译器。</p>
<p>利用protoc.exe编译proto文件，cmd切换到当前目录，执行以下命令：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; $SRC_DIR: .proto 所在的源目录</span><br><span class="line">&#x2F;&#x2F; --python_out: 生成 python 代码</span><br><span class="line">&#x2F;&#x2F; $DST_DIR: 生成代码的目标目录</span><br><span class="line">&#x2F;&#x2F; xxx.proto: 要针对哪个 proto 文件生成接口代码</span><br><span class="line">protoc -I&#x3D;$SRC_DIR --python_out&#x3D;$DST_DIR xxx.proto</span><br></pre></td></tr></table></figure>
这里我们使用如下编译语句
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc -I&#x3D;. --python_out&#x3D;.&#x2F; addressbook.proto</span><br></pre></td></tr></table></figure></p>
<p>编译好之后你就会在目标目录里面看到输出的结果文件，如下：addressbook_pb2.py</p>
<h3><span id="di-san-bu-bian-yi-py-wen-jian-jin-xing-xu-lie-hua-he-fan-xu-lie-hua">第三步，编译.py文件，进行序列化和凡序列化</span><a href="#di-san-bu-bian-yi-py-wen-jian-jin-xing-xu-lie-hua-he-fan-xu-lie-hua" class="header-anchor">#</a></h3>
<p>add_person.py
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from tutorial import addressbook_pb2</span><br><span class="line"></span><br><span class="line">address_book &#x3D; addressbook_pb2.AddressBook()</span><br><span class="line">person &#x3D; address_book.people.add()</span><br><span class="line"></span><br><span class="line">person.id &#x3D; 1</span><br><span class="line">person.name &#x3D; &quot;safly&quot;</span><br><span class="line">person.email &#x3D; &quot;safly@qq.com&quot;</span><br><span class="line">person.money &#x3D; 1000.11</span><br><span class="line">person.work_status &#x3D; True</span><br><span class="line"></span><br><span class="line">phone_number &#x3D; person.phones.add()</span><br><span class="line">phone_number.number &#x3D; &quot;123456&quot;</span><br><span class="line">phone_number.type &#x3D; addressbook_pb2.MOBILE</span><br><span class="line"></span><br><span class="line">maps &#x3D; person.maps</span><br><span class="line">maps.mapfield[1] &#x3D; 1</span><br><span class="line">maps.mapfield[2] &#x3D; 2</span><br><span class="line"></span><br><span class="line">#序列化</span><br><span class="line">serializeToString &#x3D; address_book.SerializeToString()</span><br><span class="line">print(serializeToString,type(serializeToString))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">address_book.ParseFromString(serializeToString)</span><br><span class="line"></span><br><span class="line">for person in address_book.people:</span><br><span class="line">  print(&quot;p_id&#123;&#125;,p_name&#123;&#125;,p_email&#123;&#125;,p_money&#123;&#125;,p_workstatu&#123;&#125;&quot;</span><br><span class="line">        .format(person.id,person.name,person.email,person.money,person.work_status))</span><br><span class="line"></span><br><span class="line">  for phone_number in person.phones:</span><br><span class="line">    print(phone_number.number,phone_number.type)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for key in person.maps.mapfield:</span><br><span class="line">    print(key,person.maps.mapfield[key])</span><br></pre></td></tr></table></figure>
编译该py文件，输出结果如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#39;\n6\n\x05safly\x10\x01\x1a\x0csafly@qq.com%\n\x07zD(\x012\x08\n\x06123456:\x0c\n\x04\x08\x01\x10\x01\n\x04\x08\x02\x10\x02&#39; &lt;class &#39;bytes&#39;&gt;</span><br><span class="line"></span><br><span class="line">p_id1,p_namesafly,p_emailsafly@qq.com,p_money1000.1099853515625,p_workstatuTrue</span><br><span class="line">123456 0</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
我们就看到了序列化和反序列化的结果</p>
<p>这篇简介就介绍到这，后期会继续</p>
<h2><span id="jin-jie-shi-yong">进阶使用</span><a href="#jin-jie-shi-yong" class="header-anchor">#</a></h2>
<p>addressbook.proto内容如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package tutorial;</span><br><span class="line">&#x2F;&#x2F;引入外部proto</span><br><span class="line">import &quot;emu.proto&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">  int32 id &#x3D; 2;</span><br><span class="line">  string email &#x3D; 3;</span><br><span class="line">  float money &#x3D; 4;</span><br><span class="line">  bool work_status &#x3D; 5;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones &#x3D; 6;</span><br><span class="line">  &#x2F;&#x2F;外部引用map</span><br><span class="line">  repeated MyMessage maps &#x3D; 7;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;内部嵌套message</span><br><span class="line">  repeated Hobby hobby &#x3D; 8;</span><br><span class="line">  message Hobby&#123;</span><br><span class="line">    string interest &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message PhoneNumber &#123;</span><br><span class="line">    string number &#x3D; 1;</span><br><span class="line">    PhoneType type &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    MOBILE &#x3D; 0;</span><br><span class="line">    HOME &#x3D; 1;</span><br><span class="line">    WORK &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们将addressbook.proto中的repeated MyMessage maps = 7;进行了外部引用，
emu.proto如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message MyMessage &#123;</span><br><span class="line">  map&lt;int32, int32&gt; mapfield &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后首先对emu.proto进行编译， protoc ./emu.proto --python_out=./</p>
<p>然后会addressbook.proto进行编译 protoc ./addressbook.proto
--python_out=./
然后会默认生成上述截图中的emu_pb2.py、addressbook_pb2.py文件</p>
<p>我们接下来看看add_person.py代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from tutorial import addressbook_pb2</span><br><span class="line"></span><br><span class="line">address_book &#x3D; addressbook_pb2.AddressBook()</span><br><span class="line">person &#x3D; address_book.people.add()</span><br><span class="line"></span><br><span class="line">person.id &#x3D; 1</span><br><span class="line">person.name &#x3D; &quot;safly&quot;</span><br><span class="line">person.email &#x3D; &quot;safly@qq.com&quot;</span><br><span class="line">person.money &#x3D; 1000.11</span><br><span class="line"></span><br><span class="line">person.work_status &#x3D; True</span><br><span class="line"></span><br><span class="line">phone_number &#x3D; person.phones.add()</span><br><span class="line">phone_number.number &#x3D; &quot;123456&quot;</span><br><span class="line">phone_number.type &#x3D; addressbook_pb2.MOBILE</span><br><span class="line"></span><br><span class="line">maps &#x3D; person.maps.add()</span><br><span class="line">maps.mapfield[1] &#x3D; 1</span><br><span class="line">maps.mapfield[2] &#x3D; 2</span><br><span class="line"></span><br><span class="line">hobby &#x3D; person.hobby.add()</span><br><span class="line">hobby.interest &#x3D; &quot;python&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#序列化</span><br><span class="line">serializeToString &#x3D; address_book.SerializeToString()</span><br><span class="line">print(serializeToString,type(serializeToString))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">address_book.ParseFromString(serializeToString)</span><br><span class="line"></span><br><span class="line">for person in address_book.people:</span><br><span class="line">  print(&quot;p_id&#123;&#125;,p_name&#123;&#125;,p_email&#123;&#125;,p_money&#123;&#125;,p_workstatu&#123;&#125;&quot;</span><br><span class="line">        .format(person.id,person.name,person.email,person.money,person.work_status))</span><br><span class="line"></span><br><span class="line">  for phone_number in person.phones:</span><br><span class="line">    print(phone_number.number,phone_number.type)</span><br><span class="line">  print(person.phones[0].number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for map in person.maps:</span><br><span class="line">    for key in map.mapfield:</span><br><span class="line">      print(key,&#39;-------&#39;,map.mapfield[key])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for hobby in person.hobby:</span><br><span class="line">    print(hobby.interest)</span><br></pre></td></tr></table></figure>
最后输出结果如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Users&#x2F;zhiliao&#x2F;miniconda3&#x2F;bin&#x2F;python &#x2F;Users&#x2F;zhiliao&#x2F;zhiliao&#x2F;untitled1&#x2F;tutorial&#x2F;add_person.py</span><br><span class="line">b&#39;\n@\n\x05safly\x10\x01\x1a\x0csafly@qq.com%\n\x07zD(\x012\x08\n\x06123456:\x0c\n\x04\x08\x01\x10\x01\n\x04\x08\x02\x10\x02B\x08\n\x06python&#39; &lt;class &#39;bytes&#39;&gt;</span><br><span class="line">p_id1,p_namesafly,p_emailsafly@qq.com,p_money1000.1099853515625,p_workstatuTrue</span><br><span class="line">123456 0</span><br><span class="line">123456</span><br><span class="line">2 ------- 2</span><br><span class="line">1 ------- 1</span><br><span class="line">python</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://blog.csdn.net/u013210620/article/details/81317731" title="python基础--protobuf的使用(一)">python基础--protobuf的使用(一)</a></li>
<li><a href="https://www.jianshu.com/p/2265f56805fa" title="Protobuf学习">Protobuf学习</a></li>
<li><a href="https://www.jianshu.com/p/31a6b4b2c3ab" title="Protobuf Python 示例">Protobuf Python 示例</a></li>
</ol>
<h2><span id="tuo-zhan-yue-du">拓展阅读</span><a href="#tuo-zhan-yue-du" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://www.jianshu.com/p/73c9ed3a4877" title="深入 ProtoBuf - 编码">深入 ProtoBuf - 编码</a></li>
<li><a href="https://www.jianshu.com/p/62f0238beec8" title="深入 ProtoBuf - 序列化源码解析">深入 ProtoBuf -
序列化源码解析</a></li>
<li><a href="https://www.jianshu.com/p/ddc1aaca3691" title="深入 ProtoBuf - 反射原理解析">深入 ProtoBuf -
反射原理解析</a></li>
</ol>
]]></content>
      <categories>
        <category>Protobuf&amp;gRPC</category>
      </categories>
      <tags>
        <tag>Protobuf&amp;gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity项目架构设计与开发管理</title>
    <url>/2020/08/10/Unity%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2><span id="1-chang-jian-jia-gou">1.常见架构</span><a href="#1-chang-jian-jia-gou" class="header-anchor">#</a></h2>
<ul>
<li>EmptyGo</li>
<li>simple GameManager</li>
<li>Manager of Managers</li>
<li>MVCS</li>
<li>MVVM:UFRAME</li>
</ul>
<h2><span id="2-emptygo">2.EmptyGo</span><a href="#2-emptygo" class="header-anchor">#</a></h2>
<ul>
<li>Put all the code without visual representation in the world onto an
empty game object.</li>
<li>use GameObject.Find() or inspector target references to communicate
with each other.<strong>GameObject.Find()不解耦合</strong></li>
</ul>
<h2><span id="3-simple-gamemanager">3.simple GameManager</span><a href="#3-simple-gamemanager" class="header-anchor">#</a></h2>
<ul>
<li>改为一个singleton</li>
<li>包括UI设计，包括模块的访问</li>
<li><strong>全部塞进去，会发生混乱</strong></li>
</ul>
<h2><span id="4-manager-of-managers-zhong-xing-you-xi-fei-chang-chang-yong">4.Manager of
Managers(中型游戏非常常用)</span><a href="#4-manager-of-managers-zhong-xing-you-xi-fei-chang-chang-yong" class="header-anchor">#</a></h2>
<ul>
<li>MainManager（<strong>customizes and managers all the
submanagers</strong>）（<strong>submanagers operate as singletons and
can easily address each other to collaborate</strong>）
<ol type="1">
<li>EventManager:集中管理UI到各个模块之间的消息，以及各个模块相互访问的传递</li>
<li>AudioManager:在场景中任何一个地方播放音乐，都用它来管理</li>
<li>GUIManager:管理所有UI发生的click的事件</li>
<li>PoolManager:把已经初始化，但暂不使用的gameobject放入pool(非常重要)</li>
<li>LevelManager:关卡管理(非常重要)</li>
<li>GameManager:</li>
<li>SaveManager:load page，游戏退出后，进入还想在原处(非常重要)</li>
<li>MenuManager:管理Menu上的动画，外观上的东西（严格与GUIManager事件管理区分开来）</li>
</ol></li>
</ul>
<h3><span id="4-1-level-manager">4.1 level manager</span><a href="#4-1-level-manager" class="header-anchor">#</a></h3>
<h4><span id="4-1-1-unity-zi-dai-application-loadlevel">4.1.1 Unity 自带
Application.loadLevel();</span><a href="#4-1-1-unity-zi-dai-application-loadlevel" class="header-anchor">#</a></h4>
<p><strong>ISSUE 1:</strong> you need to know the scene name or the
index of the scene you want to load,but most probably <strong>the name
or order will be changed later</strong>.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Application.loadLevel(&quot;FirstLevel&quot;);</span><br><span class="line">Application.loadLevel(1);</span><br></pre></td></tr></table></figure></p>
<p><strong>ISSUE 2:</strong> there's no simple method of passing
arguments to a scene , e.g., assuming you're <strong>resuing one scene
for many different levels.</strong></p>
<p><strong>ISSUE 3:</strong>managing multiple level work flows is not a
simple task. suppose you want to <strong>create two versions of your
game</strong>:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Application.loadLevel(1);</span><br><span class="line">Application.loadLevel(2);</span><br><span class="line">Application.loadLevel(3);</span><br><span class="line">---</span><br><span class="line">VS</span><br><span class="line">---</span><br><span class="line">Application.loadLevel(1);</span><br><span class="line">Application.loadLevel(3);</span><br><span class="line">Application.loadLevel(2);</span><br></pre></td></tr></table></figure></p>
<h4><span id="4-2-level-manager-she-ji">4.2 level manager设计</span><a href="#4-2-level-manager-she-ji" class="header-anchor">#</a></h4>
<ol type="1">
<li>Compose a configuration
table.(需要变换加载场景顺序，仅需要在表内变换)</li>
<li>create a new API
<ul>
<li>LevelManager.LoadNext();</li>
</ul></li>
<li>In the configuration table, it also should <strong>be allowed to set
an argument line for each level</strong>.</li>
<li>It should be allowed to create multiple configuration tables,and
before building your appliaction switch between
them.(示例：Unity商店MadLevelManager)</li>
</ol>
<h4><span id="4-3-pool-manager-she-ji">4.3 pool manager设计</span><a href="#4-3-pool-manager-she-ji" class="header-anchor">#</a></h4>
<ol type="1">
<li>Maintain a list of dormant objects in the pool class:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&lt;GameObject&gt; dormantObjects &#x3D; new List &lt;GameObject&gt;();</span><br></pre></td></tr></table></figure></li>
<li>the list contains all different types of game objects / prefabs</li>
</ol>
<p><strong>SPAWN()</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public GameObject Spawn(GameObject go)&#123;</span><br><span class="line">    GameObject temp &#x3D; null;</span><br><span class="line">    if (dormantObjects.count&gt;0)&#123;</span><br><span class="line">        foreach(GameObject dob in dormantObjects)&#123;</span><br><span class="line">            if(dob.name &#x3D;&#x3D; go.name)&#123;</span><br><span class="line">                temp &#x3D; dob;</span><br><span class="line">                dormantObjects.remove(temp);</span><br><span class="line">                return temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp &#x3D; GameObejct.Instantiate(go) as GameObejct;</span><br><span class="line">    temp.name &#x3D; go.name;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>DESPAWN()</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public GameObject Despawn(GameObject go)&#123;</span><br><span class="line">    go.transform.parent &#x3D; PoolManager.transform;</span><br><span class="line">    go.SetActive(false);</span><br><span class="line">    dormantObjects.Add(go);</span><br><span class="line">    Trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TRIM</strong>（超过限制就删除）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Trim()&#123;</span><br><span class="line">    while(dormantObjects.Count&gt;Capacity)&#123;</span><br><span class="line">        GameObject dob &#x3D; dormantObjects[0];</span><br><span class="line">        dormantObjects.RemoveAt(0);</span><br><span class="line">        Destory(dob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PROBLEMS</strong> 1. This pool is <strong>not able to manage
the Load/Unload of prefabs</strong>. 2. Only dormant objects are managed
in the pool, <strong>active objects must be managed out of pool
separately</strong>. 3. The total number of dormant objects can be
controlled, rather than the instances of each
prefabs.（总物体有数量限制，而不是每中类型没有限制）</p>
<p><strong>better design</strong> PoolManager:<strong>Singleton,Manage
multiple SpawnPools</strong> - SpawnPool1 + prefabPool1---Prefab1 +
prefabPool2---Prefab2 - SpawnPool2 + prefabPool3---Prefab3 +
prefabPool4---Prefab4</p>
<p><strong>Spawnpool</strong>：design rules for spawnpool 1. define an
empty object,set its transform as the parent of all the instances in the
pool.（空物体） 2. manager multiple prefabpools via a dictionary</p>
<p><strong>prefabPool</strong> 1. create a prefabPool for each prefab.
2. maintains a list of activated objects and another list of deactive
objects. 3. centrally manage the load/unload process here.</p>
<h4><span id="4-4-save-manager-she-ji">4.4 save manager设计</span><a href="#4-4-save-manager-she-ji" class="header-anchor">#</a></h4>
<ol type="1">
<li>save and load user preferences and achievements.
<ul>
<li>quit/resume game</li>
</ul></li>
<li>a lot of developers are used to save/load data with JSON/XML
files.</li>
<li>Is there any better solution?
<ul>
<li>Serialize almost any type of data.</li>
<li>it's fast,even on mobile devices.</li>
<li>encrypt save date efficiently and securely.</li>
<li>snap a screen</li>
</ul></li>
</ol>
<h3><span id="5-mvcs-strangeioc-ui-he-luo-ji-fen-kai">5.
MVCS:STRANGEIOC(UI和逻辑分开)</span><a href="#5-mvcs-strangeioc-ui-he-luo-ji-fen-kai" class="header-anchor">#</a></h3>
<div style="width:60%;margin:auto">
<img src="/2020/08/10/Unity%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/Manager_of_Managers_problem.png" class title="Manager of Managers 模式的问题">
</div>
<div style="width:60%;margin:auto">
<img src="/2020/08/10/Unity%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/Manager_of_Managers_problem2.png" class title="Manager of Managers 模式的问题">
</div>
<h4><span id="5-1-strangeioc-framework">5.1 strangeioc framework</span><a href="#5-1-strangeioc-framework" class="header-anchor">#</a></h4>
<ol type="1">
<li>The core of the framework is <strong>binding</strong></li>
<li>basic structure: The key triggers the value.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;();</span><br></pre></td></tr></table></figure></li>
<li>advanced structure: the name is a discriminator
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;().ToName(name);</span><br></pre></td></tr></table></figure></li>
<li>Type of key</li>
</ol>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 36%">
<col style="width: 36%">
</colgroup>
<thead>
<tr>
<th>key</th>
<th style="text-align: center;">value</th>
<th style="text-align: right;">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>event</td>
<td style="text-align: center;">callback</td>
<td style="text-align: right;">an event triggers a callback</td>
</tr>
<tr>
<td>interface</td>
<td style="text-align: center;">implementation</td>
<td style="text-align: right;">binds an interface to its
implementation</td>
</tr>
<tr>
<td>class</td>
<td style="text-align: center;">dependent class</td>
<td style="text-align: right;">the instantiation of one class triggers
the instantiation of dependent class.</td>
</tr>
</tbody>
</table>
<div style="width:60%;margin:auto">
<img src="/2020/08/10/Unity%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/MVCS.png" class title="MVCS概述">
</div>
<ol type="1">
<li>a view only does display and
input.(UI事件和GameObject上的可视化相关)</li>
<li>the mediator connects the view with the rest of your app</li>
<li>commands are classes triggered by events.</li>
</ol>
<h4><span id="5-2-mediator">5.2 Mediator</span><a href="#5-2-mediator" class="header-anchor">#</a></h4>
<p><strong>Binding</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mediationBinder.Bind&lt;Example View&gt;().To&lt;ExampleMediator&gt;();</span><br></pre></td></tr></table></figure></p>
<p><strong>Dispatcher</strong> - simple format
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatcher.Dispatcher(AttackEvent.FIRE_MISSILE);</span><br></pre></td></tr></table></figure>
- Event + data
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector3 orientation &#x3D; gameObject.transform.loaclRotaion.eulerAngles;</span><br><span class="line">dispatcher.Dispatcher(AttackEvent.FIRE_MISSILE, orientation);</span><br></pre></td></tr></table></figure></p>
<p><strong>Listener</strong> - If Listener is a method
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatcher.AddListener(AttackEvent.FIRE_MISSILE, onMissileFire);</span><br><span class="line">dispatcher.RemoveListener(AttackEvent.FIRE_MISSILE, onMissileFire);</span><br></pre></td></tr></table></figure>
- If Listener is a command
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commandBinder.Binder(GameEvent.GUN_FIRE,OnGunFireCommand);</span><br><span class="line">class OnGunFireCommand:EventCommand&#123;</span><br><span class="line">    override public void Execute()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="5-3-limitation">5.3 Limitation</span><a href="#5-3-limitation" class="header-anchor">#</a></h4>
<ul>
<li>Injection empolys reflection, which is slow.（反射机制耗时）</li>
<li>if inject sth,you have to map it, otherwise, it will result in null
pointer errors.（容易造成空指针）</li>
</ul>
<h3><span id="6-mvvm-uframe">6 MVVM:UFRAME</span><a href="#6-mvvm-uframe" class="header-anchor">#</a></h3>
<p>View---&gt;ViewModel---&gt;Model</p>
<h3><span id="7-bian-ma-ce-lue">7 编码策略</span><a href="#7-bian-ma-ce-lue" class="header-anchor">#</a></h3>
<ul>
<li>文件命名规范</li>
<li>文件名分类</li>
<li>用空物体来管理同类物体</li>
<li>零容忍warnings and errors</li>
<li>零容忍runtime memory location(动态开辟数组等)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>[boost.asio] 1.basic introduction of boost asio</title>
    <url>/2021/04/22/boost-asio-1-basic-introduction-of-boost-asio/</url>
    <content><![CDATA[Boost.Asio
可在I/O对象(如socket)中进行同步(synchronous)和异步(asynchronous)操作。
<a id="more"></a> 接下来，以一个基于同步的I/O socket连接操作为例：
<div style="width:100%;margin:auto">
<img src="/2021/04/22/boost-asio-1-basic-introduction-of-boost-asio/sync_op.png" class title="同步连接">
</div>
<p>在program中,至少需要有一个 I/0 execution
context,如<strong>boost::asio::io_context, boost::asio::thread_pool, or
boost::asio::system_context</strong></p>
<p>该boost::asio::io_context表明已经<strong>连接到</strong>了
<strong>操作系统的 I/O services</strong>上。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br></pre></td></tr></table></figure></p>
<p>program进行I/O操作，必须有一个 I/O object 如 TCP socket：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boost::asio::ip::tcp::socket socket(io_context);</span><br></pre></td></tr></table></figure></p>
<h4><span id="tong-bu-lian-jie-cao-zuo-xiang-guan-shi-jian">同步连接操作相关事件</span><a href="#tong-bu-lian-jie-cao-zuo-xiang-guan-shi-jian" class="header-anchor">#</a></h4>
<p>进行同步连接操作是，如下事件<strong>按顺序</strong>触发 1. 通过调用
I/O object，进行初始化连接
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket.connect(server_endpoint);</span><br></pre></td></tr></table></figure>
2. I/O object <strong>请求 I/O execution context</strong> 3. I/O
execution context
<strong>调用操作系统</strong>，进行<strong>连接操作</strong>。 4.
操作系统<strong>返回 操作返回值</strong> 给 I/O execution context 5. I/O
execution context将 操作系统返回的结果 转换为boost::system::error_code
对象。然后返回该结果给 I/O object。 6. 若操作失败, I/O object 抛出
boost::system::system_error类型的异常。 若初始化操作的code 为：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boost::system::error_code ec;</span><br><span class="line">socket.connect(server_endpoint, ec);</span><br></pre></td></tr></table></figure>
返回结果设置到 类型为error_code的变量ec, I/O object不会抛出异常。</p>
<h4><span id="yi-bu-lian-jie-cao-zuo-xiang-guan-shi-jian">异步连接操作相关事件</span><a href="#yi-bu-lian-jie-cao-zuo-xiang-guan-shi-jian" class="header-anchor">#</a></h4>
<div style="width:90%;margin:auto">
<img src="/2021/04/22/boost-asio-1-basic-introduction-of-boost-asio/async_op1.png" class title="异步连接">
</div>
<ol type="1">
<li><p>通过调用 I/O object，进行初始化连接
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket.async_connect(server_endpoint, your_completion_handler);</span><br></pre></td></tr></table></figure>
其中 **_completion_handler**
是一个<strong>带有签名(signature)</strong>的函数 or 函数对象
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void your_completion_handler(const boost::system::error_code&amp; ec);</span><br></pre></td></tr></table></figure>
这个签名(signature) 取决于正在进行的 异步操作。</p></li>
<li><p>I/O object <strong>请求 I/O execution context</strong>。</p></li>
<li><p>I/O execution context
给<strong>操作系统</strong>发signals，通知操作系统进行异步连接。</p></li>
<li><p><strong>操作系统</strong>完成连接操作后，将结果加入到队列，等待<strong>I/O
execution context</strong>处理。</p></li>
<li><p>当使用 io_context 作为 I/O execution context时,
需要运行io_context::run()，获取返回的结果。当有未完成的异步操作时，不能运行
io_context::run()。因此需要在首次进行异步连接操作时，就运行io_context::run()。</p></li>
<li><p>在 io_context::run() 里，<strong>I/O execution context</strong>
将处理队列中的返回结果，将其翻译成 error_code，然后传给
<strong>completion handler(回调)</strong></p></li>
</ol>
<div style="width:90%;margin:auto">
<img src="/2021/04/22/boost-asio-1-basic-introduction-of-boost-asio/async_op2.png" class title="异步连接2">
</div>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li>(Basic Boost.Asio
Anatomy)[https://www.boost.org/doc/libs/1_75_0/doc/html/boost_asio/overview/core/basics.html]</li>
</ol>
]]></content>
      <categories>
        <category>boost</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>[boost.asio] 2.proactor I/0设计模式:单线程并发</title>
    <url>/2021/04/23/boost-asio-2-proactor-I-0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>Boost.Asio
库为支持同步和异步操作。异步支持基于proactor设计模式[POSA2]。与同步或Reactor方法相比，这种方法的优点和缺点概述如下。
<a id="more"></a> ## Proactor 与 Reactor -
Proactor和Reactor都是<strong>并发编程中的设计模式</strong> -
Proactor用于<strong>异步IO</strong>，而Reactor用于<strong>同步IO</strong>，
关键区别在于 <strong>何时IO</strong> -
Reactor：非阻塞同步网络模型，关心<strong>就绪事件</strong>，
可以理解为：来了事件我通知你，你来处理，如epoll_wait -
Proactor：异步网络模型，关心<strong>完成事件</strong>，可以理解为：来了事件我来处理，处理完了我通知你。</p>
<h2><span id="proactor-yu-boost-asio">Proactor 与 Boost.Asio</span><a href="#proactor-yu-boost-asio" class="header-anchor">#</a></h2>
<div style="width:90%;margin:auto">
<img src="/2021/04/23/boost-asio-2-proactor-I-0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/proactor.png" class title="proactor">
</div>
<h2><span id="proactor-she-ji-mo-shi">Proactor设计模式</span><a href="#proactor-she-ji-mo-shi" class="header-anchor">#</a></h2>
<ul>
<li>异步操作(Asynchronous Operation) 定义异步执行的操作，例如
<strong>异步读</strong>或在<strong>套接字上写入</strong>。</li>
<li>异步操作处理器(Asynchronous Operation Processor)
执行异步操作，并在操作完成时<strong>对completion event
queue中的事件进行排队</strong>。从高层次的角度来看，像<strong>reactive_socket_service</strong>这样的内部服务是异步操作处理器。</li>
<li>完成事件队列(Completion Event Queue)
缓冲完成事件，直到它们被<strong>Asynchronous Event
Demultiplexer</strong>移出队列。</li>
<li>完成处理程序(Completion Handler)
处理异步操作的结果。这些是函数对象，通常<strong>使用boost::bind创建</strong>。</li>
<li>异步事件多路分配器(Asynchronous Event Demultiplexer)
阻塞并等待完成事件队列上发生的事件，并将完成的事件返回其调用者。</li>
<li>前摄器(Proactor) 调用<strong>Asynchronous Event
Demultiplexer</strong>将事件出列，并分派与事件关联的Completion
Handler程序（即调用函数对象）。这个抽象由io_context类表示。</li>
<li>发起者(Initiator)
<strong>启动异步操作的应用程序</strong>特定代码。启动器通过高级接口（如basic_stream_socket）与异步操作处理器进行交互，而高级接口又
<strong>委托给 （如reactive_socket_service）等服务</strong>。</li>
</ul>
<h3><span id="ji-yu-reactor-de-shi-xian">基于Reactor的实现</span><a href="#ji-yu-reactor-de-shi-xian" class="header-anchor">#</a></h3>
<p>在许多平台上，Boost.Asio 在Reactor（如select,
epoll或kqueue）中实现Proactor设计模式，如下所示：</p>
<ul>
<li>异步操作处理器(Asynchronous Operation Processor) 使用<strong>select,
epoll或kqueue</strong>实现的Reactor。当Reactor指示资源已准备好执行操作时，处理器将执行异步操作，并将关联的completion
handler程序入列(enqueue)完成事件队列。</li>
<li>完成事件队列(Completion Event Queue)
完成处理程序（即函数对象）的链表。<br>
</li>
<li>异步事件多路分配器(Asynchronous Event Demultiplexer)
这是通过等待事件或条件变量实现的，直到完成处理程序在完成事件队列中可用。</li>
</ul>
<h3><span id="shi-yong-windows-chong-die-overlapped-i-o-shi-xian">使用 Windows
重叠（Overlapped）I/O 实现</span><a href="#shi-yong-windows-chong-die-overlapped-i-o-shi-xian" class="header-anchor">#</a></h3>
<p>在 Windows NT、2000 和 XP 上，Boost.Asio 利用重叠 I/O
提供Proactor模式的高效实现。此实现方法对应于Proactor设计模式，如下所示：</p>
<ul>
<li>异步操作处理器(Asynchronous Operation Processor)
这是由操作系统实现的。操作通过调用Overlapped函数（如AcceptEx）启动。</li>
<li>完成事件队列(Completion Event Queue) 这由操作系统实现，并关联到 I/O
完成端口。每个io_context实例都有一个 I/O 完成端口。</li>
<li>异步事件多路分配器(Asynchronous Event Demultiplexer) 由 Boost.Asio
调用，使事件及其关联的完成处理程序出列。</li>
</ul>
<h2><span id="que-dian">缺点</span><a href="#que-dian" class="header-anchor">#</a></h2>
<ul>
<li>程序复杂性(Program complexity)。 由于操作启动和完成之间的
<strong>时间和空间的分离</strong>，使用异步机制<strong>开发应用程序更加困难</strong>。由于<strong>控制流的倒置</strong>，应用程序也可能更<strong>难调试</strong>。</li>
<li>内存使用情况(Memory usage)。
在读取或写入操作期间必须<strong>提交缓冲区空间</strong>，此操作可能会<strong>无限期地继续</strong>，并且每个并发操作都需要单独的缓冲区。另一方面，在套接字准备好读取或写入之前，Reactor模式不需要缓冲空间。</li>
</ul>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？</a></li>
<li><a href="https://www.boost.org/doc/libs/1_75_0/doc/html/boost_asio/overview/core/async.html">The
Proactor Design Pattern: Concurrency Without Threads</a></li>
</ol>
]]></content>
      <categories>
        <category>boost</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>[boost.asio] 3.Overview (1)</title>
    <url>/2021/04/26/boost-asio-3-Overview/</url>
    <content><![CDATA[<h2><span id="threads-and-boost-asio">Threads and Boost.Asio</span><a href="#threads-and-boost-asio" class="header-anchor">#</a></h2>
<h4><span id="xian-cheng-an-quan-thread-safety">线程安全（Thread Safety）</span><a href="#xian-cheng-an-quan-thread-safety" class="header-anchor">#</a></h4>
<p>并发（concurrent）在不同对象间是安全的，但对于单一对象，却是不安全的。然而
<strong>io_context等类型</strong>可以保证
<strong>单一对象的并发线程安全</strong>。</p>
<h4><span id="xian-cheng-chi-thread-pools">线程池（Thread Pools）</span><a href="#xian-cheng-chi-thread-pools" class="header-anchor">#</a></h4>
<p>多个线程可以调用
<strong>io_context::run()</strong>来建立一个<strong>线程池</strong>，从中可以调用完成处理程序。这种方法也可以<strong>与post()一起使用</strong>，作为<strong>跨线程池</strong>执行任意计算任务的方法。</p>
<p>所有加入到io_context's
pool的线程都是对等的，io_context可以任意方式分发工作。</p>
<h4><span id="nei-bu-xian-cheng-internal-threads">内部线程（Internal Threads）</span><a href="#nei-bu-xian-cheng-internal-threads" class="header-anchor">#</a></h4>
<p>为了实现异步，有一些调用者不可见的 内部线程，他们必须满足： -
不能被库函数使用者 直接调用 - 屏蔽所有signal</p>
<p>这种方法辅之以以下保证：</p>
<ul>
<li>异步completion
handlers程序将仅从当前<strong>正在调用io_context::run()的线程</strong>调用。</li>
</ul>
<p>因此，库用户需要 <strong>创建 和
管理</strong>所有<strong>收消息的线程</strong>。</p>
<p>这种方法的原因包括：</p>
<ul>
<li>单线程调用<strong>io_context::run()</strong>，可以避免与<strong>同步相关的开发复杂性</strong>。例如，库用户可以实现<strong>单线程的可扩展服务器</strong>。</li>
<li>库用户需要在<strong>线程启动后</strong>以及<strong>执行其他应用程序代码之前</strong>在线程中执行初始化。</li>
<li>库接口与<strong>线程创建和管理</strong>接口<strong>解耦合</strong>，并允许在<strong>线程不可用的平台上实现</strong>。</li>
</ul>
<h2><span id="strands-shi-yong-mei-you-xian-shi-suo-ding-de-xian-cheng-strands-use-threads-without-explicit-locking">Strands:
使用没有显式锁定的线程(Strands: Use Threads Without Explicit
Locking)</span><a href="#strands-shi-yong-mei-you-xian-shi-suo-ding-de-xian-cheng-strands-use-threads-without-explicit-locking" class="header-anchor">#</a></h2>
<p>Strand定义为event
handlers的<strong>严格顺序调用</strong>（即没有并发调用）。使用Strand允许<strong>在多线程</strong>中执行代码，而<strong>无需显式加锁</strong>（例如，使用互斥）。</p>
<p>Strands可implicit 或 explicit: - 由于io_context保证了event
handlers仅从io_context::run()里面触发，因此在单线程中调用
io_context::run()，意味着所有的event handlers在implicit strand中执行。 -
当与连接相关联的单链异步操作（例如采用半双工协议，如HTTP），是不可能存在并发的handlers，这种情况就是implicit
strand。 - explicit strand是 <strong>strand&lt;&gt; or
io_context::strand</strong> 的实例。所有的event handler函数 需要使用
<strong>boost::asio::bind_executor()</strong>绑定到strand上 或
通过<strong>strand对象发布/调度（posted/dispatched）</strong></p>
<p>对于<strong>组合异步操作</strong>，如<strong>async_read()</strong>或<strong>async_read_until()</strong>，如果completion
handler通过strand，则所有中间handlers也应该经历相同的strand。这是确保调用方和组合操作之间<strong>共享的任何对象的线程安全</strong>。</p>
<p>为此，所有异步操作都使用<strong>get_associated_executor</strong>函数获取handler的关联执行器。例如：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boost::asio::associated_executor_t&lt;Handler&gt; a &#x3D; boost::asio::get_associated_executor(h);</span><br></pre></td></tr></table></figure>
通过指定<strong>嵌套类型executor_type</strong>和<strong>成员函数get_executor()</strong>，可以针对特定处理程序类型自定义执行器：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class my_handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  &#x2F;&#x2F; Custom implementation of Executor type requirements.</span><br><span class="line">  typedef my_executor executor_type;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return a custom executor implementation.</span><br><span class="line">  executor_type get_executor() const noexcept</span><br><span class="line">  &#123;</span><br><span class="line">    return my_executor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void operator()() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在更复杂的情况下，associated_executor模板可能直接<strong>偏特化</strong>（partially
specialised）：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct my_handler</span><br><span class="line">&#123;</span><br><span class="line">  void operator()() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">namespace boost &#123; namespace asio &#123;</span><br><span class="line"></span><br><span class="line">  template &lt;class Executor&gt;</span><br><span class="line">  struct associated_executor&lt;my_handler, Executor&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; Custom implementation of Executor type requirements.</span><br><span class="line">    typedef my_executor type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Return a custom executor implementation.</span><br><span class="line">    static type get(const my_handler&amp;,</span><br><span class="line">        const Executor&amp; &#x3D; Executor()) noexcept</span><br><span class="line">    &#123;</span><br><span class="line">      return my_executor();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125; &#125; &#x2F;&#x2F; namespace boost::asio</span><br></pre></td></tr></table></figure></p>
<p>boost::asio::bind_executor()函数用于绑定特殊executor对象（如一个strand）到completion
handler。例如：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_socket.async_read_some(my_buffer,</span><br><span class="line">    boost::asio::bind_executor(my_strand,</span><br><span class="line">      [](error_code ec, size_t length) &#x2F;&#x2F; 这是个lambda函数</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">      &#125;));</span><br></pre></td></tr></table></figure></p>
<h2><span id="buffers">Buffers</span><a href="#buffers" class="header-anchor">#</a></h2>
<p>I/O
涉及数据<strong>在内存的连续区域</strong>（称为缓冲区）之间传输，这些缓冲区可以简单地表示为<strong>由指针和字节大小组成的元组</strong>。为了开发高效的网络应用程序，Boost.Asio
包括对<strong>分散收集(scatter-gather)</strong>操作的支持：</p>
<ul>
<li>散点读取(scatter-read)将数据<strong>接收到多个缓冲区</strong>中。</li>
<li>收集写入(gather-write)<strong>传输多个缓冲区</strong>。</li>
</ul>
<p>除了将缓冲区指定为指针和大小（以字节为单位）之外，Boost.Asio
还区分了可修改内存（称为mutable）和非可修改内存（其中后者从存储中创建为
const 限定变量）。因此，这两种类型可以定义如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef std::pair&lt;void*, std::size_t&gt; mutable_buffer;</span><br><span class="line">typedef std::pair&lt;const void*, std::size_t&gt; const_buffer;</span><br></pre></td></tr></table></figure>
mutable_buffer 可以转换为const_buffer，反之不行。</p>
<p>但是，Boost.Asio
没有使用上述定义，而是<strong>定义两个类：mutable_buffer和const_buffer</strong>。这个目的是提供连续内存的不透明表示形式，其中：</p>
<ul>
<li>转换行为与std::pair一样：mutable_buffer可单向转换为const_buffer，反之不行。</li>
<li>有缓冲区<strong>溢出保护</strong>。给定一个缓冲区实例，用户只能创建另一个表示相同内存范围或其子范围的缓冲区。为了提供进一步的安全性，库还包括用于从
POD
元素的数组、boost::array或std::vector或std::string自动确定缓冲区大小的机制。</li>
<li>使用<strong>data()</strong>成员函数<strong>显式访问底层内存</strong>。通常应用程序不需要这样做，但库实现需要将原始内存传递给<strong>底层操作系统函数</strong>。</li>
</ul>
<p>最后，通过将<strong>缓冲区对象放入容器</strong>中，可以将多个缓冲区传递给scatter-gather操作（如read()或
write()）。MutableBufferSequence和ConstBufferSequence概念已经定义好，这样就可以使用诸如std::vector、std::list、std::array或boost::array之类的容器。</p>
<h4><span id="yu-iostreams-ji-cheng-de-streambuf">与Iostreams集成的Streambuf</span><a href="#yu-iostreams-ji-cheng-de-streambuf" class="header-anchor">#</a></h4>
<p>boost::asio::basic_streambuf 类继承自 std::basic_streambuf，可以将
输入和输出序列（sequence） 关联到一个或多个
<strong>字符串数组对象</strong>，这些元素存储任意值。这些字符数组对象是
<strong>streambuf
对象的内部对象</strong>，但提供了<strong>对数组元素的直接访问</strong>，以允许它们<strong>用于
I/O 操作</strong>，例如套接字的<strong>发送或接收</strong>操作</p>
<h4><span id="huan-chong-xu-lie-de-zi-jie-bian-li">缓冲序列的字节遍历</span><a href="#huan-chong-xu-lie-de-zi-jie-bian-li" class="header-anchor">#</a></h4>
<p>buffers_iterator&lt;&gt;模板类，允许遍历buffer序列（即满足MutableBufferSequence或ConstBufferSequence要求的类型），就好像它们是连续的字节序列一样。还提供了名为buffers_begin()和buffers_end()的help函数。</p>
<p>例如，从socket读取一行，并且转换为string：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boost::asio::streambuf sb;</span><br><span class="line">...</span><br><span class="line">std::size_t n &#x3D; boost::asio::read_until(sock, sb, &#39;\n&#39;);</span><br><span class="line">boost::asio::streambuf::const_buffers_type bufs &#x3D; sb.data();</span><br><span class="line">std::string line(</span><br><span class="line">    boost::asio::buffers_begin(bufs),</span><br><span class="line">    boost::asio::buffers_begin(bufs) + n);</span><br></pre></td></tr></table></figure></p>
<h4><span id="huan-chong-qu-diao-shi">缓冲区调试</span><a href="#huan-chong-qu-diao-shi" class="header-anchor">#</a></h4>
<p>某些标准库的实现（如Microsoft Visual C++ 8.0
和更高版本一起搭载的库）提供了一个称为<strong>迭代器调试</strong>的特性。这意味着在<strong>运行时检查迭代器的有效性</strong>。如果程序尝试使用已失效的迭代器，则会<strong>触发断言</strong>。例如：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; v(1)</span><br><span class="line">std::vector&lt;int&gt;::iterator i &#x3D; v.begin();</span><br><span class="line">v.clear(); &#x2F;&#x2F; invalidates iterators</span><br><span class="line">*i &#x3D; 0; &#x2F;&#x2F; assertion!</span><br></pre></td></tr></table></figure>
Boost.Asio 利用此功能<strong>添加缓冲区调试</strong>。请考虑以下代码：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dont_do_this()</span><br><span class="line">&#123;</span><br><span class="line"> std::string msg &#x3D; &quot;Hello, world!&quot;;</span><br><span class="line"> boost::asio::async_write(sock, boost::asio::buffer(msg), my_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
调用<strong>异步读或写</strong>时，需要<strong>确保操作的缓冲区</strong>在<strong>调用completion
handler之前是有效的</strong>。在上面的示例中，缓冲区是std::string变量msg。这个变量<strong>在栈上(局部变量)</strong>，因此在异步<strong>操作完成之前它就超出了函数的范围（scope）</strong>。如果幸运的话，应用程序会crash，但随机失败的可能性更大。</p>
<p>启用缓冲区调试时，Boost.Asio
将<strong>迭代器存储到字符串</strong>中，直到异步操作完成，然后取消引用以检查其有效性。</p>
<p>此功能对 Microsoft Visual Studio 8.0 或更高版本可用，而 GCC
需要定义了**_GLIBCXX_DEBUG<strong>时才可用。此检查会带来性能开销，因此仅在调试生成中启用缓冲区调试。对于其他编译器，可以通过</strong>定义
BOOST_ASIO_ENABLE_BUFFER_DEBUGGING来启用<strong>它。也可以通过定义
</strong>BOOST_ASIO_DISABLE_BUFFER_DEBUGGING来显式禁用**。</p>
]]></content>
      <categories>
        <category>boost</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>[boost.asio] 4.Overview (2)</title>
    <url>/2021/04/28/boost-asio-4-Overview-2/</url>
    <content><![CDATA[<h2><span id="liu-duan-du-he-duan-xie-streams-short-reads-and-short-writes">流、短读和短写(Streams,
Short Reads and Short Writes)</span><a href="#liu-duan-du-he-duan-xie-streams-short-reads-and-short-writes" class="header-anchor">#</a></h2>
<p>Boost.Asio中許多 I/0对象都是<strong>面向流</strong>的： -
没有消息边界。数据通过连续字节序列传输 -
<strong>读取或写入</strong>操做传输的数据可能<strong>少于请求的字节</strong>。这就叫做
短读(short read) or 短写(short write)。</p>
<p>提供面向流的I/O模型满足一个或多个如下要求： -
SyncReadStream，使用read_some()的成员函数执行。 -
AsyncReadStream，使用async_read_some()的成员函数执行。 -
SyncWriteStream，使用write_some()的成员函数执行。 -
AsyncWriteStream，使用async_write_some()的成员函数执行。</p>
<p>面向流的I/O对象有：ip::tcp::socket, ssl::stream&lt;&gt;,
posix::stream_descriptor, windows::stream_handle 等</p>
<p>当短读(short read) or 短写(short
write)出现时，程序必须重新启动操作，直到传输了所需的字数。Boost.Asio
提供自动执行此操作的常规函数：read()、async_read()、write()和async_write()。</p>
<h4><span id="why-eof-is-an-error">Why EOF is an Error</span><a href="#why-eof-is-an-error" class="header-anchor">#</a></h4>
<ul>
<li>stream结束符可以导致 read, async_read, read_until or
async_read_until函数终止。例如，由于 EOF，读取 N
个字节可能会提前完成。</li>
<li>EOF 错误可用于区分流的末尾和大小为 0 的成功读取。</li>
</ul>
<h2><span id="reactor-shi-cao-zuo-reactor-style-operations">Reactor式操作（Reactor-Style
Operations）</span><a href="#reactor-shi-cao-zuo-reactor-style-operations" class="header-anchor">#</a></h2>
<p>有时需要集成使用自定义I/0操作的第三方库。Boost.Asio
包括同步和异步操作，这些操作可用于等待socket准备好读取、准备写入或出现挂起的错误情况。下面是一个非阻塞读的例子：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip::tcp::socket socket(my_io_context);</span><br><span class="line">...</span><br><span class="line">socket.non_blocking(true);</span><br><span class="line">...</span><br><span class="line">socket.async_wait(ip::tcp::socket::wait_read, read_handler);</span><br><span class="line">...</span><br><span class="line">void read_handler(boost::system::error_code ec)</span><br><span class="line">&#123;</span><br><span class="line">  if (!ec)</span><br><span class="line">  &#123;</span><br><span class="line">    std::vector&lt;char&gt; buf(socket.available());</span><br><span class="line">    socket.read_some(buffer(buf));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这些操作支持<strong>所有平台的socket</strong>，以及 POSIX
的面向流的描述符类。</p>
<h2><span id="ji-yu-xing-de-cao-zuo-line-based-operations">基于行的操作(Line-Based
Operations)</span><a href="#ji-yu-xing-de-cao-zuo-line-based-operations" class="header-anchor">#</a></h2>
<p>许多常用的 internet
协议是基于行的，它们具有由<strong>字符序列“”分隔</strong>的元素，如
HTTP、SMTP 和 FTP。为了更容易地实现基于行的协议，Boost.Asio 提供了函数
read_until()和async_read_until()。 如下是在一个HTTP服务器使用
async_read_until() 的例子：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class http_connection</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    boost::asio::async_read_until(socket_, data_, &quot;\r\n&quot;,</span><br><span class="line">        boost::bind(&amp;http_connection::handle_request_line, this, _1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void handle_request_line(boost::system::error_code ec)</span><br><span class="line">  &#123;</span><br><span class="line">    if (!ec)</span><br><span class="line">    &#123;</span><br><span class="line">      std::string method, uri, version;</span><br><span class="line">      char sp1, sp2, cr, lf;</span><br><span class="line">      std::istream is(&amp;data_);</span><br><span class="line">      is.unsetf(std::ios_base::skipws);</span><br><span class="line">      is &gt;&gt; method &gt;&gt; sp1 &gt;&gt; uri &gt;&gt; sp2 &gt;&gt; version &gt;&gt; cr &gt;&gt; lf;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  boost::asio::ip::tcp::socket socket_;</span><br><span class="line">  boost::asio::streambuf data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
streambuf数据成员用作存储在搜索<strong>分隔符（delimiter）之前</strong>从套接字读取的数据的位置。<strong>分隔符后可能还有其他数据</strong>。剩余的数据应该<strong>留在streambuf中</strong>，以便后续的read_until()或async_read_until()处理。</p>
<p><strong>分隔符</strong>可以指定为单个<strong>char、std::string或boost::regex</strong>。read_until()和async_read_until()函数还接受称为match
condition的用户自定义函数对象的重载。例如，将数据读取到streambuf，直到遇到空白：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef boost::asio::buffers_iterator&lt;</span><br><span class="line">    boost::asio::streambuf::const_buffers_type&gt; iterator;</span><br><span class="line"></span><br><span class="line">std::pair&lt;iterator, bool&gt; match_whitespace(iterator begin, iterator end)</span><br><span class="line">&#123;</span><br><span class="line">  iterator i &#x3D; begin;</span><br><span class="line">  while (i !&#x3D; end)</span><br><span class="line">    if (std::isspace(*i++))</span><br><span class="line">      return std::make_pair(i, true);</span><br><span class="line">  return std::make_pair(i, false);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">boost::asio::streambuf b;</span><br><span class="line">boost::asio::read_until(s, b, match_whitespace);</span><br></pre></td></tr></table></figure>
要将数据读取到streambuf中，直到找到匹配的字符：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class match_char</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  explicit match_char(char c) : c_(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename Iterator&gt;std::pair&lt;Iterator, bool&gt; operator()(</span><br><span class="line">      Iterator begin, Iterator end) const</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator i &#x3D; begin;</span><br><span class="line">    while (i !&#x3D; end)</span><br><span class="line">      if (c_ &#x3D;&#x3D; *i++)</span><br><span class="line">        return std::make_pair(i, true);</span><br><span class="line">    return std::make_pair(i, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  char c_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">namespace boost &#123; </span><br><span class="line">    namespace asio &#123;</span><br><span class="line">        template &lt;&gt; struct is_match_condition&lt;match_char&gt;: public boost::true_type &#123;&#125;;</span><br><span class="line">&#125; &#125; &#x2F;&#x2F; namespace boost::asio</span><br><span class="line">...</span><br><span class="line">boost::asio::streambuf b;</span><br><span class="line">boost::asio::read_until(s, b, match_char(&#39;a&#39;));</span><br></pre></td></tr></table></figure>
对于函数和typedef的嵌套<strong>result_type类型</strong>的函数对象，is_match_condition&lt;&gt;类型特征会自动计算为
true。对于其他类型的特征必须显示特化（explicitly specialised）。</p>
<h2><span id="zi-ding-yi-nei-cun-fen-pei-custom-memory-allocation">自定义内存分配(Custom
Memory Allocation)</span><a href="#zi-ding-yi-nei-cun-fen-pei-custom-memory-allocation" class="header-anchor">#</a></h2>
<p>许多异步操作需要分配一个对象去存储操作的状态。
另外，程序中包含了易于识别的异步操作链。
半双工协议（如HTTP服务器）对每个客户端连接维护一个有单向操作链（先接收后发送）。
全双工协议有两条并行的链。程序应该能够根据这些特性，为链中的所有异步操作重用这些内存。</p>
<p>对于用户自定义的Handler对象的副本
h，若需要分配与该处理程序关联的内存，这将有一个使用<strong>get_associated_allocator</strong>的分配器（allocator）。例如
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boost::asio::associated_allocator_t&lt;Handler&gt; a &#x3D; boost::asio::get_associated_allocator(h);</span><br></pre></td></tr></table></figure>
默认情况下，处理程序使用标准分配器（按照::operator new()和::operator
delete()实现）。可以通过<strong>指定嵌套类型allocator_type</strong>和成员函数<strong>get_allocator()</strong>，为特定处理程序类型<strong>自定义分配器</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class my_handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  &#x2F;&#x2F; Custom implementation of Allocator type requirements.</span><br><span class="line">  typedef my_allocator allocator_type;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return a custom allocator implementation.</span><br><span class="line">  allocator_type get_allocator() const noexcept</span><br><span class="line">  &#123;</span><br><span class="line">    return my_allocator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void operator()() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在更复杂的情况下，associated_allocator模板可能直接偏特化(partially
specialised)：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace boost &#123; namespace asio &#123;</span><br><span class="line">  template &lt;typename Allocator&gt; struct associated_allocator&lt;my_handler, Allocator&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; Custom implementation of Allocator type requirements.</span><br><span class="line">    typedef my_allocator type;</span><br><span class="line">    &#x2F;&#x2F; Return a custom allocator implementation.</span><br><span class="line">    static type get(const my_handler&amp;, const Allocator&amp; a &#x3D; Allocator()) noexcept</span><br><span class="line">    &#123;</span><br><span class="line">      return my_allocator();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; &#125; &#x2F;&#x2F; namespace boost::asio</span><br></pre></td></tr></table></figure>
- 这保证了释放将在调用associated
handler之前发生，这意味着内存已经<strong>准备好被重用</strong>于handler启动的任何新的异步操作。</p>
<ul>
<li>该实现保证，对于库中包含的异步操作，该实现<strong>不会对内存分配函数进行并发调用</strong>。如果需要从不同线程调用分配函数，将插入<strong>适当的内存屏障</strong>，以确保内存正确。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>[c++11] 2.可变参数模板</title>
    <url>/2021/04/13/c-11-2-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2>
<p>C++11的新特性--<strong>可变模版参数（variadic
templates）</strong>是C++11新增的最强大的特性之一，它对参数进行了高度泛化,表示<strong>0到任意个数、任意类型的参数</strong>.
<a id="more"></a></p>
<h2><span id="ke-bian-mo-ban-can-shu-han-shu">可变模版参数函数</span><a href="#ke-bian-mo-ban-can-shu-han-shu" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class... T&gt;</span><br><span class="line">void f(T... args) </span><br><span class="line">&#123; &#x2F;&#x2F;可以传任意类型和个数的参数给函数f  </span><br><span class="line">    cout &lt;&lt; sizeof...(args) &lt;&lt; endl; &#x2F;&#x2F;打印变参的个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();        &#x2F;&#x2F;0</span><br><span class="line">f(1, 2);    &#x2F;&#x2F;2</span><br><span class="line">f(1, 2.5, &quot;&quot;);    &#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>
<h4><span id="di-gui-han-shu-fang-shi-zhan-kai-can-shu-bao">递归函数方式展开参数包</span><a href="#di-gui-han-shu-fang-shi-zhan-kai-can-shu-bao" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;递归终止函数</span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;展开函数</span><br><span class="line">template &lt;class T, class ...Args&gt;</span><br><span class="line">void print(T head, Args... rest)</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;parameter &quot; &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">   print(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   print(1,2,3,4);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="dou-hao-biao-da-shi-zhan-kai-can-shu-bao">逗号表达式展开参数包</span><a href="#dou-hao-biao-da-shi-zhan-kai-can-shu-bao" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">void printarg(T t)</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class ...Args&gt;</span><br><span class="line">void expand(Args... args)</span><br><span class="line">&#123;</span><br><span class="line">   int arr[] &#x3D; &#123;(printarg(args), 0)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expand(1,2,3,4);</span><br></pre></td></tr></table></figure>
<p>这种展开参数包的方式，<strong>不需要通过递归终止函数</strong>，是直接在expand函数体中展开的,
printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。这种就地展开参数包的方式实现的关键是<strong>逗号表达式</strong>。我们知道逗号表达式会按顺序执行逗号前面的表达式，比如：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; (a &#x3D; b, c); </span><br></pre></td></tr></table></figure>
这个表达式会按顺序执行：<strong>b会先赋值给a</strong>，接着括号中的<strong>逗号表达式返回c的值</strong>，因此<strong>d将等于c</strong>。</p>
<p>expand函数中的逗号表达式：(printarg(args),
0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组,
{(printarg(args), 0)...}将会展开成
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )</span><br></pre></td></tr></table></figure>
最终会创建一个元素值 <strong>都为0的数组int
arr[sizeof...(Args)]</strong>。由于是逗号表达式，在创建数组的过程中会<strong>先执行逗号表达式前面的部分printarg(args)</strong>打印出参数，也就是说<strong>在构造int数组的过程中就将参数包展开了</strong>，这个数组的目的<strong>纯粹是为了在数组构造的过程展开参数包</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class F, class... Args&gt;</span><br><span class="line">void expand(const F&amp; f, Args&amp;&amp;...args) </span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class="line">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line">expand([](int i)&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;, 1,2,3);</span><br></pre></td></tr></table></figure>
## reference 1.<a href="https://en.cppreference.com/w/cpp/language/parameter_pack">type
... Args(optional)</a> 2.<a href="https://www.cnblogs.com/qicosmos/p/4325949.html">泛化之美--C++11可变模版参数的妙用</a></p>
]]></content>
      <categories>
        <category>c++11</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>[c++11] 3.std::move和std::forward</title>
    <url>/2021/04/13/c-11-3-std-move%E5%92%8Cstd-forward/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>[c#]c#中的Lazy</title>
    <url>/2020/08/15/c-c-%E4%B8%AD%E7%9A%84Lazy/</url>
    <content><![CDATA[<h2><span id="xian-cheng-an-quan-dan-li-zui-jia-shi-jian-c-zhong-de-lazy-shi-ru-he-bao-zheng-xian-cheng-an-quan-de">线程安全单例最佳实践，C#中的Lazy是如何保证线程安全的</span><a href="#xian-cheng-an-quan-dan-li-zui-jia-shi-jian-c-zhong-de-lazy-shi-ru-he-bao-zheng-xian-cheng-an-quan-de" class="header-anchor">#</a></h2>
<p>在.NET 4.0之后，.NET
Framework中提供了一种<strong>安全的延迟加载类型Lazy</strong>。Lazy能够<strong>在多线程环境下，保证GetValue函数只执行一次</strong>，从而实现单例模式。</p>
<p>在过去，实现单例模式我们通常使用二次判断锁，或者利用类的静态初始化函数利用Lazy类型，能够简化这一过程，并且性能上更好。</p>
<p>Lazy创建的时候可以指定线程安装模式，目前有两种模式，<strong>PublicationOnly，ExcutionAndPublication。</strong></p>
<p><strong>延迟初始化，在第一次使用该对象时再对其进行初始化，如果没有用到则不需要进行初始化,这样的话，使用延迟初始化就提高程序的效率，从而使程序占用更少的内存。</strong></p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%">
</colgroup>
<tbody>
<tr>
<td>#### PublicationOnly模式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boxed &#x3D; CreateValue(); &#x2F;&#x2F;1</span><br><span class="line">if (boxed &#x3D;&#x3D; null ||</span><br><span class="line">  &#x2F;&#x2F;比较m_boxed与null，如果不相等，什么都不做；如果m_boxed与null相等，则用boxed替换m_boxed的值。</span><br><span class="line">   &#x2F;&#x2F;无论比较结果相等与否，返回值都是m_boxed中原有的值。</span><br><span class="line">    Interlocked.CompareExchange(ref m_boxed, boxed, null) !&#x3D; null) &#x2F;&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line">    boxed &#x3D; (Boxed)m_boxed; &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    m_valueFactory &#x3D; ALREADY_INVOKED_SENTINEL; &#x2F;&#x2F;4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr>
<td>1.
运行<strong>初始化函数，装箱到一个内部Box类型中，解决null值判断的问题</strong>，如果已经创建的情况，会返回null，该过程是线程不安全的</td>
</tr>
<tr>
<td>2.
判断m_boxed是否为空，m_boxed是value保存的字段，如果等于空则设置为boxed，该方法能保证原子性，该过程是线程安全的</td>
</tr>
<tr>
<td>3.
如果<strong>CreateValue返回空，表示其他线程已经创建有实例，则设置为已经创建好的实例</strong></td>
</tr>
<tr>
<td>4.
将初始化方法标记为已经初始化，一般发生在并发运行情况下，多次运行CreateValue</td>
</tr>
<tr>
<td><strong>PublicationOnly模式下使用基于Interlocked.CompareExchange（原子性运算）实现的乐观锁</strong>，该类包含了原子性方法
CAS(Compare and swap)</td>
</tr>
<tr>
<td><strong>CAS</strong>是利用CPU提供的原子性指令来实现，不同运行时版本可能有不一样实现。Interlocked具体的实现在Native方法中，有兴趣的朋友可以通过coreclr/jvm代码查看具体实现</td>
</tr>
<tr>
<td>这种模式下，单例函数可能多次运行，但是最终能保证获取到的实例只有一个</td>
</tr>
</tbody>
</table>
<h4><span id="excutionandpublication-mo-shi">ExcutionAndPublication模式</span><a href="#excutionandpublication-mo-shi" class="header-anchor">#</a></h4>
<p><strong>ExcutionAndPublication模式下使用的是Volatile+Monitor</strong>，Monitor就是lock语句的实现，Monitor实现在Native代码中，是重量级的锁</p>
<p>Monitor支持<strong>队列和线程睡眠</strong>，能够保证一<strong>整个方法块处于单线程执行状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object threadSafeObj &#x3D; Volatile.Read(ref m_threadSafeObj); &#x2F;&#x2F;强制从主内存空间同步变量到线程内存空间副本</span><br><span class="line">bool lockTaken &#x3D; false;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    if (threadSafeObj !&#x3D; (object)ALREADY_INVOKED_SENTINEL) &#x2F;&#x2F;此时会有多个线程获取到正确值，抢夺开始</span><br><span class="line">        Monitor.Enter(threadSafeObj, ref lockTaken); &#x2F;&#x2F;尝试等待锁，进入成功设置lockTaken为true</span><br><span class="line">    else</span><br><span class="line">        Contract.Assert(m_boxed !&#x3D; null);</span><br><span class="line">　　　　　　　　　　　 &#x2F;&#x2F;单线程代码块 Start</span><br><span class="line">    if (m_boxed &#x3D;&#x3D; null) &#x2F;&#x2F;没有设置值的情况</span><br><span class="line">    &#123;</span><br><span class="line">        boxed &#x3D; CreateValue(); &#x2F;&#x2F;获取值</span><br><span class="line">        m_boxed &#x3D; boxed; &#x2F;&#x2F;设置到字段中</span><br><span class="line">        Volatile.Write(ref m_threadSafeObj, ALREADY_INVOKED_SENTINEL); &#x2F;&#x2F;强制将线程内存空间副本写入到主内存空间</span><br><span class="line">    &#125;</span><br><span class="line">    else &#x2F;&#x2F; got the lock but the value is not null anymore, check if it is created by another thread or faulted and throw if so</span><br><span class="line">    &#123;</span><br><span class="line">        boxed &#x3D; m_boxed as Boxed;</span><br><span class="line">        if (boxed &#x3D;&#x3D; null) &#x2F;&#x2F; it is not Boxed, so it is a LazyInternalExceptionHolder</span><br><span class="line">        &#123;</span><br><span class="line">            LazyInternalExceptionHolder exHolder &#x3D; m_boxed as LazyInternalExceptionHolder;</span><br><span class="line">            Contract.Assert(exHolder !&#x3D; null);</span><br><span class="line">            exHolder.m_edi.Throw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">　　　　　　　　　　　　&#x2F;&#x2F;单线程代码块End</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    if (lockTaken) &#x2F;&#x2F;进入成功需要释放，避免死锁</span><br><span class="line">        Monitor.Exit(threadSafeObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>[c#]c#中单例模式的实现</title>
    <url>/2020/08/13/c-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id="c-zhong-dan-li-mo-shi-de-shi-xian">c#中单例模式的实现</span><a href="#c-zhong-dan-li-mo-shi-de-shi-xian" class="header-anchor">#</a></h2>
<p>本质上，单例模式是一个<strong>只允许创建一个实例，并提供对这个实例简单的访问途径的类</strong>。一般而言，单例模式在创建实例时<strong>不允许传递任何参数</strong>,否则不同参数导致不同的实例创建,就会出现问题！（如果同一个实例可以被同参的不同请求所访问，那么工厂模式会更适合。）只有在第一次被用到的时候才会被创建。在C#中有实现单例模式有很多种方法。我展示如下三个版本：从<strong>线程不安全的到简单线程安全的、再到简洁高效的版本</strong>。所有的这些实现都有以下四个特征：</p>
<ol type="1">
<li>只有一个构造函数，而且是<strong>私有的，不带参数的</strong>。这是为了防止其他类对其实例化,同时也防止了子类化－－如果一个单例能被子类化
一次，就能被子类化两次，而如果每个子类可以创建一个实例，这与模式本身又产生了冲突。如果你（遇到这样的情况）：只有在运行期才能知道实际的类型，因此需要一个父类的单例，可以使用<strong>工厂模式。</strong></li>
<li>类是<strong>密封的（即不可以被继承的类）</strong>。这并不是必须的，严格的说，即如上一点所说的原因，可以提高JIT（Just-In-Time
, 运行时编译执行的技术）的效率。</li>
<li>一个<strong>静态变量用来保存单例的引用</strong>。</li>
<li>一个<strong>用以访问单例引用的公用静态方法</strong>。</li>
</ol>
<h5><span id="ban-ben-1-fei-xian-cheng-an-quan">版本1－非线程安全</span><a href="#ban-ben-1-fei-xian-cheng-an-quan" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; Bad code! Do not use!</span><br><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    static Singleton instance&#x3D;null;</span><br><span class="line">    Singleton()</span><br><span class="line">     &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton Instance</span><br><span class="line">     &#123;</span><br><span class="line">        get</span><br><span class="line">         &#123;</span><br><span class="line">            if (instance&#x3D;&#x3D;null)</span><br><span class="line">             &#123;</span><br><span class="line">                instance &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>两个线程可能同时判断“if
(instance==null)”，发现为TRUE,于是都创建了实例，这又违背了单例模式。无法确保只能让一个线程使对象实例化</strong></p>
<h5><span id="ban-ben-2-jian-dan-de-xian-cheng-an-quan">版本2－ 简单的线程安全</span><a href="#ban-ben-2-jian-dan-de-xian-cheng-an-quan" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    static Singleton instance&#x3D;null;</span><br><span class="line"></span><br><span class="line">    static readonly object padlock &#x3D; new object();</span><br><span class="line">    Singleton()</span><br><span class="line">     &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;每次访问的时候都要进行锁定</span><br><span class="line">    public static Singleton Instance</span><br><span class="line">     &#123;</span><br><span class="line">        get</span><br><span class="line">         &#123;</span><br><span class="line">           &#x2F;&#x2F;共用的对象进行锁定，然后判断实例是否在之前已经创建。</span><br><span class="line">            lock (padlock)</span><br><span class="line">             &#123;</span><br><span class="line">                if (instance&#x3D;&#x3D;null)</span><br><span class="line">                 &#123;</span><br><span class="line">                    instance &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">                return instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现是<strong>线程安全的。线程首先对共用的对象进行锁定</strong>，然后判断实例是否在之前已经创建。不幸的是，由于在<strong>每次访问的时候都要进行锁定</strong>，所以<strong>影响了性能</strong>。（这对于多
线程并发的高性能要求的应用显得尤为重要）。对那些可被其他类访问的对象进行锁定或对类型进行锁定<strong>会导致性能问题甚至引起死锁</strong>。</p>
<h5><span id="ban-ben-3-yong-shuang-chong-jian-ce-ji-zhi-de-cuo-wu-ban-ben-mei-yong-gong-yong-zhi-du-dui-xiang">版本3－
用双重检测机制的错误版本（没用公用只读对象）</span><a href="#ban-ben-3-yong-shuang-chong-jian-ce-ji-zhi-de-cuo-wu-ban-ben-mei-yong-gong-yong-zhi-du-dui-xiang" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;sealed关键字，表示不能被继承</span><br><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    static Singleton instance&#x3D;null;</span><br><span class="line">    Singleton()</span><br><span class="line">     &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton Instance</span><br><span class="line">     &#123;</span><br><span class="line">        get</span><br><span class="line">         &#123;</span><br><span class="line">          &#x2F;&#x2F;先判断是否存在单例</span><br><span class="line">            if (instance&#x3D;&#x3D;null)</span><br><span class="line">             &#123;</span><br><span class="line">                lock (instance)</span><br><span class="line">                 &#123;</span><br><span class="line">                    if (instance&#x3D;&#x3D;null)</span><br><span class="line">                     &#123;</span><br><span class="line">                        instance &#x3D; new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是错误的，在c#中，lock空指针会报错。</p>
<h5><span id="ban-ben-4-yong-shuang-chong-jian-ce-ji-zhi-de-xian-cheng-an-quan">版本4－
用双重检测机制的线程安全</span><a href="#ban-ben-4-yong-shuang-chong-jian-ce-ji-zhi-de-xian-cheng-an-quan" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;sealed关键字，表示不能被继承</span><br><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    static Singleton instance&#x3D;null;</span><br><span class="line">    static readonly object padlock &#x3D; new object();</span><br><span class="line">    Singleton()</span><br><span class="line">     &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton Instance</span><br><span class="line">     &#123;</span><br><span class="line">        get</span><br><span class="line">         &#123;</span><br><span class="line">             &#x2F;&#x2F;先判断是否存在单例</span><br><span class="line">            if (instance&#x3D;&#x3D;null)</span><br><span class="line">             &#123;</span><br><span class="line">                lock (padlock)</span><br><span class="line">                 &#123;</span><br><span class="line">                    if (instance&#x3D;&#x3D;null)</span><br><span class="line">                     &#123;</span><br><span class="line">                        instance &#x3D; new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现是<strong>线程安全的。线程先判断是否存在单例，不存在实例才对共用的对象进行锁定</strong>，然后判断实例是否在之前已经创建。看似看似没有问题，但却会引发另一个问题，这个问题由指令重排序引起。指令重排序是为了优化指令，提高程序运行效率。<strong>指令重排序</strong>包括<strong>编译器重排序和运行时重排序</strong>。例如
instance = new Singleton() 可分解为如下伪代码：</p>
<p><strong>排序前</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory &#x3D; allocate();   &#x2F;&#x2F;1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory);  &#x2F;&#x2F;2：初始化对象</span><br><span class="line">instance &#x3D; memory;     &#x2F;&#x2F;3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure></p>
<p><strong>排序后</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory &#x3D; allocate();   &#x2F;&#x2F;1：分配对象的内存空间</span><br><span class="line">instance &#x3D; memory;     &#x2F;&#x2F;3：设置instance指向刚分配的内存地址</span><br><span class="line">                       &#x2F;&#x2F;注意，此时对象还没有被初始化！</span><br><span class="line">ctorInstance(memory);  &#x2F;&#x2F;2：初始化对象</span><br></pre></td></tr></table></figure>
由于并行执行，则线程A执行了<strong>instance =
memory然后线程B检查到instance不为null</strong>，则<strong>会使用未经实例化完全的对象进行操作</strong>，引发错误。</p>
<h4><span id="ban-ben-5-yong-shuang-chong-jian-ce-ji-zhi-de-xian-cheng-an-quan-jia-ru-volatile">版本5－
用双重检测机制的线程安全(加入volatile)</span><a href="#ban-ben-5-yong-shuang-chong-jian-ce-ji-zhi-de-xian-cheng-an-quan-jia-ru-volatile" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Bad code! Do not use!</span><br><span class="line"></span><br><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private volatile static Singleton instance &#x3D; null;&#x2F;&#x2F;volatile 可以禁止</span><br><span class="line">    private static readonly object padlock &#x3D; new object();</span><br><span class="line"></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (instance &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (padlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance &#x3D;&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance &#x3D; new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volatile表明<strong>属性将被多个线程同时访问，告知编译器不要按照单线程访问的方式去优化该字段</strong>，线程会<strong>监听字段变更，但是不保证字段访问总是顺序执行</strong>。</p>
<h4><span id="ban-ben-6-xian-cheng-an-quan-bi-mian-shi-li-chuang-jian-he-yin-yong-fu-zhi-hun-luan">版本6－
线程安全，避免实例创建和引用赋值混乱</span><a href="#ban-ben-6-xian-cheng-an-quan-bi-mian-shi-li-chuang-jian-he-yin-yong-fu-zhi-hun-luan" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static Singleton instance &#x3D; null;&#x2F;&#x2F;volatile 可以禁止</span><br><span class="line">    private static readonly object padlock &#x3D; new object();</span><br><span class="line"></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (instance &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (padlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance &#x3D;&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var tmp&#x3D; new Singleton();</span><br><span class="line">                        &#x2F;&#x2F; ensures that the instance is well initialized,</span><br><span class="line">                       &#x2F;&#x2F; and only then, it assigns the static variable.</span><br><span class="line">                        System.Threading.Thread.MemoryBarrier();</span><br><span class="line">                       instance &#x3D; tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>官方文档是说Thread.MemoryBarrier()，保证之前的数据存取优先于MemoryBarrier执行，只有在多CPU下才需要使用</strong></p>
<h4><span id="ban-ben-7-bu-yong-suo-shi-xian-xian-cheng-an-quan-bu-quan-shi-yan-shi-chu-shi-hua">版本7－
不用锁实现线程安全，不全是延时初始化</span><a href="#ban-ben-7-bu-yong-suo-shi-xian-xian-cheng-an-quan-bu-quan-shi-yan-shi-chu-shi-hua" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static readonly Singleton instance &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Explicit static constructor to tell C# compiler</span><br><span class="line">    &#x2F;&#x2F; not to mark type as beforefieldinit</span><br><span class="line">    static Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C＃中的<strong>静态构造函数被指定仅在创建类的实例或引用静态成员时执行</strong>，并且<strong>每个AppDomain只执行一次</strong>，所以是<strong>延时初始化</strong>，但是当Singleton有多个静态属性，且<strong>其他的属性被访问时，实例也会被初始化，所以不是完全的延时初始化方式</strong>。</p>
<h4><span id="ban-ben-8-bu-yong-suo-shi-xian-xian-cheng-an-quan-bu-quan-shi-yan-shi-chu-shi-hua">版本8－
不用锁实现线程安全，不全是延时初始化</span><a href="#ban-ben-8-bu-yong-suo-shi-xian-xian-cheng-an-quan-bu-quan-shi-yan-shi-chu-shi-hua" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton Instance &#123; get &#123; return Nested.instance; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    private class Nested</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Explicit static constructor to tell C# compiler</span><br><span class="line">        &#x2F;&#x2F; not to mark type as beforefieldinit</span><br><span class="line">        static Nested()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        internal static readonly Singleton instance &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有<strong>当Nested类的第一个引用调用时，Singleton才会被实例化</strong>，也就是调用Instance，是<strong>完全的延时初始化</strong>。</p>
<h4><span id="ban-ben-9-xian-cheng-an-quan-net-4-zhi-hou-zhi-chi">版本9－ 线程安全， .NET
4之后支持</span><a href="#ban-ben-9-xian-cheng-an-quan-net-4-zhi-hou-zhi-chi" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public sealed class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static readonly Lazy&lt;Singleton&gt; lazy &#x3D;</span><br><span class="line">        new Lazy&lt;Singleton&gt;(() &#x3D;&gt; new Singleton());</span><br><span class="line"></span><br><span class="line">    public static Singleton Instance &#123; get &#123; return lazy.Value; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c# 设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[c++]基础知识一</title>
    <url>/2020/12/05/c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/</url>
    <content><![CDATA[<h2><span id="gou-zao-han-shu">构造函数</span><a href="#gou-zao-han-shu" class="header-anchor">#</a></h2>
<ol type="1">
<li>函数名与类名相同</li>
<li>不能定义返回值，也不能有return语句</li>
<li>可以有形式参数，也可以没有</li>
<li>可以是内联函数</li>
<li>可以重载</li>
<li>可以带默认参数值</li>
<li>对象被创建时自动调用</li>
<li>如果不定义构造函数，编译器编译阶段会生成默认构造函数</li>
<li>如果此时希望编译器隐含生成默认构造函数，只需加上=default</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Clock &#123;</span><br><span class="line">public:</span><br><span class="line">    Clock(int h, int m, int s);</span><br><span class="line">   Clock(); &#x2F;&#x2F;默认构造函数</span><br><span class="line">   void setTime(int h, int m, int s);</span><br><span class="line">    void showTime();</span><br><span class="line">private:</span><br><span class="line">    int hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock() : hour(0), minute(0), second(0) &#123;&#125;&#x2F;&#x2F;默认构造函数，用初始化列表，但是没用形参</span><br><span class="line">Clock::Clock(int h,int m,int s):hour(h),minute(m),second(s)&#123;&#125; </span><br><span class="line">&#x2F;&#x2F;用初始列表初始化hour，minute，second三个成员变量，效率高，简单初始化无需写在结构体里面</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  Clock c1(0,1,8); &#x2F;&#x2F;调用构造函数</span><br><span class="line">   Clock c2; &#x2F;&#x2F;调用无参构造函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="wei-tuo-gou-zao-han-shu">委托构造函数</span><a href="#wei-tuo-gou-zao-han-shu" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Clock::Clock(int h,int m,int s):hour(h),minute(m),second(s)&#123;&#125; </span><br><span class="line">Clock::Clock() : hour(0), minute(0), second(0) &#123;&#125;&#x2F;&#x2F;默认构造函数，用初始化列表，但是没用形参</span><br><span class="line"></span><br><span class="line">委托构造函数不仅可以简洁，而且保证代码一致性</span><br><span class="line">Clock::Clock():Clock(0,0,0)&#123;&#125;  &#x2F;&#x2F;默认构造函数用委托构造函数构造</span><br></pre></td></tr></table></figure>
<h3><span id="kao-bei-gou-zao-han-shu">拷贝构造函数</span><a href="#kao-bei-gou-zao-han-shu" class="header-anchor">#</a></h3>
<p>特殊的构造函数，其<strong>形参为本类对象的引用</strong>,
<strong>用一个已存在的对象去初始化同类型的新对象</strong> 1.
定义一个对象，以本类
<strong>另一个对象作为初始值，发送拷贝构造函数</strong> 2.
如果函数的形参时类的对象，调用函数时，将使用实参对象初始化形参对象 3.
如果函数的
<strong>返回值是类的对象，函数执行完返回主调函数时，将使用return语句中的对象初始化一个临时无名对象</strong>，传递给主调i函数
4. C++11用"=delete"指示编译器不生成默认复制构造函数<strong> 5.
</strong>拷贝构造函数是一种特殊的构造函数<strong>，具有
</strong>单个形参<strong>，该形参（常用const修饰）是
</strong>对该类类型的引用<strong>。 6.
当定义一个新对象并用一个同类型的对象对它进行初始化时，将
</strong>显示使用拷贝构造函数<strong>。当该类型的对象传递给函数或从函数返回该类型的对象时，将
</strong>隐式调用拷贝构造函数**。</p>
<p>C++支持两种初始化形式：复制初始化（int a = 5;）和直接初始化（int
a(5);）对于类
<strong>类型直接初始化直接调用实参匹配的构造函数</strong>，<strong>复制初始化总是调用拷贝构造函数</strong>，也就是说：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A x(2);　　&#x2F;&#x2F;直接初始化，调用构造函数</span><br><span class="line">A y &#x3D; x;　　&#x2F;&#x2F;复制初始化，调用拷贝构造函数</span><br></pre></td></tr></table></figure></p>
<p>下面使用上面定义的类对象来说明各个构造函数的用法：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 void main()</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     &#x2F;&#x2F; 调用了无参构造函数，数据成员初值被赋为0.0</span><br><span class="line"> 4     Complex c1，c2;</span><br><span class="line"> 5  </span><br><span class="line"> 6     &#x2F;&#x2F; 调用一般构造函数，数据成员初值被赋为指定值</span><br><span class="line"> 7     Complex c3(1.0,2.5);</span><br><span class="line"> 8     &#x2F;&#x2F; 也可以使用下面的形式</span><br><span class="line"> 9     Complex c3 &#x3D; Complex(1.0,2.5);</span><br><span class="line">10          </span><br><span class="line">11     &#x2F;&#x2F; 把c3的数据成员的值赋值给c1</span><br><span class="line">12     &#x2F;&#x2F; 由于c1已经事先被创建，故此处不会调用任何构造函数</span><br><span class="line">13     &#x2F;&#x2F; 只会调用 &#x3D; 号运算符重载函数</span><br><span class="line">14     c1 &#x3D; c3;</span><br><span class="line">15          </span><br><span class="line">16     &#x2F;&#x2F; 调用类型转换构造函数</span><br><span class="line">17     &#x2F;&#x2F; 系统首先调用类型转换构造函数，将5.2创建为一个本类的临时对象，然后调用等号运算符重载，将该临时对象赋值给c1</span><br><span class="line">18     c2 &#x3D; 5.2;</span><br><span class="line">19        </span><br><span class="line">20     &#x2F;&#x2F; 调用拷贝构造函数( 有下面两种调用方式) </span><br><span class="line">21     Complex c5(c2);</span><br><span class="line">22     Complex c4 &#x3D; c2;  &#x2F;&#x2F; 注意和 &#x3D; 运算符重载区分,这里等号左边的对象不是事先已经创建，故需要调用拷贝构造函数，参数为c2       </span><br><span class="line">23          </span><br><span class="line">24 &#125;</span><br></pre></td></tr></table></figure>
参考：http://www.cnblogs.com/xkfz007/archive/2012/05/11/2496447.html</p>
<h2><span id="shen-kao-bei-he-qian-kao-bei">深拷贝和浅拷贝：</span><a href="#shen-kao-bei-he-qian-kao-bei" class="header-anchor">#</a></h2>
<ol type="1">
<li><p>所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。</p></li>
<li><p>在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间</p></li>
</ol>
<p>如果一个类拥有资源，当这个<strong>类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝</strong></p>
<p>上面提到，如果没有自定义拷贝构造函数，则系统会创建默认的拷贝构造函数，但系统创建的
<strong>默认拷贝构造函数只会执行“浅拷贝”</strong>，即将被拷贝对象的数据成员的值一一赋值给新创建的对象，若该类的数据成员中
<strong>有指针成员，则会使得新的对象的指针所指向的地址与被拷贝对象的指针所指向的地址相同，delete该指针时则会导致两次重复delete而出错</strong>。下面是示例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 #include &lt;iostream.h&gt;</span><br><span class="line"> 2 #include &lt;string.h&gt;</span><br><span class="line"> 3 class Person </span><br><span class="line"> 4 &#123;</span><br><span class="line"> 5 public :</span><br><span class="line"> 6          </span><br><span class="line"> 7     &#x2F;&#x2F; 构造函数</span><br><span class="line"> 8     Person(char * pN)</span><br><span class="line"> 9     &#123;</span><br><span class="line">10         cout &lt;&lt; &quot;一般构造函数被调用 !\n&quot;;</span><br><span class="line">11         m_pName &#x3D; new char[strlen(pN) + 1];</span><br><span class="line">12         &#x2F;&#x2F;在堆中开辟一个内存块存放pN所指的字符串</span><br><span class="line">13         if(m_pName !&#x3D; NULL) </span><br><span class="line">14         &#123;</span><br><span class="line">15            &#x2F;&#x2F;如果m_pName不是空指针，则把形参指针pN所指的字符串复制给它</span><br><span class="line">16              strcpy(m_pName ,pN);</span><br><span class="line">17         &#125;</span><br><span class="line">18     &#125;        </span><br><span class="line">19        </span><br><span class="line">20     &#x2F;&#x2F; 系统创建的默认复制构造函数，只做位模式拷贝</span><br><span class="line">21     Person(Person &amp; p)    </span><br><span class="line">22     &#123; </span><br><span class="line">23         &#x2F;&#x2F;使两个字符串指针指向同一地址位置         </span><br><span class="line">24         m_pName &#x3D; p.m_pName;         </span><br><span class="line">25     &#125;</span><br><span class="line">26  </span><br><span class="line">27     ~Person( )</span><br><span class="line">28     &#123;</span><br><span class="line">29         delete m_pName;</span><br><span class="line">30     &#125;</span><br><span class="line">31          </span><br><span class="line">32 private :</span><br><span class="line">33     char * m_pName;</span><br><span class="line">34 &#125;;</span><br><span class="line">35  </span><br><span class="line">36 void main( )</span><br><span class="line">37 &#123; </span><br><span class="line">38     Person man(&quot;lujun&quot;);</span><br><span class="line">39     Person woman(man); </span><br><span class="line">40      </span><br><span class="line">41     &#x2F;&#x2F; 结果导致   man 和    woman 的指针都指向了同一个地址</span><br><span class="line">42      </span><br><span class="line">43     &#x2F;&#x2F; 函数结束析构时</span><br><span class="line">44     &#x2F;&#x2F; 同一个地址被delete两次</span><br><span class="line">45 &#125;</span><br><span class="line">46  </span><br><span class="line">47  </span><br><span class="line">48 &#x2F;&#x2F; 下面自己设计复制构造函数，实现“深拷贝”，即不让指针指向同一地址，而是重新申请一块内存给新的对象的指针数据成员</span><br><span class="line">49 Person(Person &amp; chs);</span><br><span class="line">50 &#123;</span><br><span class="line">51      &#x2F;&#x2F; 用运算符new为新对象的指针数据成员分配空间</span><br><span class="line">52      m_pName&#x3D;new char[strlen(p.m_pName)+ 1];</span><br><span class="line">53  </span><br><span class="line">54      if(m_pName)         </span><br><span class="line">55      &#123;</span><br><span class="line">56              &#x2F;&#x2F; 复制内容</span><br><span class="line">57             strcpy(m_pName ,chs.m_pName);</span><br><span class="line">58      &#125;</span><br><span class="line">59    </span><br><span class="line">60     &#x2F;&#x2F; 则新创建的对象的m_pName与原对象chs的m_pName不再指向同一地址了</span><br><span class="line">61 &#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="yi-ge-kong-de-class-lei-li-you-shi-me">一个空的class类里有什么?</span><a href="#yi-ge-kong-de-class-lei-li-you-shi-me" class="header-anchor">#</a></h2>
<p>定义一个空类
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
默认会生成以下几个函数 1. 无参的构造函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Empty()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
2. 拷贝构造函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Empty(const Empty&amp; copy)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
3. 赋值运算符
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Empty&amp; operator &#x3D; (const Empty&amp; copy)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
4. 析构函数（非虚）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~Empty()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这些函数只有在第一次使用它们的时候才会生成，他们都是inline并且public的。如果想禁止生成这些函数，可以将它们定义成private函数，如果有很多类都有这种需求，那么可以定义一个基类，然后让其他类继承这个类。
### 空class用法</p>
<p>先假设我们有个很傲娇的类，它不希望通过构造函数生成，也不希望别的对象对它赋值。
然而更加高级的做法是定义一个空类，将空类的复制构造函数和赋值操作符声明为私有，然后让SomeClass继承它。像这样：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    Empty()&#123;&#125;                    &#x2F;&#x2F;允许derived class调用</span><br><span class="line">    ~Empty()&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    Empty(const Empty&amp;);            &#x2F;&#x2F;阻止了copying</span><br><span class="line">    Empty&amp; operator &#x3D; (const Empty&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SomeClass: private Empty</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这些函数只有在第一次使用它们的时候才会生成，他们都是inline并且public的。如果想禁止生成这些函数，可以将它们定义成private函数，如果有很多类都有这种需求，那么可以定义一个基类，然后让其他类继承这个类。</p>
<h2><span id="xu-han-shu-de-zuo-yong-yi-ji-shi-xian-yuan-li">虚函数的作用以及实现原理</span><a href="#xu-han-shu-de-zuo-yong-yi-ji-shi-xian-yuan-li" class="header-anchor">#</a></h2>
<p>链接：https://www.nowcoder.com/questionTerminal/1f67d4e2b6134c298e993e622181b333
#### 虚函数的作用：简单讲即实现多态。
基类定义了虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，且这样的函数调用是无法在编译器期间确认的，而是在运行期确认，也叫做迟绑定。</p>
<p>对于虚函数的支持则分两步完成：</p>
<p><strong>1.每一个class产生一堆指向虚函数的指针，放在表格之中。这个表格称之为虚函数表（virtual
table，vtbl）。</strong></p>
<p><strong>2.每一个对象被添加了一个指针，指向相关的虚函数表vtbl。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的构造函数，析构函数和拷贝赋值运算符自动完成。</strong></p>
<p>另外，虚函数表地址的前面设置了一个指向type_info的指针，RTTI（Run Time
Type
Identification）运行时类型识别是有编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI是为多态而生成的信息，所以只有具有虚函数的对象在会生成。</p>
<p><strong><em>C++中虚函数使用虚函数表和
虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地
址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的
虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处），
它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应
不同基类的虚函数表。</em></strong></p>
<p>简单来讲是多态，也就是允许派生类对象指向基类指针在运行时调用调用派生类的同名函数。
原理：含有虚函数的类对象，在啊创建时会再头部创建一个指针，指向一个虚表，虚表内保存着虚函数的地址，当调用虚函数时，调用指针指向虚表，子啊虚表中找到虚函数的地址。从而实现运行时多态，普通的成员函数地址是固定的，直接调用即可。</p>
<h2><span id="overload-overwrite-ji-override-de-qu-bie">Overload、Overwrite及Override的区别</span><a href="#overload-overwrite-ji-override-de-qu-bie" class="header-anchor">#</a></h2>
<p>Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。
1. 相同的范围（在同一个类中）； 2. 函数名字相同； 3. 参数不同； 4.
virtual 关键字可有可无。</p>
<p>Override(覆盖)：是指派生类函数覆盖基类函数，特征是： 1.
不同的范围（分别位于派生类与基类）； 2. 函数名字相同； 3. 参数相同； 4.
基类函数必须有virtual 关键字。</p>
<p>Overwrite(重写)：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
1.
如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
2.
如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> void F()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;Parent.F()&#x2F;n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void G()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;Parent.G()&#x2F;n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int Add(int x, int y)</span><br><span class="line"> &#123;</span><br><span class="line">        return x + y;</span><br><span class="line"> &#125;</span><br><span class="line">    &#x2F;&#x2F;重载(overload)Add函数</span><br><span class="line"> float Add(float x, float y)</span><br><span class="line">   &#123;</span><br><span class="line">        return x + y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ChildOne:Parent</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;重写(overwrite)父类函数</span><br><span class="line"> void F()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;ChildOne.F()&#x2F;n&quot;); </span><br><span class="line"> &#125;</span><br><span class="line">    &#x2F;&#x2F;覆写(override)父类虚函数,主要实现多态</span><br><span class="line">  void G()</span><br><span class="line">  &#123;</span><br><span class="line">        printf(&quot;ChildOne.G()&#x2F;n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> ChildOne childOne;&#x2F;&#x2F; &#x3D; new ChildOne();</span><br><span class="line"> Parent* p &#x3D; (Parent*)&amp;childOne;</span><br><span class="line">  &#x2F;&#x2F;调用Parent.F()</span><br><span class="line">  p-&gt;F();</span><br><span class="line">    &#x2F;&#x2F;实现多态</span><br><span class="line">  p-&gt;G();</span><br><span class="line">    Parent* p2 &#x3D; new Parent();</span><br><span class="line">   &#x2F;&#x2F;重载(overload)</span><br><span class="line">  printf(&quot;%d&#x2F;n&quot;,p2-&gt;Add(1, 2));</span><br><span class="line">   printf(&quot;%f&#x2F;n&quot;,p2-&gt;Add(3.4f, 4.5f));</span><br><span class="line"> delete p2;</span><br><span class="line">    system(&quot;PAUSE&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="overload-de-hua-zhi-you-han-shu-fan-hui-zhi-lei-xing-bu-tong-hui-chong-zai-ma">overload的话，只有函数返回值类型不同，会重载吗?</span><a href="#overload-de-hua-zhi-you-han-shu-fan-hui-zhi-lei-xing-bu-tong-hui-chong-zai-ma" class="header-anchor">#</a></h2>
<ol type="1">
<li><p>在使用重载时只能通过<strong>不同的参数样式</strong>。例如，<strong>不同的参数类型，不同的参数个数，不同的参数顺序</strong>（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,
float)， 但是不能为fun(int, int)）；</p></li>
<li><p>不能通过访问权限、返回类型、抛出的异常进行重载；</p></li>
<li><p>方法的异常类型和数目不会对重载造成影响；</p></li>
<li><p>对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p></li>
</ol>
<h2><span id="yi-ge-jie-gou-ti-zhong-you-yi-ge-int-yi-ge-char-yi-ge-static-int-wen-zhe-ge-jie-gou-ti-zhan-duo-shao-nei-cun">一个结构体中有一个int，一个char，一个static
int，问这个结构体占多少内存</span><a href="#yi-ge-jie-gou-ti-zhong-you-yi-ge-int-yi-ge-char-yi-ge-static-int-wen-zhe-ge-jie-gou-ti-zhan-duo-shao-nei-cun" class="header-anchor">#</a></h2>
<p>结构体 <strong>内存对齐规则</strong> 结构体所占用的内存
<strong>与其成员在结构体中的声明顺序有关</strong>，其成员的内存对齐规则如下：</p>
<ol type="1">
<li><p>每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。</p></li>
<li><p>复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，可以最小化长度。</p></li>
<li><p>结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。</p></li>
<li><p>计算结构体的内存大小时，应该列出每个成员的偏移地址，则其长度=最后一个成员的偏移地址+最后一个成员数的长度+最后一个成员的调整参数</p></li>
</ol>
<h2><span id="stl-zhong-you-shi-me-lei">STL中有什么类</span><a href="#stl-zhong-you-shi-me-lei" class="header-anchor">#</a></h2>
<p>https://blog.csdn.net/chuanzhouxiao/article/details/51902786
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector 向量 </span><br><span class="line">string 字符串</span><br><span class="line">list 列表</span><br><span class="line">queue 队列</span><br><span class="line">map 映射</span><br><span class="line">set 集合</span><br><span class="line">stack 栈</span><br><span class="line"></span><br><span class="line">map，vector和unordered_map区别及实现原理 </span><br><span class="line">红黑树 hash表 </span><br><span class="line">mysql索引 </span><br><span class="line">tcp三次握手 重传机制 </span><br></pre></td></tr></table></figure>
## 进程数据栈堆</p>
<h3><span id="1-jin-cheng-he-xian-cheng-de-ding-yi">1.进程和线程的定义</span><a href="#1-jin-cheng-he-xian-cheng-de-ding-yi" class="header-anchor">#</a></h3>
<ol type="1">
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</li>
<li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</li>
</ol>
<h3><span id="2-jin-cheng-he-xian-cheng-de-qu-bie">2.进程和线程的区别</span><a href="#2-jin-cheng-he-xian-cheng-de-qu-bie" class="header-anchor">#</a></h3>
<ol type="1">
<li>进程在执行过程中拥有独立的内存单元，而该进程的多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
<li>在很多现代操作系统中，一个进程的（虚）地址空间大小为4G，分为系统（内核？）空间和用户空间两部分，系统空间为所有进程共享，而用户空间是独立的，一般WINDOWS进程的用户空间为2G。</li>
<li>一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)，Windows线程的缺省堆栈大小为1M。堆(heap)的分配与栈有所不同，一般是一个进程有一个C运行时堆，这个堆为本进程中所有线程共享，windows进程还有所谓进程默认堆，用户也可以创建自己的堆。
用操作系统术语，线程切换的时候实际上切换的是一个可以称之为线程控制块的结构（TCB?）,里面保存所有将来用于恢复线程环境必须的信息，包括所有必须保存的寄存器集，线程的状态等。</li>
</ol>
<h3><span id="3-duo-xian-cheng-de-gua-yong-chang-jing-shi-shi-me-wei-sha-yao-yong-duo-xian-cheng">3.多线程的适用场景是什么？为啥要用多线程？</span><a href="#3-duo-xian-cheng-de-gua-yong-chang-jing-shi-shi-me-wei-sha-yao-yong-duo-xian-cheng" class="header-anchor">#</a></h3>
<p>使用多线程是为了
<strong>提高程序运行的效率</strong>。假如有一个程序，要求用户输入多个算式，计算出结果，并分别打印到屏幕上。如果用户一直没有输入，那么无法计算，更无法打印。如果用户输入了，必须要全部输入完，才能计算出结果，再打印到屏幕。
使用线程的话，一个线程用来等待用户输入，一个用来计算结果，一个用来打印。用户在输入算式3的时候，计算线程在计算算式2，打印线程在打印算式1，三个线程同时进行，减少了等待，这样就提高了运行效率</p>
<h3><span id="4-dui-he-zhan">4.堆和栈</span><a href="#4-dui-he-zhan" class="header-anchor">#</a></h3>
<p><strong>堆</strong>：是
<strong>共有的空间，分全局堆和局部堆</strong>。全局堆就是
<strong>所有没有分配的空间</strong>，局部堆就是
<strong>用户分配的空间</strong>。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得
<strong>用完了要还给操作系统，要不然就是内存泄漏</strong>。</p>
<p><strong>栈</strong>：是个
<strong>线程独有的</strong>，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread
safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。
函数调用栈堆</p>
<p>Top N排序 拷贝构造函数 复制构造函数 static 关键字</p>
<h2><span id="yuan-wen-jian-cpp-dao-ke-zhi-xing-wen-jian-exe-de-guo-cheng">源文件cpp到可执行文件exe的过程</span><a href="#yuan-wen-jian-cpp-dao-ke-zhi-xing-wen-jian-exe-de-guo-cheng" class="header-anchor">#</a></h2>
<p>从一个cpp文件到一个exe文件，大概经历了以下过程：</p>
<ol type="1">
<li><p>预处理（preprocessor）
根据预处理命令组装成新的C/C++程序，常以i为扩展名。这个过程包括：宏的替换、删除注释、处理预处理指令（如#include、#ifdef）。</p></li>
<li><p>编译（complier） 将得到的i文件翻译成汇编代码，即.s文件。</p></li>
<li><p>汇编（assembler）
将汇编文件翻译成机器指令，并打包成可重定位目标程序的o文件。该文件是二进制文件，字节编码是机器指令。编译器把一个cpp编译汇编得到目标文件时，除了要在目标文件里写入cpp里包含的数据和代码，还要至少提供3个表：</p></li>
</ol>
<ul>
<li>未解决符号表（unresolved symbol
table）：提供所有在编译单元里引用但定义不在本编译单元里的符号及其出现的地址；</li>
<li>导出符号表（export symbol
table）：提供本编译单元具有定义，且愿意提供给其它编译单元使用的符号及其地址（全局作用域）；</li>
<li>地址重定向表（address redirect
table）：提供本编译单元所有对自身地址的引用的记录。</li>
</ul>
<ol start="4" type="1">
<li>链接（linker）
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或函数调用）或程序中可能调用了某个库文件中的函数。将引用的其它o文件并入到我们程序所在的o文件中并进行处理，方可得到最终的可执行文件。
链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定向表，对其中记录的地址进行重定向（即加上该编译单元实际在可执行文件里的起始地址）。然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上填写实际的地址（也要加上拥有该符号定义的编译单元实际在可执行文件里的起始地址）。最后把所有的目标文件的内容写在各自的位置上，再做一些别的工作，即得到一个可执行文件。
PS：实际链接的时候更为复杂，因为实际的目标文件里把数据或代码分为好几个区，重定向等要按区进行，但原理一样。</li>
</ol>
<ul>
<li>内部链接：一个名称对编译单元（cpp文件）来说是局部的，在链接的时候其它的编译单元无法链接到它；</li>
<li>外部链接：一个名称对编译单元来说不是局部的，在链接的时候其它的编译单元可以访问它，即它可以和别的编译单元交互。</li>
</ul>
<h2><span id="const-he-define">const和define</span><a href="#const-he-define" class="header-anchor">#</a></h2>
<p>const定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量，存放在静态区)，而#define定义的宏常量在内存中有若干个拷贝。
#define宏是在预编译阶段进行替换，而const修饰的只读变量是在编译的时候确定其值。
#define宏没有类型，而const修饰的只读变量具有特定的类型
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int *p;   &#x2F;&#x2F;p可变，p指向的对象不可变</span><br><span class="line">int const*p;  &#x2F;&#x2F;p可变，p指向的对象不可变</span><br><span class="line">int *const p;  &#x2F;&#x2F;p不可变，p指向的对象可变</span><br><span class="line">const int *const p;  &#x2F;&#x2F;指针p和p指向的对象都不可变</span><br></pre></td></tr></table></figure>
总的来说： const：有数据类型，编译进行安全检查，可调试
define:宏，不考虑数据类型，没有安检，不能调试</p>
<p>这里有一个记忆和理解的方法：
先忽略类型名(编译器解析的时候也是忽略类型名)，我们看const离哪个近。"近水楼台先得月"，离谁近就修饰谁。
判断时忽略括号中的类型
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (int) *p;   &#x2F;&#x2F;const修饰*p，*p是指针指向的对象，不可变</span><br><span class="line">(int) const *p；  &#x2F;&#x2F;const修饰*p，*p是指针指向的对象，不可变</span><br><span class="line">(int)*const p;   &#x2F;&#x2F;const修饰p，p不可变，p指向的对象可变</span><br><span class="line">const (int) *const p;  &#x2F;&#x2F;前一个const修饰*p，后一个const修饰p，指针p和p指向的对象都不可变</span><br></pre></td></tr></table></figure>
## C++ 异常机制分析 http://www.cnblogs.com/QG-whz/p/5136883.html</p>
<h2><span id="new-he-malloc-de-qu-bie">new和malloc的区别</span><a href="#new-he-malloc-de-qu-bie" class="header-anchor">#</a></h2>
<p>https://www.cnblogs.com/engraver-lxw/p/8600816.html 1.
申请的内存所在位置 　　new操作符从自由存储区（free
store）上为对象动态分配内存空间，而malloc函数从<strong>堆上动态分配内存</strong>。
2. 返回类型安全性
　　new操作符内存分配成功时，<strong>返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符</strong>。而malloc内存分配成功则是**返回void
* ，需要通过强制类型转换将void*指针转换成我们需要的类型**。</p>
<ol start="3" type="1">
<li>内存分配失败时的返回值
　　new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</li>
</ol>
<p>在使用C语言时，我们习惯
<strong>在malloc分配内存后判断分配是否成功</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *a  &#x3D; (int *)malloc ( sizeof (int ));</span><br><span class="line">if(NULL &#x3D;&#x3D; a)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
但是
<strong>对于new实际上这样做一点意义也没有</strong>，因为new根本不会返回NULL，而且
<strong>程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    int *a &#x3D; new int();</span><br><span class="line">&#125;</span><br><span class="line">catch (bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li>是否需要指定内存大小 使用
<strong>new操作符申请内存分配时无须指定内存块的大小</strong>，编译器会根据类型信息自行计算，而
<strong>malloc则需要显式地指出所需内存的尺寸</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;...&#125;</span><br><span class="line">A * ptr &#x3D; new A;</span><br><span class="line">A * ptr &#x3D; (A *)malloc(sizeof(A)); &#x2F;&#x2F;需要显式指定所需内存大小sizeof(A);</span><br></pre></td></tr></table></figure></li>
<li>是否调用构造函数/析构函数
使用new操作符来分配对象内存时会经历三个步骤：</li>
</ol>
<ul>
<li>第一步：调用operator new 函数（对于数组是operator
new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li>
<li>第二步：编译器运行
<strong>相应的构造函数以构造对象，并为其传入初值</strong>。</li>
<li>第三步：对象构造完成后，<strong>返回一个指向该对象的指针</strong>。</li>
</ul>
<p>使用delete操作符来释放对象内存时会经历两个步骤： - 第一步：调用
<strong>对象的析构函数</strong>。 - 第二步：编译器 <strong>调用operator
delete(或operator delete[])函数释放内存空间</strong>。</p>
<p>总之来说，<strong>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构</strong>。而
<strong>malloc则不会</strong>。</p>
<ol start="6" type="1">
<li>对数组的处理 C++提供了new[]与delete[]来专门处理数组类型:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A * ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个A对象</span><br></pre></td></tr></table></figure>
使用new[]分配的内存必须使用delete[]进行释放：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete [] ptr;</span><br></pre></td></tr></table></figure>
new对数组的支持体现在它会<strong>分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏</strong>。至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int * ptr &#x3D; (int *) malloc( sizeof(int)* 10 );&#x2F;&#x2F;分配一个10个int元素的数组</span><br></pre></td></tr></table></figure></li>
<li>new与malloc是否可以相互调用 operator new /operator
delete的实现可以基于malloc，而
<strong>malloc的实现不可以去调用new</strong>。下面是编写operator new
/operator delete 的一种简单方式，其他版本也与之类似：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> void * operator new (sieze_t size)</span><br><span class="line"> &#123;</span><br><span class="line">     if(void * mem &#x3D; malloc(size)</span><br><span class="line">         return mem;</span><br><span class="line">     else</span><br><span class="line">         throw bad_alloc();</span><br><span class="line"> &#125;</span><br><span class="line"> void operator delete(void *mem) noexcept</span><br><span class="line"> &#123;</span><br><span class="line">    free(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="zhi-zhen-dui-qi">指针对齐</span><a href="#zhi-zhen-dui-qi" class="header-anchor">#</a></h2>
<p>以下代码打印的结果是（假设运行在 64 位计算机上）：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct st_t &#123;</span><br><span class="line">    int status;</span><br><span class="line">    short *pdata;</span><br><span class="line">    char errstr[32]; </span><br><span class="line">&#125;;</span><br><span class="line">st_t st[16];</span><br><span class="line">char *p&#x3D;(char *)(st[2].esstr+32);</span><br><span class="line">printf(“%d”,(p-(char *)(st)));</span><br></pre></td></tr></table></figure></p>
<p>根据字节对齐，在64位系统下struct st_t 结构体占用的字节为48个。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct st_t &#123; </span><br><span class="line">int status;  &#x2F;&#x2F;占用8个（后面的4个为对齐位） </span><br><span class="line">short *pdata;&#x2F;&#x2F;占用8个 </span><br><span class="line">char errstr[32];&#x2F;&#x2F;占用32个 </span><br><span class="line">&#125;; </span><br><span class="line">char *p&#x3D;(char *)(st[2].esstr+32)，p实际指向了st[3] </span><br><span class="line">则p-(char *)(st))，即为&amp;st[3]-&amp;st[0],占用空间为3个结构体的大小，即3*48&#x3D;144</span><br></pre></td></tr></table></figure></p>
<h2><span id="kong-lei-de-sizeof-da-xiao-you-yi-ge-xu-han-shu-de-lei-de-sizeof">空类的sizeof大小，有一个虚函数的类的sizeof</span><a href="#kong-lei-de-sizeof-da-xiao-you-yi-ge-xu-han-shu-de-lei-de-sizeof" class="header-anchor">#</a></h2>
<p>https://blog.csdn.net/foreverhuylee/article/details/39320977
题目（二）：运行下面的代码，输出是什么？
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        B() &#123;&#125;</span><br><span class="line">~B() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        C() &#123;&#125;</span><br><span class="line">        virtual ~C() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d, %d, %d\n&quot;, sizeof(A), sizeof(B), sizeof(C));</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><p>答案是1, 1, 4。class
A是一个空类型，它的实例不包含任何信息，本来求sizeof应该是0。但当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual
Studio 2008中每个空类型的实例占用一个byte的空间。</p></li>
<li><p>class B在class
A的基础上添加了构造函数和析构函数。由于构造函数和析构函数的调用与类型的实例无关（调用它们只需要知道函数地址即可），在它的实例中不需要增加任何信息。所以sizeof(B)和sizeof(A)一样，在Visual
Studio 2008中都是1。</p></li>
<li><p>class C在class
B的基础上把析构函数标注为虚拟函数。C++的编译器一旦发现一个类型中有虚拟函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4个字节的空间，因此sizeof(C)是4。</p></li>
</ol>
<h2><span id="zhi-chuan-di-yin-yong-chuan-di">值传递，引用传递</span><a href="#zhi-chuan-di-yin-yong-chuan-di" class="header-anchor">#</a></h2>
<p>值传递---单向传递 swap(int a,int b) 引用传递 ----双向传递 swap(int
&amp;a,int &amp;b)<br>
<strong>引用即别名，必须初始化</strong></p>
<h2><span id="nei-lian-han-shu-inline">内联函数 inline</span><a href="#nei-lian-han-shu-inline" class="header-anchor">#</a></h2>
<p>作用：可避免函数调用的开销
注：<strong>内联函数只是对编译器发送一个请求，编译器可以忽略该请求</strong>
一般用于<strong>优化规模小，流程直接，频繁调用的函数</strong></p>
<ol type="1">
<li>内联函数体内不能有循环语句和switch语句</li>
<li>内联函数定义必须在内联函数第一次调用之前</li>
<li>对内联函数不能进行异常接口声明</li>
</ol>
<h2><span id="constexpr-han-shu">constexpr函数</span><a href="#constexpr-han-shu" class="header-anchor">#</a></h2>
<p>指能用于常量表达式的函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constexpr int getsize() &#123;</span><br><span class="line">  return 20;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"> constexpr int foo &#x3D; getsize(); &#x2F;&#x2F;foo是常量表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## 常量表达式 值不会改变并且编译过程就能得到计算结果的表达式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int max_files&#x3D;20; &#x2F;&#x2F;常量表达式</span><br><span class="line">const int limit&#x3D;max_files+1; &#x2F;&#x2F;常量表达式</span><br><span class="line">int staff_size&#x3D;27; &#x2F;&#x2F;不是常量表达式</span><br></pre></td></tr></table></figure></p>
<h2><span id="mo-ren-can-shu-zhi">默认参数值</span><a href="#mo-ren-can-shu-zhi" class="header-anchor">#</a></h2>
<p>有默认参数的形参必须<strong>列在函数形参列表的最右端</strong>
调用实参与形参结合的次序是<strong>从左到右</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int add(int x,int y&#x3D;5,int z&#x3D;6);&#x2F;&#x2F;正确</span><br><span class="line">add(1)&#x3D;12;</span><br><span class="line">add(1,2)&#x3D;9;</span><br><span class="line"></span><br><span class="line">int add(int x&#x3D;1,int y&#x3D;5,int z);&#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>[c++接口] 1.boost常用接口</title>
    <url>/2021/02/25/c-%E6%8E%A5%E5%8F%A3-1-boost%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2><span id="1-enable-shared-from-this">1. enable_shared_from_this</span><a href="#1-enable-shared-from-this" class="header-anchor">#</a></h2>
<p><a href="https://www.boost.org/doc/libs/1_64_0/libs/smart_ptr/enable_shared_from_this.html">enable_shared_from_this</a><t>定义了
<strong>shared_from_this</strong>和
<strong>weak_from_this</strong>成员函数，它们分别返回自身的<strong>share_ptr</strong>的<strong>weak_ptr</strong>。
如何在对象中获得一个指向当前对象的 shared_ptr 对象 <a id="more"></a> ####
使用场景 - 当类对象被 shared_ptr 管理时 - 需要在类自己定义的函数里
<strong>把当前类对象作为参数</strong>传给其他函数时（将对象的 this
指针[raw pointer]作为返回值返回给了调用者时可能会造成的 core dump）</t></p>
<h4><span id="yuan-ma-fen-xi">源码分析</span><a href="#yuan-ma-fen-xi" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace boost</span><br><span class="line">&#123;</span><br><span class="line">template&lt;class T&gt; class enable_shared_from_this</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    shared_ptr&lt;T&gt; shared_from_this();      </span><br><span class="line">    shared_ptr&lt;T const&gt; shared_from_this() const;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;T&gt; weak_from_this() noexcept;</span><br><span class="line">    weak_ptr&lt;T const&gt; weak_from_this() const noexcept;</span><br><span class="line"></span><br><span class="line">    template&lt;class X, class Y&gt; void _internal_accept_owner( shared_ptr&lt;X&gt; const * ppx, Y * py ) const</span><br><span class="line">    &#123;</span><br><span class="line">        if( weak_this_.expired() )</span><br><span class="line">        &#123;</span><br><span class="line">            weak_this_ &#x3D; shared_ptr&lt;T&gt;( *ppx, py );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    mutable weak_ptr&lt;T&gt; weak_this_; &#x2F;&#x2F;弱引用指针数组（不能用shared_ptr，否则shared_ptr的引用永远也不为零）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取当前对象的shared_ptr指针就是从该weak_ptr提升而来</span><br><span class="line">shared_ptr&lt;T&gt; shared_from_this()</span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;T&gt; p( weak_this_ );</span><br><span class="line">    BOOST_ASSERT( p.get() &#x3D;&#x3D; this );</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;而weak_ptr的则是在构造的时候初始化的</span><br><span class="line">explicit shared_ptr( Y * p ): px( p ), pn( p ) &#x2F;&#x2F; Y must be complete</span><br><span class="line">&#123;</span><br><span class="line">    boost::detail::sp_enable_shared_from_this( this, p, p );</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">template&lt; class X, class Y, class T &gt;</span><br><span class="line">inline void sp_enable_shared_from_this( boost::shared_ptr&lt;X&gt; const * ppx, Y const * py, </span><br><span class="line">boost::enable_shared_from_this&lt; T &gt; const * pe )</span><br><span class="line">&#123;</span><br><span class="line">    if( pe !&#x3D; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        pe-&gt;_internal_accept_owner( ppx, const_cast&lt; Y* &gt;( py ) );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="example">example</span><a href="#example" class="header-anchor">#</a></h4>
<p>对一个类 Y ，当我们希望使用 shared_ptr 来管理其类对象时，可以让类 Y
<strong>从 enable_shared_from_this 继承</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;boost&#x2F;enable_shared_from_this.hpp&gt;</span><br><span class="line">#include &lt;boost&#x2F;shared_ptr.hpp&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">class Y: public boost::enable_shared_from_this&lt;Y&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    boost::shared_ptr&lt;Y&gt; f()</span><br><span class="line">    &#123;</span><br><span class="line">        return shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 正确的使用方法</span><br><span class="line">    boost::shared_ptr&lt;Y&gt; p(new Y);</span><br><span class="line">    boost::shared_ptr&lt;Y&gt; q &#x3D; p-&gt;f();   &#x2F;&#x2F; 调用f获得shared_ptr</span><br><span class="line">    assert(p &#x3D;&#x3D; q);</span><br><span class="line">    assert(!(p &lt; q || q &lt; p)); &#x2F;&#x2F; p and q must share ownership</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 错误的使用方法，因为Y的成员weak_ptr 根本就没有得到初始化</span><br><span class="line">    Y  yy;</span><br><span class="line">    boost::shared_ptr&lt;Y&gt; q &#x3D; yy.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
另外可见<a href="https://www.boost.org/doc/libs/1_39_0/doc/html/boost_asio/tutorial/tutdaytime3/src.html">boost官方的详细例子</a></p>
<h4><span id="shi-xian-yuan-li">实现原理</span><a href="#shi-xian-yuan-li" class="header-anchor">#</a></h4>
<ul>
<li>限制：
<ul>
<li>在类对象 <strong>本身</strong>当中
<strong>不能存储</strong>类对象<strong>本身的 shared_ptr</strong>
，否则类对象 shared_ptr
永远也不会为0了，资源永远不会释放，除非程序结束。</li>
<li>类对象肯定是 外部函数通过某种机制分配的，而且
<strong>一经分配立即交给 shared_ptr
管理</strong>，而且以后凡是需要共享使用类对象的地方必须 <strong>使用这个
shared_ptr 当作右值</strong>来构造产生或者<strong>拷贝产生另一个
shared_ptr</strong> 从而达到共享使用的目的。</li>
</ul></li>
<li>方案
<ul>
<li>类对象的<strong>外部 shared_ptr</strong>
作为<strong>函数参数</strong>传给需要<strong>引用类对象自身的函数</strong>
【这种方法很丑陋，而且并不是所有的情况都可行（如在外部 shared_ptr
不可见的作用域中就不行）】</li>
<li>类对象<strong>自身存储某种信息</strong>，在<strong>需要</strong>自身
shared_ptr 时来<strong>产生一个临时的 shared_ptr</strong> 。</li>
</ul></li>
</ul>
<h4><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h4>
<ol type="1">
<li><a href="https://www.boost.org/doc/libs/1_64_0/libs/smart_ptr/enable_shared_from_this.html">boost/enable_shared_from_this</a></li>
<li><a href="https://www.cnblogs.com/xiezhw3/p/4099948.html">如何用enable_shared_from_this
来得到指向自身的shared_ptr 及对enable_shared_from_this 的理解</a></li>
</ol>
<h2><span id="2-noncopyable-bu-ke-kao-bei-lei">2. noncopyable 不可拷贝类</span><a href="#2-noncopyable-bu-ke-kao-bei-lei" class="header-anchor">#</a></h2>
<p><a href="https://www.boost.org/doc/libs/1_65_0/libs/core/doc/html/core/noncopyable.html">&lt;boost/core/noncopyable.hpp&gt;</a>定义了
boost::noncopyable(不可拷贝) 类。 boost::noncopyable 使用
<strong>private</strong> (C++03版) 或者 <strong>deleted</strong>
(C++11版)字段 来限制拷贝构造函数。一个类继承自它也是不可拷贝的.</p>
<h4><span id="da-zhi-shi-xian">大致实现</span><a href="#da-zhi-shi-xian" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace boost</span><br><span class="line">&#123;</span><br><span class="line">    class noncopyable&#123;</span><br><span class="line">    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  c++03版本 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    private:  &#x2F;&#x2F; emphasize the following members are private</span><br><span class="line">        noncopyable( const noncopyable&amp; );</span><br><span class="line">        noncopyable&amp; operator&#x3D;( const noncopyable&amp; );</span><br><span class="line">    </span><br><span class="line">    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; c++11版本 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    public:</span><br><span class="line">        noncopyable(const noncopyable&amp;) &#x3D; delete;</span><br><span class="line">        noncopyable&amp; operator&#x3D;( const noncopyable&amp; ) &#x3D; delete;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="example">example</span><a href="#example" class="header-anchor">#</a></h4>
<p><strong>private继承</strong>boost::noncopyable,
使自定义类不能被拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;boost&#x2F;core&#x2F;noncopyable.hpp&gt;</span><br><span class="line">class X: private boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="3-variant-class">3. variant class</span><a href="#3-variant-class" class="header-anchor">#</a></h2>
<h4><span id="ding-yi">定义</span><a href="#ding-yi" class="header-anchor">#</a></h4>
<p>The <a href="https://cs.brown.edu/~jwicks/boost/doc/html/variant.html">variant
class</a> template is a <strong>safe, generic, stack-based discriminated
union container</strong>, offering a simple solution for manipulating an
object from a <strong>heterogeneous set(elements may not be of same data
type)</strong> of types in a uniform manner. Whereas standard containers
such as <strong>std::vector</strong> may be thought of as
"<strong>multi-value, single type</strong>," variant is
"<strong>multi-type, single value</strong>."</p>
]]></content>
      <categories>
        <category>c++接口</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>[Cocos]常用API</title>
    <url>/2020/10/27/cocos-%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<h1><span id="cocosapi-xue-xi">cocosApi学习</span><a href="#cocosapi-xue-xi" class="header-anchor">#</a></h1>
<p>这篇博客记录一下工作中遇到的Cocos相关api。</p>
<h2><span id="eventlistenertouchonebyone-create">EventListenerTouchOneByOne::create()</span><a href="#eventlistenertouchonebyone-create" class="header-anchor">#</a></h2>
<p><strong>单点触摸</strong>监听
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listener &#x3D; cc.EventListenerTouchOneByOne.create()</span><br></pre></td></tr></table></figure></p>
<h2><span id="cc-fadeto">cc.fadeTo</span><a href="#cc-fadeto" class="header-anchor">#</a></h2>
<p>修改 <strong>透明度</strong>到指定值</p>
<h2><span id="rong-qi-dong-zuo">容器动作</span><a href="#rong-qi-dong-zuo" class="header-anchor">#</a></h2>
<h3><span id="shun-xu-dong-zuo-cc-sequence">顺序动作 cc.sequence</span><a href="#shun-xu-dong-zuo-cc-sequence" class="header-anchor">#</a></h3>
<p>顺序动作可以让一系列子动作按顺序一个个执行
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 让节点左右来回移动</span><br><span class="line">var seq &#x3D; cc.sequence(cc.moveBy(0.5, 200, 0), cc.moveBy(0.5, -200, 0));</span><br><span class="line">node.runAction(seq);</span><br></pre></td></tr></table></figure></p>
<h3><span id="tong-bu-dong-zuo-cc-spawn">同步动作 cc.spawn</span><a href="#tong-bu-dong-zuo-cc-spawn" class="header-anchor">#</a></h3>
<p>同步动作可以同步执行对一系列子动作，子动作的执行结果会叠加起来修改节点的属性。示例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 让节点在向上移动的同时缩放</span><br><span class="line">var spawn &#x3D; cc.spawn(cc.moveBy(0.5, 0, 50), cc.scaleTo(0.5, 0.8, 1.4));</span><br><span class="line">node.runAction(spawn);</span><br></pre></td></tr></table></figure></p>
<h3><span id="chong-fu-dong-zuo-cc-repeat">重复动作 cc.repeat</span><a href="#chong-fu-dong-zuo-cc-repeat" class="header-anchor">#</a></h3>
<p>重复动作用来多次重复一个动作。示例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 让节点左右来回移动，并重复 5 次</span><br><span class="line">var seq &#x3D; cc.repeat(</span><br><span class="line">            cc.sequence(</span><br><span class="line">                cc.moveBy(2, 200, 0),</span><br><span class="line">                cc.moveBy(2, -200, 0)</span><br><span class="line">            ), 5);</span><br><span class="line">node.runAction(seq);</span><br></pre></td></tr></table></figure></p>
<h2><span id="ccc-callfunc-create-func">ccc.CallFunc.create(func)</span><a href="#ccc-callfunc-create-func" class="header-anchor">#</a></h2>
<p>调用当前不带参数的函数</p>
<h2><span id="cc-delaytime-create-float-delaytime">cc.DelayTime.create(float
delaytime)</span><a href="#cc-delaytime-create-float-delaytime" class="header-anchor">#</a></h2>
<p>延迟当前的action</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node.runAction(cc.Sequence.create([cc.DelayTime.create(1), cc.CallFunc.create(callback)]))</span><br><span class="line"></span><br><span class="line">def callback():</span><br><span class="line">    print &quot;just test&quot;</span><br></pre></td></tr></table></figure>
<h1><span id="ccui">ccui</span><a href="#ccui" class="header-anchor">#</a></h1>
<h3><span id="ccui-touch-event-moved-dang-qian-wei-hong-ping-yi-dong-zhuang-tai">ccui.TOUCH_EVENT_MOVED当前为触屏移动状态</span><a href="#ccui-touch-event-moved-dang-qian-wei-hong-ping-yi-dong-zhuang-tai" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ccui.TOUCH_EVENT_MOVED &#x3D;&#x3D; evtType:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h3><span id="ccui-touch-event-ended-dang-qian-wei-hong-ping-tai-qi-zhuang-tai">ccui.TOUCH_EVENT_ENDED
当前为触屏抬起状态</span><a href="#ccui-touch-event-ended-dang-qian-wei-hong-ping-tai-qi-zhuang-tai" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if evtType &#x3D;&#x3D; ccui.TOUCH_EVENT_ENDED:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h2><span id="button-an-niu">button按钮</span><a href="#button-an-niu" class="header-anchor">#</a></h2>
<h3><span id="button-tu-pian-she-zhi">button图片设置</span><a href="#button-tu-pian-she-zhi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">btn.loadTextureNormal(&quot;....png&quot;)  # 正常状态</span><br><span class="line">btn.loadTexturePressed(&quot;....png&quot;)  # 按下状态</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Cocos</tag>
      </tags>
  </entry>
  <entry>
    <title>[hexo]重装系统后重新部署hexo</title>
    <url>/2022/11/05/hexo-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<p>最近重装了windows系统，因此需要重新部署hexo博客，记录下重新部署的步骤
<a id="more"></a></p>
<h2><span id="an-zhuang-node-js">安装Node.js</span><a href="#an-zhuang-node-js" class="header-anchor">#</a></h2>
<ul>
<li>下载
<ul>
<li>下载稳定版 <a href="https://nodejs.org/zh-cn/">nodejs</a></li>
<li>我这里给的是64位的，选中安装路径后就一直点Next。</li>
</ul></li>
<li>设置环境变量
<ul>
<li>右键"此电脑"-"属性"-"高级系统设置"-"环境变量"-选中用户变量的Path编辑-"新增"将nodejs按照路径加入</li>
<li>我的安装路径是 D:</li>
</ul></li>
<li>验证
<ul>
<li>按Win+R打开命令提示符，输入node -v和npm -v，出现版本号就成功了</li>
</ul></li>
</ul>
<h2><span id="an-zhuang-git">安装Git</span><a href="#an-zhuang-git" class="header-anchor">#</a></h2>
<p>为了把本地的文件上传到github上，我们需要用到分布式版本控制工具————Git</p>
<p>下载地址<a href="https://git-scm.com/download/win">Git</a></p>
<ul>
<li>验证
<ul>
<li>按Win+R打开命令提示符，输入git --version验证是否安装成功。</li>
</ul></li>
</ul>
<h2><span id="github-jia-ru-mi-yao">Github加入密钥</span><a href="#github-jia-ru-mi-yao" class="header-anchor">#</a></h2>
<ul>
<li><p>设置git用户名和email
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;sysuleo&quot;</span><br><span class="line">git config --global user.email &quot;youremail@xx.com&quot;</span><br></pre></td></tr></table></figure></p></li>
<li><p>生成密钥
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@xx.com&quot;</span><br></pre></td></tr></table></figure></p></li>
<li><p>保存密钥到github 打开github，在头像下面点击settings，再点击SSH
and GPG keys，新建一个SSH，将如下内容复制进去</p></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
<h2><span id="la-qu-hexo-ge-ren-bo-ke-yuan-ma">拉去hexo 个人博客源码</span><a href="#la-qu-hexo-ge-ren-bo-ke-yuan-ma" class="header-anchor">#</a></h2>
<p>新建blog目录, 如 D:_blog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd D:\github\sysuleo_blog</span><br><span class="line"></span><br><span class="line">git clone xxxxxx # 拉去博客源码</span><br></pre></td></tr></table></figure>
<h2><span id="an-zhuang-hexo">安装Hexo</span><a href="#an-zhuang-hexo" class="header-anchor">#</a></h2>
<ul>
<li><p>安装hexo: cd到博客目录下, 输入
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/111998154">npm卡顿</a>时可以换源
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry http:&#x2F;&#x2F;registry.npmmirror.com</span><br></pre></td></tr></table></figure></p></li>
<li><p>验证： 输入
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2><span id="shan-diao-yuan-blog-wen-jian-jia-bu-fen-wen-jian">删掉原blog文件夹部分文件</span><a href="#shan-diao-yuan-blog-wen-jian-jia-bu-fen-wen-jian" class="header-anchor">#</a></h2>
<p>只需保留_config.yml，theme/，source/，scaffolds/，package.json，.gitignore
这些项目, 删除其余文件</p>
<h2><span id="an-zhuang-yi-lai-wen-jian">安装依赖文件</span><a href="#an-zhuang-yi-lai-wen-jian" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h2><span id="an-zhuang-bu-shu-cha-jian">安装部署插件</span><a href="#an-zhuang-bu-shu-cha-jian" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>最后验证是否成成功
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s </span><br></pre></td></tr></table></figure></p>
<h2><span id="wen-ti-hui-zong">问题汇总</span><a href="#wen-ti-hui-zong" class="header-anchor">#</a></h2>
<h3><span id="1-pandoc-exited-with-code-null-bao-cuo">1. pandoc exited with code
null报错</span><a href="#1-pandoc-exited-with-code-null-bao-cuo" class="header-anchor">#</a></h3>
<p>执行hexo-g 时报错如下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">INFO  Start processing</span><br><span class="line">ERROR &#123;</span><br><span class="line">  err: Error:</span><br><span class="line">  [ERROR][hexo-renderer-pandoc] On D:\github\sysuleo_blog\sysuleo.github.io_resource\themes\hexo-theme-next\languages\README.md</span><br><span class="line">  [ERROR][hexo-renderer-pandoc] pandoc exited with code null.</span><br><span class="line">      at Hexo.pandocRenderer (D:\github\sysuleo_blog\sysuleo.github.io_resource\node_modules\hexo-renderer-pandoc\index.js:114:11)</span><br><span class="line">      at Hexo.tryCatcher (D:\github\sysuleo_blog\sysuleo.github.io_resource\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">      at Hexo.&lt;anonymous&gt; (D:\github\sysuleo_blog\sysuleo.github.io_resource\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
参考<a href="https://www.zepoch.cc/2022/2213706848">关于 pandoc exited
with code null 的解决方案</a></p>
<p>下载安装 <a href="https://github.com/jgm/pandoc/releases">pandoc</a>，重新启动命令行就ok了</p>
<h3><span id="2-tomorrow-night-css-que-shi">2. tomorrow-night.css缺失</span><a href="#2-tomorrow-night-css-que-shi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">INFO  Start processing</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: ENOENT: no such file or directory, open &#39;D:\github\sysuleo_blog\sysuleo.github.io_resource\node_modules\highlight.js&#x2F;styles&#x2F;tomorrow-night.css&#39;</span><br><span class="line">      at Object.openSync (node:fs:600:3)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>参考官网<a href="https://hexo.io/docs/troubleshooting.html">Troubleshooting</a>: If
you get an error like Error: ENOENT: no such file or directory it’s
probably due to to <strong>mixing uppercase and lowercase letters in
your tags, categories, or filenames</strong>. Git cannot automatically
merge this change so it breaks the automatic branching.</p>
<p>最后没找到问题, 重新部署解决了...</p>
<h3><span id="3-git-pull-bao-cuo-host-key-verification-failed">3. git pull报错Host
key verification failed.</span><a href="#3-git-pull-bao-cuo-host-key-verification-failed" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">.........</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in &#x2F;c&#x2F;Users&#x2F;liuwen03&#x2F;.ssh&#x2F;known_hosts to get rid of this message.</span><br><span class="line">Offending RSA key in &#x2F;c&#x2F;Users&#x2F;liuwen03&#x2F;.ssh&#x2F;known_hosts:1</span><br><span class="line">RSA host key for github.com has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/">We
updated our RSA SSH host key</a>, 重新生成known_host文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -R github.com</span><br></pre></td></tr></table></figure></p>
<h3><span id="4-git-bao-cuo-you-re-using-an-rsa-key-with-sha-1-which-is-no-longer-allowed">4.
git报错"You're using an RSA key with SHA-1, which is no longer
allowed.</span><a href="#4-git-bao-cuo-you-re-using-an-rsa-key-with-sha-1-which-is-no-longer-allowed" class="header-anchor">#</a></h3>
<p>参考<a href="https://stackoverflow.com/questions/71500791/eclipse-git-youre-using-an-rsa-key-with-sha-1-which-is-no-longer-allowed-pl">Eclipse/Git:
"You're using an RSA key with SHA-1, which is no longer
allowed"</a>：</p>
<blockquote>
<p>According to Github security blog RSA keys with SHA-1 are no longer
accepted.</p>
</blockquote>
<blockquote>
<p>Use the following command to create new SSH key with ECDSAencryption
and add it to Github：</p>
</blockquote>
<blockquote>
<p>ssh-keygen -t ecdsa -b 521 -C "your_email@example.com"</p>
</blockquote>
<h3><span id="5-git-clone-shi-bai-failed-to-connect-to-github-com-port-443-after-21106-ms-could-not-connect-to-server">5.
git clone 失败"Failed to connect to github.com port 443 after 21106 ms:
Could not connect to server"</span><a href="#5-git-clone-shi-bai-failed-to-connect-to-github-com-port-443-after-21106-ms-could-not-connect-to-server" class="header-anchor">#</a></h3>
<ul>
<li>本地使用了vpn科学上网，需要设置代理端口(因人而异，参考<a href="https://simplestark.com/archives/%E7%BB%8F%E9%AA%8C%E5%AE%9D%E5%AE%9Dfailedtoconnecttogithubcomport443operationtimedout">【经验宝宝】Failed
to connect to github.com port 443: Operation timed out</a>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<h3><span id="6-npm-install-bao-cuo-certificate-has-expired">6. npm install报错</span><a href="#6-npm-install-bao-cuo-certificate-has-expired" class="header-anchor">#</a></h3>
<p>更换淘宝镜像时，发现报错证书已过期，那是因为淘宝的镜像网站更换了，原地址已不再维护但是仍然可访问。具体公告在：developer.aliyun.com/mirror/NPM，
具体变化如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry http:&#x2F;&#x2F;registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"># http:&#x2F;&#x2F;npm.taobao.org &#x3D;&gt; http:&#x2F;&#x2F;npmmirror.com</span><br><span class="line"># http:&#x2F;&#x2F;registry.npm.taobao.org &#x3D;&gt; http:&#x2F;&#x2F;registry.npmmirror.com</span><br></pre></td></tr></table></figure>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://simplestark.com/archives/%E7%BB%8F%E9%AA%8C%E5%AE%9D%E5%AE%9Dfailedtoconnecttogithubcomport443operationtimedout">【经验宝宝】Failed
to connect to github.com port 443: Operation timed out</a></li>
<li><a href="https://juejin.cn/post/7330147786677567499">npm install
提示 Error: certificate has expired</a></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 1.常用指令</title>
    <url>/2020/11/12/linux-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="jin-cheng-xiang-guan-zhi-ling-ps">进程相关指令 ps</span><a href="#jin-cheng-xiang-guan-zhi-ling-ps" class="header-anchor">#</a></h2>
<p>参考自 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html" title="ps 进程查看器">ps 进程查看器</a></p>
<h3><span id="jin-cheng-zhuang-tai">进程状态</span><a href="#jin-cheng-zhuang-tai" class="header-anchor">#</a></h3>
<p>ps工具标识进程的5种状态码: - D 不可中断 uninterruptible sleep
(usually IO) - R 运行 runnable (on run queue) - S 中断 sleeping - T 停止
traced or stopped - Z 僵死 a defunct (”zombie”) process</p>
<h3><span id="ming-ling-can-shu">命令参数</span><a href="#ming-ling-can-shu" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a       显示 所有进程（显示状态码）</span><br><span class="line">-a      显示同一终端下的所有程序</span><br><span class="line">-A      所有进程</span><br><span class="line">e       环境变量</span><br><span class="line">c       进程的 真实名称</span><br><span class="line"></span><br><span class="line">r       当前 终端的进程</span><br><span class="line">T       当前 终端的所有程序</span><br><span class="line">u       用户的所有进程</span><br><span class="line">-au     较详细的资讯</span><br><span class="line">-aux    所有包含其他使用者的行程</span><br><span class="line"></span><br><span class="line">-N      反向选择</span><br><span class="line">-e      等于“-A”</span><br><span class="line">f       显示程序间的关系</span><br><span class="line">-H      显示树状结构</span><br><span class="line"></span><br><span class="line">-C&lt;命令&gt;               列出指定命令的状况</span><br><span class="line">–lines&lt;行数&gt;           每页显示的行数</span><br><span class="line">–width&lt;字符数&gt;         每页显示的字符数</span><br><span class="line">–help                  显示帮助信息</span><br><span class="line">–version                显示版本显示</span><br></pre></td></tr></table></figure>
<h3><span id="shu-chu-lie-han-yi">输出列含义</span><a href="#shu-chu-lie-han-yi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F           代表这个程序的旗标 (flag)， 4 代表使用者为 super user</span><br><span class="line">S           代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</span><br><span class="line">UID         程序被该 UID 所拥有</span><br><span class="line">PID         进程的ID</span><br><span class="line">PPID        则是其 上级父程序的ID</span><br><span class="line">C           CPU 使用的资源百分比</span><br><span class="line">PRI         这个是 Priority (优先执行序) 的缩写，详细后面介绍</span><br><span class="line">NI          这个是 Nice 值，在下一小节我们会持续介绍</span><br><span class="line">ADDR        这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</span><br><span class="line">SZ          使用掉的内存大小</span><br><span class="line">WCHAN       目前这个程序是否正在运作当中，若为 - 表示正在运作</span><br><span class="line">TTY         登入者的终端机位置</span><br><span class="line">TIME        使用掉的 CPU 时间。</span><br><span class="line">CMD         所下达的指令为何</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="qi-ta-chang-yong-zhi-ling">其它常用指令</span><a href="#qi-ta-chang-yong-zhi-ling" class="header-anchor">#</a></h2>
<h3><span id="linux-huan-jing-zhong-ying-wen-qie-huan-pei-zhi-yi-ji-luan-ma-wen-ti">linux环境中英文切换配置以及乱码问题</span><a href="#linux-huan-jing-zhong-ying-wen-qie-huan-pei-zhi-yi-ji-luan-ma-wen-ti" class="header-anchor">#</a></h3>
<h4><span id="ji-chu-pei-zhi">基础配置</span><a href="#ji-chu-pei-zhi" class="header-anchor">#</a></h4>
<p>本质就是修改系统的LANG变量</p>
<p>LANG是language的简称，稍微有英语基础的用户一看就看出来这个变量是决定系统的默认语言的，即系统的菜单、程序的工具栏语言、输入法默
认语言等。</p>
<h4><span id="cha-kan-dang-qian-yong-hu-de-lang-bian-liang">查看当前用户的LANG变量</span><a href="#cha-kan-dang-qian-yong-hu-de-lang-bian-liang" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">liuw@12:~locale</span><br><span class="line"></span><br><span class="line">LANG&#x3D;zh_CN</span><br><span class="line">LANGUAGE&#x3D;</span><br><span class="line">LC_CTYPE&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_NUMERIC&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_TIME&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_COLLATE&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_MONETARY&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_MESSAGES&#x3D;en_US</span><br><span class="line">LC_PAPER&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_NAME&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_ADDRESS&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_TELEPHONE&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_MEASUREMENT&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_IDENTIFICATION&#x3D;&quot;zh_CN&quot;</span><br><span class="line">LC_ALL&#x3D;</span><br></pre></td></tr></table></figure>
<h4><span id="pei-zhi-zi-ji-de-lang">配置自己的LANG</span><a href="#pei-zhi-zi-ji-de-lang" class="header-anchor">#</a></h4>
如果你希望修改整个系统的编码和语言信息，可以修改系统的配置文件修改LANG，而如果不希望影响其他用户直接在
<strong>自己的~/.bashrc中配置LANG</strong>即可
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># use english</span><br><span class="line">export LANG&#x3D;en_US.UTF-8</span><br><span class="line"></span><br><span class="line">LANG&#x3D;en_US.UTF-8</span><br><span class="line">LANGUAGE&#x3D;</span><br><span class="line">LC_CTYPE&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_NUMERIC&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_TIME&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_COLLATE&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_MONETARY&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_MESSAGES&#x3D;en_US</span><br><span class="line">LC_PAPER&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_NAME&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_ADDRESS&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_TELEPHONE&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_MEASUREMENT&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_IDENTIFICATION&#x3D;&quot;en_US.UTF-8&quot;</span><br><span class="line">LC_ALL&#x3D;</span><br></pre></td></tr></table></figure>
配置后如图：
<div style="width:90%;margin:auto">
<img src="/2020/11/12/linux-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/locale%E5%90%8E.png" class title="locale后图">
</div>
<h4><span id="svn-can-t-convert-string-from-utf-8-to-native-encoding-wen-ti">SVN:
Can't convert string from 'UTF-8' to native encoding问题</span><a href="#svn-can-t-convert-string-from-utf-8-to-native-encoding-wen-ti" class="header-anchor">#</a></h4>
<p>上图可以看到，原本的'LC_ALL'为空，对中文因此出现了这个问题
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LC_ALL&#x3D;</span><br></pre></td></tr></table></figure>
解决方案：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LC_ALL&#x3D;zh_CN.UTF-8     # 配置~&#x2F;.bashrc中 LC_ALL</span><br></pre></td></tr></table></figure></p>
<h3><span id="cha-xun-linux-xi-tong-lei-xing">查询linux系统类型</span><a href="#cha-xun-linux-xi-tong-lei-xing" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>
<p>这个命令适用于所有遵守LSB规范的的linux，包括Redhat、SuSE、Debian、Ubuntu、Centos等发行版</p>
<h3><span id="xian-shi-xi-tong-he-xin-xin-xi">显示系统核心信息</span><a href="#xian-shi-xi-tong-he-xin-xin-xi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname</span><br><span class="line"></span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<h3><span id="nei-cun-xin-xi">内存信息</span><a href="#nei-cun-xin-xi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;meminfo</span><br></pre></td></tr></table></figure>
<h3><span id="cpu-xin-xi">CPU信息</span><a href="#cpu-xin-xi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure>
<h3><span id="cha-kan-dang-qian-lu-jing">查看当前路径</span><a href="#cha-kan-dang-qian-lu-jing" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<h3><span id="chong-ming-ming-wen-jian-mv">重命名文件 mv</span><a href="#chong-ming-ming-wen-jian-mv" class="header-anchor">#</a></h3>
<p>例子：将目录A重命名为B
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv A B</span><br></pre></td></tr></table></figure>
例子：将/a目录移动到/b下，并重命名为c
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv &#x2F;a &#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure></p>
<h3><span id="sou-suo-wen-jian-find">搜索文件 find</span><a href="#sou-suo-wen-jian-find" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -mtime 0   #0代表当前时间，即从现在到24小时前，有改动过内容的文件都会被列出来</span><br><span class="line"></span><br><span class="line">find &#x2F;etc -newer &#x2F;etc&#x2F;passwd #寻找&#x2F;etc下面的文件，如果文件日期比&#x2F;etc&#x2F;passwd新就列出</span><br><span class="line"></span><br><span class="line">find &#x2F; -name file  #&#x2F;代表全文搜索</span><br><span class="line"></span><br><span class="line">find &#x2F;home -user Anmy  #查找&#x2F;home下属于Anmy的文件</span><br><span class="line"></span><br><span class="line">find &#x2F; -nouser #查找系统中不属于任何人的文件，可以轻易找出那些不太正常的文件</span><br><span class="line"></span><br><span class="line">find &#x2F; -name passed #查找文件名为passed的文件</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 10.linux三剑客之 sed指令</title>
    <url>/2021/05/19/linux-10-linux%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8B-sed%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="what-is-sed">what is sed</span><a href="#what-is-sed" class="header-anchor">#</a></h2>
<ul>
<li>SED是功能强大的<strong>文本流</strong>编辑器。可以进行<strong>插入，删除，搜索和替换</strong>，最常用于<strong>查找、替换</strong>。SED可以在没有打开文件的情况下就编辑文件，这效率比用vim等软件打开并替换高多了。</li>
<li>Unix中的SED命令<strong>支持正则表达式</strong>，从而可以执行复杂的模式匹配。</li>
</ul>
<h2><span id="can-shu-shuo-ming">参数说明</span><a href="#can-shu-shuo-ming" class="header-anchor">#</a></h2>
<ul>
<li>a ：新增， a
的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</li>
<li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2
之间的行！</li>
<li>d ：删除，d 后面通常不接任何东西</li>
<li>i ：插入， i
的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p ：打印，通常 会与参数 sed -n 一起运行</li>
<li>s ：替换，可以搭配正规表示法，例如 1,20s/old/new/g 就是啦！</li>
</ul>
<h2><span id="ti-huan">替换</span><a href="#ti-huan" class="header-anchor">#</a></h2>
<h4><span id="1-ti-huan-mei-xing-di-yi-ge-zi-fu-chuan-pattern">1. 替换每行第一个字符串pattern</span><a href="#1-ti-huan-mei-xing-di-yi-ge-zi-fu-chuan-pattern" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sed &#39;s&#x2F;unix&#x2F;linux&#x2F;&#39; geekfile.txt</span><br></pre></td></tr></table></figure>
<h4><span id="2-ti-huan-mei-xing-di-n-ge-pattern-shi-yong-1-2">2. 替换每行第n个 pattern
（使用/1，/2）</span><a href="#2-ti-huan-mei-xing-di-n-ge-pattern-shi-yong-1-2" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sed &#39;s&#x2F;unix&#x2F;linux&#x2F;2&#39; geekfile.txt</span><br></pre></td></tr></table></figure>
<h4><span id="3-ti-huan-mei-xing-suo-you-pattern-shi-yong-1-2">3. 替换每行所有 pattern
（使用/1，/2）</span><a href="#3-ti-huan-mei-xing-suo-you-pattern-shi-yong-1-2" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sed &#39;s&#x2F;unix&#x2F;linux&#x2F;g&#39; geekfile.txt</span><br></pre></td></tr></table></figure>
<h4><span id="4-gei-xing-nei-dan-ci-di-yi-ge-zi-mu-jia-gua-hao">4.给行内单词第一个字母加括号</span><a href="#4-gei-xing-nei-dan-ci-di-yi-ge-zi-mu-jia-gua-hao" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;Welcome To The Geek Stuff&quot; | sed &#39;s&#x2F;\(\b[A-Z]\)&#x2F;\(\1\)&#x2F;g&#39;</span><br><span class="line"></span><br><span class="line">(W)elcome (T)o (T)he (G)eek (S)tuff</span><br></pre></td></tr></table></figure>
<h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor">#</a></h2>
<h4><span id="1-shan-chu-di-5-xing">1.删除第5行</span><a href="#1-shan-chu-di-5-xing" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &#39;5d&#39; filename.txt</span><br></pre></td></tr></table></figure>
<h4><span id="2-shan-chu-3-dao-5-xing">2.删除 3到5行</span><a href="#2-shan-chu-3-dao-5-xing" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &#39;3,5d&#39; filename.txt</span><br></pre></td></tr></table></figure>
<h4><span id="3-shan-chu-xing-nei-de-abc">3.删除 行内的 abc</span><a href="#3-shan-chu-xing-nei-de-abc" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &#39;&#x2F;abc&#x2F;d&#39; filename.txt</span><br></pre></td></tr></table></figure>
<h2><span id="da-yin">打印</span><a href="#da-yin" class="header-anchor">#</a></h2>
<h4><span id="1-da-yin-4-dao-6-xing">1. 打印4到6行</span><a href="#1-da-yin-4-dao-6-xing" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@rhel7 ~]# sed -n &#39;4,6&#39;p a.txt</span><br></pre></td></tr></table></figure>
<h4><span id="2-da-yin-cong-n-dao-zui-hou">2. 打印从n到最后</span><a href="#2-da-yin-cong-n-dao-zui-hou" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sed -n &#39;3,$&#39;p a.txt</span><br></pre></td></tr></table></figure>
<h4><span id="3-da-yin-han-you-te-ding-pattern-de-xing">3. 打印含有特定pattern的行</span><a href="#3-da-yin-han-you-te-ding-pattern-de-xing" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sed -n &#x2F;every&#x2F;p a.txt</span><br></pre></td></tr></table></figure>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://www.geeksforgeeks.org/sed-command-linux-set-2/">SED
command in Linux</a></li>
<li><a href="https://www.runoob.com/linux/linux-comm-sed.html">Linux sed
命令</a></li>
</ol>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 11. rsnyc 万能的文件复制指令</title>
    <url>/2021/05/19/linux-11-rsnyc-%E4%B8%87%E8%83%BD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="what-is-rsnyc">what is rsnyc</span><a href="#what-is-rsnyc" class="header-anchor">#</a></h2>
<p>rsync 其实就是"远程同步"（remote sync）的意思, rsync
<strong>区别于FTP or scp</strong>的最大特点是会
<strong>检查</strong>发送方和接收方<strong>已有的文件</strong>，仅<strong>传输有变动</strong>的部分</p>
<p>它可以在<strong>本地计算机与远程计算机</strong>之间，或者<strong>两个本地目录</strong>之间同步文件，
可替代<strong>cp和mv</strong>命令。</p>
<h2><span id="ji-ben-yong-fa">基本用法</span><a href="#ji-ben-yong-fa" class="header-anchor">#</a></h2>
<p>1.-r 参数，表示递归(包括子目录)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -r source destination</span><br></pre></td></tr></table></figure>
<p>若有多个文件或目录需要同步
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -r source1 source2 destination</span><br></pre></td></tr></table></figure></p>
<p>2.-a 参数, 可以替代-r, 还可以同步元信息（比如修改时间、权限等） 由于
rsync
<strong>默认使用文件大小和修改时间</strong>决定文件是否需要更新，所以-a比-r<strong>更有用</strong></p>
<p>3.-n 参数, 模拟执行的结果
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -anv source&#x2F; destination</span><br></pre></td></tr></table></figure>
-n参数模拟命令执行的结果，<strong>并不真的执行命令</strong>。-v参数则是<strong>将结果输出到终端</strong>，这样就<strong>可以看到哪些内容会被同步</strong>。</p>
<p>4.--delete 参数,
<strong>删除</strong>只存在于<strong>目标目录、不存在于源目录的文件</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -av --delete source&#x2F; destination</span><br></pre></td></tr></table></figure>
--delete参数会<strong>使得destination成为source的一个镜像</strong></p>
<p>5.--exclude 参数, 同步时排除某些文件或目录</p>
<p>排除了所有 TXT 文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -av --exclude&#x3D;&#39;*.txt&#39; source&#x2F; destination</span><br><span class="line"># 或者</span><br><span class="line">$ rsync -av --exclude &#39;*.txt&#39; source&#x2F; destination</span><br></pre></td></tr></table></figure></p>
<p>要排除某个目录里面的所有文件，但不希望排除目录本身
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -av --exclude &#39;dir1&#x2F;*&#39; source&#x2F; destination</span><br></pre></td></tr></table></figure></p>
<p>多个排除模式，可以用多个--exclude参数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -av --exclude &#39;file1.txt&#39; --exclude &#39;dir1&#x2F;*&#39; source&#x2F; destination</span><br><span class="line">或者</span><br><span class="line">$ rsync -av --exclude&#x3D;&#123;&#39;file1.txt&#39;,&#39;dir1&#x2F;*&#39;&#125; source&#x2F; destination</span><br></pre></td></tr></table></figure></p>
<p>6.--include 参数，指定必须同步的文件模式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -av --include&#x3D;&quot;*.txt&quot; --exclude&#x3D;&#39;*&#39; source&#x2F; destination</span><br></pre></td></tr></table></figure></p>
<p>7.SSH 协议远程同步 将本地内容，同步到远程服务器
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -av source&#x2F; username@remote_host:destination</span><br></pre></td></tr></table></figure></p>
<p>将远程内容同步到本地
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -av username@remote_host:source&#x2F; destination</span><br></pre></td></tr></table></figure></p>
<p>如果 ssh 命令有附加的参数，则必须使用-e参数指定所要执行的 SSH 命令
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -av -e &#39;ssh -p 2234&#39; source&#x2F; user@remote_host:&#x2F;destination</span><br></pre></td></tr></table></figure></p>
<p>8.增量备份</p>
<p>rsync
的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。</p>
<p>除了源目录与目标目录直接比较，rsync
还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。
第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。</p>
<p>--link-dest参数用来指定<strong>同步时的基准目录</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rsync -a --delete --link-dest &#x2F;compare&#x2F;path &#x2F;source&#x2F;path &#x2F;target&#x2F;path</span><br></pre></td></tr></table></figure></p>
<p>--link-dest参数指定基准目录/compare/path，然后源目录/source/path跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录/target/path。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了。</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="http://www.ruanyifeng.com/blog/2020/08/rsync.html">rsync
用法教程</a></li>
</ol>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 13. 防火墙放行指定端口</title>
    <url>/2022/01/25/linux-13-%E9%98%B2%E7%81%AB%E5%A2%99%E6%94%BE%E8%A1%8C%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>今天遇到一个问题： linux服务器能被windows ping通, 但telnet
4000端口却不通， 而在linux 中 运行 <strong>lsof -i:4000</strong>
可以看到该端口LISTEN状态无异常。
猜测这是<strong>防火墙问题</strong>，借此机会简单了解下linux
防火墙相关的知识和指令 <a id="more"></a></p>
<h2><span id="1-iptables">1. Iptables</span><a href="#1-iptables" class="header-anchor">#</a></h2>
<p>Debian/Ubuntu系统自带防火墙大多是Iptables.</p>
<p>如何看系统类型呢？
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># uname -a</span><br><span class="line">Linux g37-dev-acfd361f 3.16.0-4-amd64 #1 SMP Debian 3.16.43-2+deb8u5 (2017-09-19) x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure>
#### 1.1 Iptables定义 <a href="https://en.wikipedia.org/wiki/Iptables">iptables(from
wikipedia)</a> is a user-space utility program that allows a system
administrator to configure the IP packet filter rules of the Linux
kernel firewall, implemented as different Netfilter modules.</p>
<h4><span id="1-2-iptables-an-zhuang">1.2 Iptables安装</span><a href="#1-2-iptables-an-zhuang" class="header-anchor">#</a></h4>
<p>Debian/Ubuntu系统一般都自带了, 先查看本机版本
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">liuwen03@g37-dev-acfd361f:~$ dpkg -l iptables</span><br><span class="line">Desired&#x3D;Unknown&#x2F;Install&#x2F;Remove&#x2F;Purge&#x2F;Hold</span><br><span class="line">| Status&#x3D;Not&#x2F;Inst&#x2F;Conf-files&#x2F;Unpacked&#x2F;halF-conf&#x2F;Half-inst&#x2F;trig-aWait&#x2F;Trig-pend</span><br><span class="line">|&#x2F; Err?&#x3D;(none)&#x2F;Reinst-required (Status,Err: uppercase&#x3D;bad)</span><br><span class="line">||&#x2F; Name                   Version          Architecture     Description</span><br><span class="line">+++-&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">ii  iptables               1.4.21-2+b1      amd64            administration tools for packet filtering and NAT</span><br></pre></td></tr></table></figure></p>
<p>如未安装, 命令如下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install iptables</span><br></pre></td></tr></table></figure>
#### 1.4 Iptables -h -h 查看帮助文档
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># iptables -h</span><br><span class="line">iptables v1.4.21</span><br><span class="line"></span><br><span class="line">Usage: iptables -[ACD] chain rule-specification [options]</span><br><span class="line">       iptables -I chain [rulenum] rule-specification [options]</span><br><span class="line">       iptables -R chain rulenum rule-specification [options]</span><br><span class="line">       iptables -D chain rulenum [options]</span><br><span class="line">       iptables -[LS] [chain [rulenum]] [options]</span><br><span class="line">       iptables -[FZ] [chain] [options]</span><br><span class="line">       iptables -[NX] chain</span><br><span class="line">       iptables -E old-chain-name new-chain-name</span><br><span class="line">       iptables -P chain target [options]</span><br><span class="line">       iptables -h (print this help information)</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">Either long or short options are allowed.</span><br><span class="line">  --append  -A chain            Append to chain</span><br><span class="line">  --check   -C chain            Check for the existence of a rule</span><br><span class="line">  --delete  -D chain            Delete matching rule from chain</span><br><span class="line">  --delete  -D chain rulenum</span><br><span class="line">                                Delete rule rulenum (1 &#x3D; first) from chain</span><br><span class="line">  --insert  -I chain [rulenum]</span><br><span class="line">                                Insert in chain as rulenum (default 1&#x3D;first)</span><br><span class="line">  --replace -R chain rulenum</span><br><span class="line">                                Replace rule rulenum (1 &#x3D; first) in chain</span><br><span class="line">  --list    -L [chain [rulenum]]</span><br><span class="line">                                List the rules in a chain or all chains</span><br><span class="line">  --list-rules -S [chain [rulenum]]</span><br><span class="line">                                Print the rules in a chain or all chains</span><br><span class="line">  --flush   -F [chain]          Delete all rules in  chain or all chains</span><br><span class="line">  --zero    -Z [chain [rulenum]]</span><br><span class="line">                                Zero counters in chain or all chains</span><br><span class="line">  --new     -N chain            Create a new user-defined chain</span><br><span class="line">  --delete-chain</span><br><span class="line">            -X [chain]          Delete a user-defined chain</span><br><span class="line">  --policy  -P chain target</span><br><span class="line">                                Change policy on chain to target</span><br><span class="line">  --rename-chain</span><br><span class="line">            -E old-chain new-chain</span><br><span class="line">                                Change chain name, (moving any references)</span><br><span class="line">Options:</span><br><span class="line">    --ipv4      -4              Nothing (line is ignored by ip6tables-restore)</span><br><span class="line">    --ipv6      -6              Error (line is ignored by iptables-restore)</span><br><span class="line">[!] --protocol  -p proto        protocol: by number or name, eg. &#96;tcp&#39;</span><br><span class="line">[!] --source    -s address[&#x2F;mask][...]</span><br><span class="line">                                source specification</span><br><span class="line">[!] --destination -d address[&#x2F;mask][...]</span><br><span class="line">                                destination specification</span><br><span class="line">[!] --in-interface -i input name[+]</span><br><span class="line">                                network interface name ([+] for wildcard)</span><br><span class="line"> --jump -j target</span><br><span class="line">                                target for rule (may load target extension)</span><br><span class="line">  --goto      -g chain</span><br><span class="line">                              jump to chain with no return</span><br><span class="line">  --match       -m match</span><br><span class="line">                                extended match (may load extension)</span><br><span class="line">  --numeric     -n              numeric output of addresses and ports</span><br><span class="line">[!] --out-interface -o output name[+]</span><br><span class="line">                                network interface name ([+] for wildcard)</span><br><span class="line">  --table       -t table        table to manipulate (default: &#96;filter&#39;)</span><br><span class="line">  --verbose     -v              verbose mode</span><br><span class="line">  --wait        -w              wait for the xtables lock</span><br><span class="line">  --line-numbers                print line numbers when listing</span><br><span class="line">  --exact       -x              expand numbers (display exact values)</span><br><span class="line">[!] --fragment  -f              match second or further fragments only</span><br><span class="line">  --modprobe&#x3D;&lt;command&gt;          try to insert modules using this command</span><br><span class="line">  --set-counters PKTS BYTES     set the counter during insert&#x2F;append</span><br><span class="line">[!] --version   -V              print package version.</span><br></pre></td></tr></table></figure></p>
<h4><span id="1-5-iptables-fang-huo-qiang-gui-ze">1.5 Iptables 防火墙规则</span><a href="#1-5-iptables-fang-huo-qiang-gui-ze" class="header-anchor">#</a></h4>
<p>--list 或 -L 可以查看当前防火墙规则
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># iptables --list</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             state RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  localhost.i.nease.net  anywhere</span><br><span class="line">ACCEPT     all  --  onlinegame.i.nease.net  anywhere</span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:32200</span><br><span class="line">DROP       all  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DOCKER-USER  all  --  anywhere             anywhere</span><br><span class="line">DOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  anywhere             anywhere</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-1 (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  anywhere             anywhere</span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-2 (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DROP       all  --  anywhere             anywhere</span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br></pre></td></tr></table></figure></p>
<p>如上所示, 有几条规则(Chain) - INPUT - 保存针对
<strong>进入此服务器的流量</strong>的规则 - FORWARD 保存
<strong>将转发到此服务器后面 IP的流量</strong>的规则（如
用当前服务器作其他服务器的防火墙）。 - OUTPUT 保存从 <strong>此服务器到
Internet 的流量</strong>的规则。</p>
<p>对于Chain INPUT, 其target列取值有如下三种： - ACCEPT: Traffic is
accepted for delivery. - REJECT: Traffic is rejected, sending a packet
back to the sending host. - DROP: The traffic is dropped. Nothing is
sent back to the sending host.</p>
<p>从Chain INPUT可以看出, 除个别ACCEPT的target, 其余的都会执行到DROP,
拦截其余接口</p>
<h4><span id="1-6-iptables-she-zhi-fang-huo-qiang-gui-ze">1.6 Iptables 设置防火墙规则</span><a href="#1-6-iptables-she-zhi-fang-huo-qiang-gui-ze" class="header-anchor">#</a></h4>
<p>如下是设置rules的常用指令 - -A: 'append' this rule to the end of the
INPUT Chain - -I: 'insert' this rule to the top of the INPUT Chain - -s:
Source Address. This rule only pertains to traffic coming FROM this IP.
Substitute with the IP address you are SSHing from. - -d: Destination
Address. This rule only pertains to traffic going TO this IP. Substitute
with the IP of this server. - -p: Protocol. Specifying traffic which is
TCP. - --dport: Destination Port. Specifying traffic which is for TCP
Port 22 (SSH) - -j: Jump. If everything in this rule matches then 'jump'
to ACCEPT - -D: Delete matching rule from chain</p>
<p>如1.5所示, 服务器上有一个监听 32200的tcp端口,
这个是ssh端口。而我需要的4000端口没在INPUT中 (这里需要使用-I 插入到头部)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 4000 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 对应的删除指令</span><br><span class="line">iptables -D INPUT -p tcp --dport 4000 -j ACCEPT</span><br></pre></td></tr></table></figure>
对于我的windows, 我希望linux服务器能不做拦截, 应该如何做呢?
如下指令就是开放端口给 ip xxx.xxx.xxx.xxx
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -s xxx.xxx.xxx.xxx -p all -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 对应的删除指令</span><br><span class="line">iptables -D INPUT -s xxx.xxx.xxx.xxx -p all -j ACCEPT</span><br></pre></td></tr></table></figure>
## 2. Centos Centos系统自带的防火墙是 firewall #### 放行特定端口
若要放行8888端口
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8888&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure>
命令含义：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--zone                      #作用域</span><br><span class="line">--add-port&#x3D;80&#x2F;tcp  #添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">--permanent           #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure>
然后重启防火墙
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
## 3.reference 1. <a href="https://www.howtoforge.com/linux_iptables_sarge">Basic Iptables -
Debian/RedHat</a></p>
]]></content>
      <categories>
        <category>problems solution</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 12. gdb dubugger</title>
    <url>/2021/07/06/linux-12-gdb-dubugger/</url>
    <content><![CDATA[<p>GDB, the GNU Project debugger,它诞生于 GNU 计划（同时诞生的还有
GCC、Emacs 等），是 Linux 下常用的程序调试器。
本文将对一些常用的gdb指令进行简单介绍。 <a id="more"></a> ## 启动GDB</p>
<h5><span id="debug-mou-ge-jin-cheng">debug 某个进程</span><a href="#debug-mou-ge-jin-cheng" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb -p 1234</span><br></pre></td></tr></table></figure>
<h5><span id="zhi-ding-can-shu">指定参数</span><a href="#zhi-ding-can-shu" class="header-anchor">#</a></h5>
<p>gdb bebug gcc, 并且设置gcc参数为 ‘-O2 -c foo.c’
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb --args gcc -O2 -c foo.c</span><br></pre></td></tr></table></figure></p>
<h2><span id="fan-hui-bian-xiang-guan">反汇编相关</span><a href="#fan-hui-bian-xiang-guan" class="header-anchor">#</a></h2>
<h5><span id="fan-hui-bian">反汇编</span><a href="#fan-hui-bian" class="header-anchor">#</a></h5>
<p><strong>disassemble</strong>
是以反汇编清单的形式输出内存的内容，表示的格式由命令<strong>set
disassembly-flavor</strong>确定
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000400506 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x0000000000400507 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x000000000040050a &lt;+4&gt;:     mov    $0x4005a4,%edi</span><br><span class="line">   0x000000000040050f &lt;+9&gt;:     mov    $0x0,%eax</span><br><span class="line">   0x0000000000400514 &lt;+14&gt;:    callq  0x4003e0 &lt;printf@plt&gt;</span><br><span class="line">   0x0000000000400519 &lt;+19&gt;:    pop    %rbp</span><br><span class="line">   0x000000000040051a &lt;+20&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></p>
<p>将汇编指令格式 <strong>设置为intel格式</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set disassembly-flavor intel </span><br></pre></td></tr></table></figure></p>
<h5><span id="she-zhi-duan-dian-b-break">设置断点 b / break</span><a href="#she-zhi-duan-dian-b-break" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># break 0x000000000040050f</span><br><span class="line"></span><br><span class="line"># b 0x000000000040050a</span><br></pre></td></tr></table></figure>
<h5><span id="lie-chu-suo-you-duan-dian">列出所有断点</span><a href="#lie-chu-suo-you-duan-dian" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">1       breakpoint     keep y   &lt;PENDING&gt;  0x000000000040050f</span><br><span class="line">2       breakpoint     keep y   &lt;PENDING&gt;  0x000000000040050a</span><br></pre></td></tr></table></figure>
<h5><span id="zhi-xing-run-dao-di-yi-ge-duan-dian-chu">执行run到第一个断点处</span><a href="#zhi-xing-run-dao-di-yi-ge-duan-dian-chu" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 2 at 0x40050a: file hello.c, line 4.</span><br><span class="line">Starting program: &#x2F;home&#x2F;xxx&#x2F;myfiles&#x2F;cpp_code&#x2F;hell</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 2, main () at hello.c:4</span><br><span class="line">4           printf(&quot;hello&quot;);</span><br><span class="line">4: &#x2F;x $eax &#x3D; 0x400506</span><br><span class="line">3: &#x2F;x $rsp &#x3D; 0x7fffffffe4c0</span><br><span class="line">2: &#x2F;x $edi &#x3D; 0x1</span><br><span class="line">1: &#x2F;x $rbp &#x3D; 0x7fffffffe4c0</span><br></pre></td></tr></table></figure>
<h5><span id="xian-shi-ji-cun-qi-de-zhi">显示寄存器的值</span><a href="#xian-shi-ji-cun-qi-de-zhi" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display &#x2F;x $eax</span><br></pre></td></tr></table></figure>
<h5><span id="she-zhi-he-xian-shi-can-shu">设置和显示参数</span><a href="#she-zhi-he-xian-shi-can-shu" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set args display &#x2F;x $eax</span><br><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is &quot;display &#x2F;x $eax&quot;</span><br></pre></td></tr></table></figure>
<h2><span id="huan-jing-xiang-guan">环境相关</span><a href="#huan-jing-xiang-guan" class="header-anchor">#</a></h2>
<h5><span id="path-directory">path directory</span><a href="#path-directory" class="header-anchor">#</a></h5>
<p>加入directory到运行查找路径
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) path leo&#x2F;mydir</span><br></pre></td></tr></table></figure></p>
<h5><span id="show-paths">show paths</span><a href="#show-paths" class="header-anchor">#</a></h5>
<p>打印运行时查找路径
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) show paths</span><br><span class="line">Executable and object file path: &#x2F;home&#x2F;xxx&#x2F;myfiles&#x2F;cpp_code&#x2F;directory:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5><span id="show-environment">show environment</span><a href="#show-environment" class="header-anchor">#</a></h5>
<p>打印环境变量
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) show environment</span><br><span class="line">TERM&#x3D;xterm</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">HISTSIZE&#x3D;10000</span><br><span class="line">SSH_CLIENT&#x3D;10.252.71.151 63267 32200</span><br><span class="line">SSH_TTY&#x3D;&#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">LC_ALL&#x3D;en_US.UTF-8</span><br><span class="line">HISTFILESIZE&#x3D;100000</span><br></pre></td></tr></table></figure></p>
<h5><span id="set-environment-varname-value">set environment varname
[=value]</span><a href="#set-environment-varname-value" class="header-anchor">#</a></h5>
<p>设置环境变量
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set env USER &#x3D; foo</span><br></pre></td></tr></table></figure></p>
<h5><span id="unset-environment-varname">unset environment varname</span><a href="#unset-environment-varname" class="header-anchor">#</a></h5>
<p>移除环境变量</p>
<h5><span id="pwd">pwd</span><a href="#pwd" class="header-anchor">#</a></h5>
<p>显示当前工作路径
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) pwd</span><br><span class="line">Working directory &#x2F;home&#x2F;xxx&#x2F;myfiles&#x2F;cpp_code.</span><br></pre></td></tr></table></figure></p>
<h5><span id="cd">cd</span><a href="#cd" class="header-anchor">#</a></h5>
<p>切换gdb工作路径
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) pwd</span><br><span class="line">Working directory &#x2F;home&#x2F;xxx&#x2F;myfiles&#x2F;cpp_code.</span><br><span class="line">(gdb) cd ~</span><br><span class="line">Working directory &#x2F;home&#x2F;xxx.</span><br></pre></td></tr></table></figure></p>
<h2><span id="cheng-xu-shu-ru-yu-shu-chu">程序输入与输出</span><a href="#cheng-xu-shu-ru-yu-shu-chu" class="header-anchor">#</a></h2>
<h5><span id="info-terminal">info terminal</span><a href="#info-terminal" class="header-anchor">#</a></h5>
<p>显示GDB保存的终端信息
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info terminal</span><br><span class="line">Inferior&#39;s terminal status (currently saved by GDB):</span><br><span class="line">File descriptor flags &#x3D; O_RDWR | 0x8000</span><br><span class="line">Process group &#x3D; 19973</span><br><span class="line">c_iflag &#x3D; 0xd00, c_oflag &#x3D; 0x5,</span><br><span class="line">c_cflag &#x3D; 0xbf, c_lflag &#x3D; 0x8a3b</span><br><span class="line">c_cc: 0x3 0x1c 0x8 0x15 0x4 0x0 0x1 0x0 0x11 0x13 0x1a 0x0 0x12 0xf 0x17 0x16 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br></pre></td></tr></table></figure></p>
<h5><span id="run-gt-outfile">run &gt; outfile</span><a href="#run-gt-outfile" class="header-anchor">#</a></h5>
<p>重定向输出</p>
<h2><span id="debug-zheng-zai-yun-xing-de-jin-cheng">debug正在运行的进程</span><a href="#debug-zheng-zai-yun-xing-de-jin-cheng" class="header-anchor">#</a></h2>
<p>由于之前使用<strong>Ctrl+Z</strong>强制退出，再次进入时报错 is
already traced by xxx
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb -p 22512 --quiet</span><br><span class="line">Attaching to process 22512</span><br><span class="line">warning: process 22512 is already traced by process 22307</span><br><span class="line">ptrace: Operation not permitted.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>jobs -l 找出正在终端运行的 process-id
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jobs -l</span><br><span class="line">[1]- 20412 Stopped                 sh export.sh</span><br><span class="line">[2]+ 22307 Stopped                 gdb -p 22512</span><br></pre></td></tr></table></figure></p>
<h5><span id="attach-jia-ru-jin-cheng">attach加入进程</span><a href="#attach-jia-ru-jin-cheng" class="header-anchor">#</a></h5>
<p>找到当前gdb运行进程 22307，<strong>attach</strong>进入
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) attach 22307</span><br><span class="line">Attaching to process 22307</span><br></pre></td></tr></table></figure></p>
<h5><span id="detach">detach</span><a href="#detach" class="header-anchor">#</a></h5>
<p><strong>释放</strong>gdb当前占有进程</p>
<h2><span id="yun-xing">运行</span><a href="#yun-xing" class="header-anchor">#</a></h2>
<h5><span id="step-yu-next">step 与 next</span><a href="#step-yu-next" class="header-anchor">#</a></h5>
<ul>
<li>step [count] 单步执行，会进入子函数内</li>
<li>next [count] 单行执行时，不进入子函数内</li>
</ul>
<h5><span id="step-mode">step-mode</span><a href="#step-mode" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set step-mode on</span><br><span class="line"></span><br><span class="line">set step-mode off</span><br></pre></td></tr></table></figure>
<p>step-mode on时, 对于没有debug行的function，
程序会停留在function的首条指令而不是跳过它。开启时可以详细查看机器指令</p>
<p>查看当前模式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show step-mode</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">Debugging with
GDB</a></li>
</ol>
]]></content>
      <categories>
        <category>linux tools</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 3.lsof命令</title>
    <url>/2020/12/16/linux-3-lsof%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="lsof-zuo-shi-me-de">lsof 做什么的</span><a href="#lsof-zuo-shi-me-de" class="header-anchor">#</a></h2>
<p>lsof（list open files）是一个
<strong>查看当前系统文件的工具</strong>。在linux环境下，任何事物
<strong>皆以文件的形式存在</strong>，通过文件不仅仅可以访问常规数据，还可以访问
<strong>网络连接和硬件</strong>。如传输控制协议 (TCP) 和用户数据报协议
(UDP) 套接字等，系统在后台都为该应用程序分配了一个
<strong>文件描述符</strong>，该文件描述符提供了大量关于这个应用程序本身的信息。</p>
<p>lsof打开的文件可以是：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>网络文件系统的文件</li>
<li>字符或设备文件</li>
<li>(函数)共享库</li>
<li>管道，命名管道</li>
<li>符号链接</li>
<li>网络文件（例如：NFS file、网络socket，unix域名socket）</li>
<li>or其它类型的文件</li>
</ul>
<p>由于 <strong>有时候</strong> lsof 需要
<strong>访问核心内存和各种文件</strong>，所以需要
<strong>root用户</strong>执行。</p>
<h2><span id="lsof-zen-me-yong">lsof 怎么用</span><a href="#lsof-zen-me-yong" class="header-anchor">#</a></h2>
<h3><span id="ming-ling-ge-shi">命令格式：</span><a href="#ming-ling-ge-shi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof [参数][文件]</span><br></pre></td></tr></table></figure>
<h3><span id="ming-ling-can-shu">命令参数：</span><a href="#ming-ling-can-shu" class="header-anchor">#</a></h3>
<ul>
<li>-a 列出打开文件 <strong>存在的进程</strong></li>
<li>-c<进程名> 列出指定进程所打开的文件</进程名></li>
<li>-g 列出GID号进程详情</li>
<li>-d<文件号> 列出占用该文件号的进程</文件号></li>
<li>+d<目录> 列出目录下被打开的文件</目录></li>
<li>+D<目录> 递归列出目录下被打开的文件</目录></li>
<li>-n<目录> 列出使用NFS的文件</目录></li>
<li>-i<条件> 列出 <strong>符合条件的进程</strong>。（4、6、协议、:端口、
<span class="citation" data-cites="ip">@ip</span> ）</条件></li>
<li>-p<进程号> 列出 <strong>指定进程号所打开的文件</strong></进程号></li>
<li>-u 列出UID号进程详情</li>
<li>-h 显示 帮助信息</li>
<li>-v 显示版本信息</li>
</ul>
<h2><span id="lsof-shi-li-fen-xi">lsof实例分析</span><a href="#lsof-shi-li-fen-xi" class="header-anchor">#</a></h2>
<h3><span id="example-1-wu-ren-he-can-shu">example 1: 无任何参数</span><a href="#example-1-wu-ren-he-can-shu" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof|more</span><br><span class="line"></span><br><span class="line">进程的名称  进程标识符       进程所有者</span><br><span class="line">COMMAND     PID   TID        USER   FD      TYPE             DEVICE SIZE&#x2F;OFF      NODE NAME</span><br><span class="line">systemd       1              root  cwd   unknown                                       &#x2F;proc&#x2F;1&#x2F;cwd (readlink: Permission denied)</span><br><span class="line">kthreadd      2              root  cwd   unknown                                       &#x2F;proc&#x2F;2&#x2F;cwd (readlink: Permission denied)</span><br><span class="line">kthreadd      2              root  rtd   unknown                                       &#x2F;proc&#x2F;2&#x2F;root (readlink: Permission denied)</span><br><span class="line">bash      24070          liuwen03  cwd       DIR             254,33     4096       614 &#x2F;home&#x2F;liuwen03</span><br><span class="line">bash      24070          liuwen03  rtd       DIR              253,0     4096       128 &#x2F;</span><br><span class="line">bash      24070          liuwen03  txt       REG              253,0  1029688  16819734 &#x2F;bin&#x2F;bash.19.so</span><br><span class="line">bash      24070          liuwen03  mem       REG              253,0    43592   8451394 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libnss_nis-2.19.so</span><br></pre></td></tr></table></figure>
<ul>
<li>COMMAND：进程的名称</li>
<li>PID：进程标识符</li>
<li>PPID：父进程标识符（需要指定-R参数）</li>
<li>USER：进程所有者</li>
<li>PGID：进程所属组</li>
<li>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</span><br><span class="line">（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序</span><br><span class="line">（3）lnn：library references (AIX);</span><br><span class="line">（4）er：FD information error (see NAME column);</span><br><span class="line">（5）jld：jail directory (FreeBSD);</span><br><span class="line">（6）ltx：shared library text (code and data);</span><br><span class="line">（7）mxx ：hex memory-mapped type number xx.</span><br><span class="line">（8）m86：DOS Merge mapped file;</span><br><span class="line">（9）mem：memory-mapped file;</span><br><span class="line">（10）mmap：memory-mapped device;</span><br><span class="line">（11）pd：parent directory;</span><br><span class="line">（12）rtd：root directory;</span><br><span class="line">（13）tr：kernel trace file (OpenBSD);</span><br><span class="line">（14）v86  VP&#x2F;ix mapped file;</span><br><span class="line">（15）0：表示标准输入</span><br><span class="line">（16）1：表示标准输出</span><br><span class="line">（17）2：表示标准错误</span><br><span class="line">一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等</span><br><span class="line">（1）u：表示该文件被打开并处于读取&#x2F;写入模式</span><br><span class="line">（2）r：表示该文件被打开并处于只读模式</span><br><span class="line">（3）w：表示该文件被打开并处于</span><br><span class="line">（4）空格：表示该文件的状态模式为unknow，且没有锁定</span><br><span class="line">（5）-：表示该文件的状态模式为unknow，且被锁定</span><br><span class="line">同时在文件状态模式后面，还跟着相关的锁</span><br><span class="line">（1）N：for a Solaris NFS lock of unknown type;</span><br><span class="line">（2）r：for read lock on part of the file;</span><br><span class="line">（3）R：for a read lock on the entire file;</span><br><span class="line">（4）w：for a write lock on part of the file;（文件的部分写锁）</span><br><span class="line">（5）W：for a write lock on the entire file;（整个文件的写锁）</span><br><span class="line">（6）u：for a read and write lock of any length;</span><br><span class="line">（7）U：for a lock of unknown type;</span><br><span class="line">（8）x：for an SCO OpenServer Xenix lock on part      of the file;</span><br><span class="line">（9）X：for an SCO OpenServer Xenix lock on the      entire file;</span><br><span class="line">（10）space：if there is no lock.</span><br></pre></td></tr></table></figure></li>
<li>TYPE：文件类型，如DIR、REG等，常见的文件类型:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）DIR：表示目录</span><br><span class="line">（2）CHR：表示字符类型</span><br><span class="line">（3）BLK：块设备类型</span><br><span class="line">（4）UNIX： UNIX 域套接字</span><br><span class="line">（5）FIFO：先进先出 (FIFO) 队列</span><br><span class="line">（6）IPv4：网际协议 (IP) 套接字</span><br><span class="line">（7）REG：常规文件</span><br></pre></td></tr></table></figure></li>
<li>DEVICE：指定磁盘的名称</li>
<li>SIZE：文件的大小</li>
<li>NODE：索引节点（文件在磁盘上的标识）</li>
<li>NAME：打开文件的确切名称</li>
</ul>
<h3><span id="example-2-mou-ge-wen-jian-xiang-guan-de-jin-cheng">example 2: 某个文件相关的进程</span><a href="#example-2-mou-ge-wen-jian-xiang-guan-de-jin-cheng" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">COMMAND   PID     USER  FD   TYPE DEVICE SIZE&#x2F;OFF     NODE NAME</span><br><span class="line">bash    15079 liuwen03 txt    REG  253,0  1029688 16819734 &#x2F;bin&#x2F;bash</span><br><span class="line">bash    15382 liuwen03 txt    REG  253,0  1029688 16819734 &#x2F;bin&#x2F;bash</span><br><span class="line">bash    15934 liuwen03 txt    REG  253,0  1029688 16819734 &#x2F;bin&#x2F;bash</span><br><span class="line">bash    24070 liuwen03 txt    REG  253,0  1029688 16819734 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h3><span id="example-3-mou-ge-yong-hu-da-kai-de-wen-jian-xin-xi">example
3：某个用户打开的文件信息</span><a href="#example-3-mou-ge-yong-hu-da-kai-de-wen-jian-xin-xi" class="header-anchor">#</a></h3>
<p>-u 选项，<strong>u是user的缩写</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -u liuwen03|more</span><br><span class="line"></span><br><span class="line">COMMAND     PID     USER   FD      TYPE             DEVICE SIZE&#x2F;OFF      NODE NAME</span><br><span class="line">lsof       2059 liuwen03  cwd       DIR             254,33     4096       614 &#x2F;home&#x2F;liuwen03</span><br><span class="line">lsof       2059 liuwen03  rtd       DIR              253,0     4096       128 &#x2F;</span><br><span class="line">lsof       2059 liuwen03  txt       REG              253,0   163192    605633 &#x2F;usr&#x2F;bin&#x2F;lsof</span><br><span class="line">lsof       2059 liuwen03  mem       REG              253,0    47712   8451392 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libnss_files-2.19.so</span><br><span class="line">...略</span><br></pre></td></tr></table></figure></p>
<h3><span id="example-4-mou-ge-cheng-xu-jin-cheng-suo-da-kai-de-wen-jian-xin-xi">example
4：某个程序进程所打开的文件信息</span><a href="#example-4-mou-ge-cheng-xu-jin-cheng-suo-da-kai-de-wen-jian-xin-xi" class="header-anchor">#</a></h3>
<p>-c 将会列出所有
<strong>以python这个进程开头的程序的文件</strong>，其实你可以写成
<strong>lsof | grep python</strong>, 但是
第一种方法明显比第二种方法要少打几个字符；
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -c python|more</span><br><span class="line"></span><br><span class="line">COMMAND   PID     USER   FD      TYPE             DEVICE SIZE&#x2F;OFF      NODE NAME</span><br><span class="line">python   1257     root  cwd   unknown                                       &#x2F;proc&#x2F;1257&#x2F;cwd (readlink: Permission denied)</span><br><span class="line">python   1257     root  txt   unknown                                       &#x2F;proc&#x2F;1257&#x2F;exe (readlink: Permission denied)</span><br><span class="line">python   1257     root NOFD                                                 &#x2F;proc&#x2F;1257&#x2F;fd (opendir: Permission denied)</span><br><span class="line">python   2834 liuwen03  cwd       DIR             254,33     4096   4294389 &#x2F;home&#x2F;liuwen03&#x2F;Dev&#x2F;medal_and_tv&#x2F;G37Server&#x2F;dc&#x2F;dc</span><br><span class="line">python   2834 liuwen03  rtd       DIR              253,0     4096       128 &#x2F;</span><br><span class="line">python   2834 liuwen03  txt       REG              253,0  3777864    180384 &#x2F;usr&#x2F;bin&#x2F;python2.7</span><br><span class="line">...略</span><br></pre></td></tr></table></figure></p>
<h3><span id="example-5-mou-ge-yong-hu-yi-ji-mou-ge-jin-cheng-suo-da-kai-de-wen-jian-xin-xi">example 5:
某个用户以及某个进程所打开的文件信息</span><a href="#example-5-mou-ge-yong-hu-yi-ji-mou-ge-jin-cheng-suo-da-kai-de-wen-jian-xin-xi" class="header-anchor">#</a></h3>
<p>其实就是上面 3 和 4 的组合拳
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof  -u liuwen03 -c python</span><br></pre></td></tr></table></figure></p>
<h3><span id="example-6-xian-shi-mou-ge-jin-cheng-da-kai-de-wen-jian">example 6:显示
某个进程打开的文件</span><a href="#example-6-xian-shi-mou-ge-jin-cheng-da-kai-de-wen-jian" class="header-anchor">#</a></h3>
<p>列出 2834 进程打开的文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -p 2834</span><br><span class="line">COMMAND  PID     USER   FD   TYPE    DEVICE SIZE&#x2F;OFF      NODE NAME</span><br><span class="line">python  2834 liuwen03  cwd    DIR    254,33     4096   4294389 &#x2F;home&#x2F;liuwen03&#x2F;Dev&#x2F;medal_and_tv&#x2F;G37Server&#x2F;dc&#x2F;dc</span><br><span class="line">python  2834 liuwen03  rtd    DIR     253,0     4096       128 &#x2F;</span><br><span class="line">...略</span><br></pre></td></tr></table></figure></p>
<h3><span id="example-7-lie-chu-suo-you-de-wang-luo-lian-jie">example 7：列出所有的网络连接</span><a href="#example-7-lie-chu-suo-you-de-wang-luo-lian-jie" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -i|more</span><br><span class="line"></span><br><span class="line">COMMAND  PID     USER   FD   TYPE    DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">python  2834 liuwen03    7u  IPv4 215114357      0t0  TCP *:27183 (LISTEN)</span><br><span class="line">python  2843 liuwen03    4u  IPv4 215901528      0t0  TCP localhost.i.nease.net:34189-&gt;localhost.i.nease.net:4000 (ESTABLISHED)</span><br><span class="line">...略</span><br></pre></td></tr></table></figure>
<h3><span id="example-8-lie-chu-suo-you-udp-tcp-wang-luo-lian-jie">example 8：列出所有udp/tcp
网络连接</span><a href="#example-8-lie-chu-suo-you-udp-tcp-wang-luo-lian-jie" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -i udp|more</span><br><span class="line">COMMAND  PID     USER   FD   TYPE    DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">python  4797 liuwen03   10u  IPv4 215901407      0t0  UDP *:4000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -i tcp|more</span><br></pre></td></tr></table></figure>
<h3><span id="example-9-lie-chu-shui-zai-shi-yong-mou-ge-duan-kou">example
9：列出谁在使用某个端口</span><a href="#example-9-lie-chu-shui-zai-shi-yong-mou-ge-duan-kou" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -i :4000</span><br><span class="line"></span><br><span class="line">COMMAND  PID     USER   FD   TYPE    DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">python  2843 liuwen03    4u  IPv4 215901528      0t0  TCP localhost.i.nease.net:34189-&gt;localhost.i.nease.net:4000 (ESTABLISHED)</span><br><span class="line">python  2844 liuwen03    4u  IPv4 215901525      0t0  TCP localhost.i.nease.net:34187-&gt;localhost.i.nease.net:4000 (ESTABLISHED)</span><br><span class="line">python  2845 liuwen03    4u  IPv4 215896898      0t0  TCP localhost.i.nease.net:34188-&gt;localhost.i.nease.net:4000 (ESTABLISHED)</span><br><span class="line">python  4797 liuwen03    8u  IPv4 215900363      0t0  TCP *:4000 (LISTEN)</span><br><span class="line">python  4797 liuwen03   10u  IPv4 215901407      0t0  UDP *:4000</span><br></pre></td></tr></table></figure>
<h3><span id="example-10-lie-chu-mou-ge-yong-hu-de-suo-you-huo-yue-de-wang-luo-duan-kou">example
10：列出某个用户的所有活跃的网络端口</span><a href="#example-10-lie-chu-mou-ge-yong-hu-de-suo-you-huo-yue-de-wang-luo-duan-kou" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -a -u liuwen03 -i|more</span><br><span class="line"></span><br><span class="line">COMMAND  PID     USER   FD   TYPE    DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">python  2834 liuwen03    7u  IPv4 215114357      0t0  TCP *:27183 (LISTEN)</span><br><span class="line">python  2843 liuwen03    4u  IPv4 215901528      0t0  TCP localhost.i.nease.net:34189-&gt;localhost.i.nease.net:4000 (ESTABLISHED)</span><br><span class="line">...略</span><br></pre></td></tr></table></figure>
<h3><span id="example-11-lie-chu-bei-jin-cheng-hao-wei-1234-de-jin-cheng-suo-da-kai-de-suo-you-ipv4-network-files">example
11：列出被进程号为1234的进程所打开的所有IPV4 network files</span><a href="#example-11-lie-chu-bei-jin-cheng-hao-wei-1234-de-jin-cheng-suo-da-kai-de-suo-you-ipv4-network-files" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$lsof -i 4 -a -p 4678</span><br><span class="line"></span><br><span class="line">COMMAND  PID     USER   FD   TYPE    DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">python  4678 liuwen03    7u  IPv4 215900052      0t0  TCP localhost.i.nease.net:54076-&gt;localhost.i.nease.net:x11 (ESTABLISHED)</span><br><span class="line">python  4678 liuwen03    8u  IPv4 215900054      0t0  TCP localhost.i.nease.net:39381-&gt;localhost.i.nease.net:30000 (ESTABLISHED)</span><br><span class="line">...略</span><br></pre></td></tr></table></figure>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<p>1.<a href="https://www.cnblogs.com/peida/archive/2013/02/26/2932972.html" title="每天一个linux命令（51）：lsof命令">每天一个linux命令（51）：lsof命令</a></p>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 2.curl命令行工具</title>
    <url>/2020/11/24/linux-2-curl%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>curl 是常用的命令行工具(其实并非linux下的,windows
cmd也有，只是我在linux下使用),用来请求 Web 服务器。它的名字就是
<strong>客户端（client）的 URL 工具</strong>的意思。</p>
<p>不带有任何参数时，curl 就是发出 <strong>GET</strong> 请求。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure></p>
<h2><span id="d">-d</span><a href="#d" class="header-anchor">#</a></h2>
<p>-d参数用于发送 <strong>POST 请求</strong>的数据体。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -d&#39;login&#x3D;2333＆password&#x3D;2333&#39;-X POST https:&#x2F;&#x2F;google.com&#x2F;login</span><br></pre></td></tr></table></figure></p>
<h2><span id="x">-X</span><a href="#x" class="header-anchor">#</a></h2>
<p>-X参数 <strong>指定 HTTP 请求</strong>的方法。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST https:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure></p>
<h2><span id="h">-H</span><a href="#h" class="header-anchor">#</a></h2>
<p>-H参数 <strong>添加 HTTP 请求的标头</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -H &#39;Accept-Language: en-US&#39; https:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure>
上面命令添加 HTTP 标头Accept-Language: en-US。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -H &#39;Accept-Language: en-US&#39; -H &#39;Secret-Message: xyzzy&#39; https:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure>
<p>上面命令 <strong>添加两个 HTTP 标头</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -d &#39;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#39; -H &#39;Content-Type: application&#x2F;json&#39; https:&#x2F;&#x2F;google.com&#x2F;login</span><br></pre></td></tr></table></figure>
上面命令 <strong>添加 HTTP 请求的标头是Content-Type:
application/json</strong>，然后用-d参数发送 JSON 数据。</p>
<h2><span id="v">-v</span><a href="#v" class="header-anchor">#</a></h2>
<ul>
<li>-v参数输出通信的整个过程，用于调试。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -v https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure></li>
<li>-trace参数也可以用于调试，还会输出原始的二进制数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --trace - https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>
<h2><span id="o">-o</span><a href="#o" class="header-anchor">#</a></h2>
<p>-o参数将服务器的回应
<strong>保存成文件</strong>，等同于wget命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -o baidu.html https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>
<p>上面命令将www.baidu.com保存成baidu.html。</p>
<h1><span id="bao-cuo-curl-35-unknown-ssl-protocol-error-in-connection-to-localhost-27183">报错curl:
(35) Unknown SSL protocol error in connection to localhost:27183</span><a href="#bao-cuo-curl-35-unknown-ssl-protocol-error-in-connection-to-localhost-27183" class="header-anchor">#</a></h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -v https:&#x2F;&#x2F;localhost:27183&#x2F;abc</span><br><span class="line">* Hostname was NOT found in DNS cache</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* Connected to localhost (127.0.0.1) port 27183 (#0)</span><br><span class="line">* successfully set certificate verify locations:</span><br><span class="line">*   CAfile: none</span><br><span class="line">  CApath: &#x2F;etc&#x2F;ssl&#x2F;certs</span><br><span class="line">* SSLv3, TLS handshake, Client hello (1):</span><br><span class="line">* Unknown SSL protocol error in connection to localhost:27183</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (35) Unknown SSL protocol error in connection to localhost:27183</span><br></pre></td></tr></table></figure>
<p><strong>Possible reason</strong>：没有证书，本地用
<strong>http</strong>不能用https</p>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 4.grep,tail等查看文件命令</title>
    <url>/2020/12/16/linux-4-grep-tail%E7%AD%89%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="du-qu-wen-jian-zhi-tail-ming-ling">读取文件之 tail 命令</span><a href="#du-qu-wen-jian-zhi-tail-ming-ling" class="header-anchor">#</a></h2>
<p>'tail' 命令
<strong>显示文件最后几行内容</strong>，读取log神奇。<strong>默认读取文件最后
10 行内容</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail &lt;file name&gt;  </span><br></pre></td></tr></table></figure>
<p>如
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tail log.txt  </span><br></pre></td></tr></table></figure></p>
<h4><span id="tail-n">'tail -n'</span><a href="#tail-n" class="header-anchor">#</a></h4>
<p>语法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n&lt;number&gt; &lt;file name&gt;  </span><br><span class="line"># tail -n&lt;行数&gt; &lt;文件名称&gt;</span><br></pre></td></tr></table></figure>
如读取最后5行:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tail -n5 log.txt  </span><br></pre></td></tr></table></figure></p>
<h4><span id="tail-c-xuan-xiang">'tail -c' 选项</span><a href="#tail-c-xuan-xiang" class="header-anchor">#</a></h4>
<p>tail -c 命令选项显示
<strong>文件以指定字符计数的最后内容</strong>。</p>
<p>语法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -c&lt;number&gt; &lt;file name&gt;  </span><br><span class="line">#tail -c&lt;字符数&gt; &lt;文件名称&gt;</span><br></pre></td></tr></table></figure>
如：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tail -c10 log.game*</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; log.game1 &lt;&#x3D;&#x3D;</span><br><span class="line">028.76777</span><br><span class="line">&#x3D;&#x3D;&gt; log.game2 &lt;&#x3D;&#x3D;</span><br><span class="line">028.77236</span><br></pre></td></tr></table></figure>
显示 log.game为前缀 文件的 <strong>最后 10 个字符内容信息</strong>。</p>
<h4><span id="tail-f">'tail -f'</span><a href="#tail-f" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f log.test*</span><br></pre></td></tr></table></figure>
<p>当前语句可以将 log.test1, log.test2等以 <strong>log.test
打头</strong>文件的 <strong>初始最后十行</strong> 和
<strong>追加显示</strong>,这个是 <strong>看log神器</strong></p>
<h4><span id="tail-a">'tail -a'</span><a href="#tail-a" class="header-anchor">#</a></h4>
<p>有时使用 grep命令会提示 <strong>"binary file matches </strong>.log"**
从提示可以看出,该文件是个二进制文本。</p>
<p>此时使用 <strong>-a</strong>参数接口。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -a test XXX.log</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a, --text equivalent to --binary-files&#x3D;text，即让二进制文件等价于文本。</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="du-qu-wen-jian-zhi-grep-ming-ling">读取文件之 grep 命令</span><a href="#du-qu-wen-jian-zhi-grep-ming-ling" class="header-anchor">#</a></h2>
<h4><span id="c-xian-shi-dang-qian-you-duo-shao-tiao">-c 显示当前有多少条</span><a href="#c-xian-shi-dang-qian-you-duo-shao-tiao" class="header-anchor">#</a></h4>
<p>这个语句非常 <strong>necessary</strong>, 因为log太多时，查找可能会
<strong>爆内存</strong>，先看看log有多少条（配合tail -n100等语句使用）。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$grep &quot;leo&quot; .&#x2F;log&#x2F;log.ga* -c</span><br><span class="line"></span><br><span class="line">.&#x2F;log&#x2F;log.ga1:0</span><br><span class="line">.&#x2F;log&#x2F;log.ga2:175</span><br></pre></td></tr></table></figure></p>
<h4><span id="xu-man-zu-suo-you-tiao-jian">需满足所有条件</span><a href="#xu-man-zu-suo-you-tiao-jian" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep word1 file.txt | grep word2 |grep word3</span><br></pre></td></tr></table></figure>
<h4><span id="man-zu-ren-yi-tiao-jian">满足任意条件</span><a href="#man-zu-ren-yi-tiao-jian" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E &quot;word1|word2|word3&quot;   file.txt</span><br></pre></td></tr></table></figure>
<h4><span id="sou-suo-han-you-track-zi-duan-de-log">搜索含有Track字段的log</span><a href="#sou-suo-han-you-track-zi-duan-de-log" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep Trace log.txt</span><br><span class="line">grep &quot;Trace&quot; log.txt</span><br></pre></td></tr></table></figure>
<h4><span id="duo-wen-jian-cha-zhao">多文件查找</span><a href="#duo-wen-jian-cha-zhao" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep Trace file_1 file_2 file_3 ...</span><br></pre></td></tr></table></figure>
<h4><span id="shu-chu-chu-trace-zhi-wai-de-suo-you-xing-v-xuan-xiang">输出除 Trace 之外的所有行 -v
选项：</span><a href="#shu-chu-chu-trace-zhi-wai-de-suo-you-xing-v-xuan-xiang" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v Trace file_name</span><br></pre></td></tr></table></figure>
<h4><span id="biao-ji-pi-pei-yan-se-color-auto-xuan-xiang">标记匹配颜色 --color=auto
选项：</span><a href="#biao-ji-pi-pei-yan-se-color-auto-xuan-xiang" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Trace&quot; file_name --color&#x3D;auto</span><br></pre></td></tr></table></figure>
<h4><span id="shi-yong-zheng-ze-biao-da-shi-e-xuan-xiang">使用正则表达式 -E 选项：</span><a href="#shi-yong-zheng-ze-biao-da-shi-e-xuan-xiang" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E &quot;[1-9]+&quot;</span><br><span class="line">或</span><br><span class="line">egrep &quot;[1-9]+&quot;</span><br></pre></td></tr></table></figure>
<h4><span id="zhi-shu-chu-wen-jian-zhong-pi-pei-dao-de-bu-fen-o-xuan-xiang">只输出文件中匹配到的部分 -o
选项：</span><a href="#zhi-shu-chu-wen-jian-zhong-pi-pei-dao-de-bu-fen-o-xuan-xiang" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo this is a test line. | grep -o -E &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line">echo this is a test line. | egrep -o &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br></pre></td></tr></table></figure>
<h4><span id="tong-ji-wen-jian-huo-zhe-wen-ben-zhong-bao-han-pi-pei-zi-fu-chuan-de-xing-shu-c-xuan-xiang">统计文件或者文本中包含匹配字符串的行数
-c 选项：</span><a href="#tong-ji-wen-jian-huo-zhe-wen-ben-zhong-bao-han-pi-pei-zi-fu-chuan-de-xing-shu-c-xuan-xiang" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -c &quot;Trace&quot; file_name</span><br></pre></td></tr></table></figure>
<h4><span id="shu-chu-bao-han-pi-pei-zi-fu-chuan-de-xing-shu-n-xuan-xiang">输出包含匹配字符串的行数 -n
选项：</span><a href="#shu-chu-bao-han-pi-pei-zi-fu-chuan-de-xing-shu-n-xuan-xiang" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Trace&quot; -n file_name</span><br><span class="line">或</span><br><span class="line">cat file_name | grep &quot;Trace&quot; -n</span><br></pre></td></tr></table></figure>
<h4><span id="duo-ge-wen-jian">多个文件</span><a href="#duo-ge-wen-jian" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Trace&quot; -n file_1 file_2</span><br></pre></td></tr></table></figure>
<h4><span id="da-yin-yang-shi-pi-pei-suo-wei-yu-de-zi-fu-huo-zi-jie-pian-yi">打印样式匹配所位于的字符或字节偏移：</span><a href="#da-yin-yang-shi-pi-pei-suo-wei-yu-de-zi-fu-huo-zi-jie-pian-yi" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo gun is not unix | grep -b -o &quot;not&quot;</span><br><span class="line">7:not</span><br><span class="line">#一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。</span><br></pre></td></tr></table></figure>
<h4><span id="sou-suo-duo-ge-wen-jian-bing-cha-zhao-pi-pei-wen-ben-zai-na-xie-wen-jian-zhong-l">搜索多个文件并查找匹配文本在哪些文件中
-l：</span><a href="#sou-suo-duo-ge-wen-jian-bing-cha-zhao-pi-pei-wen-ben-zai-na-xie-wen-jian-zhong-l" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -l &quot;Trace&quot; file1 file2 file3...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 5.vim指令</title>
    <url>/2021/01/05/linux-5-vim%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1><span id="what-is-vim">what is vim？</span><a href="#what-is-vim" class="header-anchor">#</a></h1>
<p>Vim是从 vi 发展出来的一个 <strong>文本编辑器</strong>。简单的来说，
vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。
vim 则可以说是程序开发者的一项很好用的工具。</p>
<h1><span id="vim-de-mo-shi">vim 的模式</span><a href="#vim-de-mo-shi" class="header-anchor">#</a></h1>
<p>vim 共分为三种模式，分别是： - 命令模式（Command mode） -
输入模式（Insert mode） - 底线命令模式（Last line mode）</p>
<h2><span id="ming-ling-mo-shi">命令模式</span><a href="#ming-ling-mo-shi" class="header-anchor">#</a></h2>
<p>用户刚刚启动 vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为<strong>命令</strong>，而非输入字符。下面列举常用的命令模式</p>
<h3><span id="cha-zhao-yu-ti-huan">查找 与 替换</span><a href="#cha-zhao-yu-ti-huan" class="header-anchor">#</a></h3>
<h4><span id="cha-zhao">查找</span><a href="#cha-zhao" class="header-anchor">#</a></h4>
<ul>
<li><strong>Command模式</strong>下按 <strong>“/”</strong>
即可进入查找模式，<strong>输入要查找的字符串</strong>并
按下<strong>Enter</strong>。 Vim会跳转到第一个匹配。 按下
<strong>“n”</strong> 查找下一个，按下 <strong>“N”</strong>
查找上一个</li>
<li>在查找模式中加入 示大小写不敏感查找，表示大小写敏感查找, 例如
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;foo\c</span><br></pre></td></tr></table></figure></li>
</ul>
<h4><span id="ti-huan">替换</span><a href="#ti-huan" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&#123;作用范围&#125;s&#x2F;&#123;目标&#125;&#x2F;&#123;替换&#125;&#x2F;&#123;替换标志&#125;</span><br></pre></td></tr></table></figure>
<p>例如 在全局范围(%)查找 foo 并替换为 bar，所有出现都会被替换（g）</p>
<h5><span id="zuo-yong-fan-wei">作用范围</span><a href="#zuo-yong-fan-wei" class="header-anchor">#</a></h5>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th>作用范围</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>当前行</td>
<td>:s/foo/bar/g</td>
</tr>
<tr>
<td>全文</td>
<td>:%s/foo/bar/g</td>
</tr>
<tr>
<td>选区，在 Visual 模式下选择区域后输入 :，Vim 即可自动补全为
:'&lt;,'&gt;。</td>
<td>:'&lt;,'&gt;s/foo/bar/g</td>
</tr>
<tr>
<td>2-11 行</td>
<td>:2,11s/foo/bar/g</td>
</tr>
<tr>
<td>当前行 . 与接下来两行 +2</td>
<td>:.,+2s/foo/bar/g</td>
</tr>
</tbody>
</table>
<h5><span id="ti-huan-biao-zhi-fu">替换标志符</span><a href="#ti-huan-biao-zhi-fu" class="header-anchor">#</a></h5>
<table>
<thead>
<tr>
<th>替换标志符</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>只替换从光标位置开始，目标的第一次出现</td>
<td>:%s/foo/bar</td>
</tr>
<tr>
<td>i 表示大小写不敏感查找</td>
<td>:%s/foo/bar/i</td>
</tr>
<tr>
<td>I 表示大小写敏感</td>
<td>:%s/foo/bar/I</td>
</tr>
<tr>
<td>c 表示需要确认</td>
<td>:%s/foo/bar/c</td>
</tr>
<tr>
<td>g 表示全局 global 替换</td>
<td>:%s/foo/bar/gc</td>
</tr>
</tbody>
</table>
<h3><span id="cha-ru">插入</span><a href="#cha-ru" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----进入输入模式(Insert mode)-----</span><br><span class="line">i               当前位置前插入</span><br><span class="line">I               当前行首插入</span><br><span class="line"></span><br><span class="line">a               当前位置后插入</span><br><span class="line">A               当前行尾插入</span><br><span class="line"></span><br><span class="line">o               当前行之后插入一行</span><br><span class="line">O               当前行之前插入一行</span><br><span class="line"></span><br><span class="line">-----进入取代模式(Replace mode)-----</span><br><span class="line">r               取代光标所在的那一个字符一次</span><br><span class="line">R               一直取代光标所在的文字，直到按下 ESC 为止</span><br></pre></td></tr></table></figure>
<h3><span id="yi-dong">移动</span><a href="#yi-dong" class="header-anchor">#</a></h3>
<h4><span id="yi-xing-wei-dan-wei-yi-dong">以行为单位移动</span><a href="#yi-xing-wei-dan-wei-yi-dong" class="header-anchor">#</a></h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>移动到行首第一个词的首字母。</td>
</tr>
<tr>
<td>|</td>
<td>移动到<strong>行首第一个字符</strong>。</td>
</tr>
<tr>
<td>$</td>
<td>移动到<strong>行尾</strong>。</td>
</tr>
<tr>
<td>j</td>
<td>移动到下一行。</td>
</tr>
<tr>
<td>k</td>
<td>移动到上一行。</td>
</tr>
<tr>
<td>:10</td>
<td>移动光标到文件第 10 行。可以 :set number 来让 vim 显示行号。</td>
</tr>
<tr>
<td>gg</td>
<td>移动到<strong>文件首行</strong>。</td>
</tr>
<tr>
<td>G</td>
<td>移动到<strong>文件尾行</strong>。</td>
</tr>
</tbody>
</table>
<h4><span id="yi-ping-mu-wei-dan-wei-yi-dong">以屏幕为单位移动</span><a href="#yi-ping-mu-wei-dan-wei-yi-dong" class="header-anchor">#</a></h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + e</td>
<td>向下滚动一行</td>
</tr>
<tr>
<td>Ctrl + y</td>
<td>向上滚动一行</td>
</tr>
<tr>
<td>Ctrl + d(down)</td>
<td>向下滚动半屏</td>
</tr>
<tr>
<td>Ctrl + u(up)</td>
<td>向上滚动半屏</td>
</tr>
<tr>
<td>Ctrl + f(forward)</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl + b(back)</td>
<td>向上滚动一屏</td>
</tr>
<tr>
<td>Shift + g</td>
<td>切换到最后</td>
</tr>
</tbody>
</table>
<h4><span id="yi-dan-ci-wei-dan-wei-yi-dong">以单词为单位移动</span><a href="#yi-dan-ci-wei-dan-wei-yi-dong" class="header-anchor">#</a></h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>w</td>
<td>移动到下一个单词的词首</td>
</tr>
<tr>
<td>b</td>
<td>移动到上一个单词的词首</td>
</tr>
<tr>
<td>e</td>
<td>移动到下一个单词的结尾</td>
</tr>
</tbody>
</table>
<h3><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor">#</a></h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X
为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td>nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符，
『10x』。</td>
</tr>
<tr>
<td>dd</td>
<td>删除游标所在的那一整行(常用)</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行
(常用)</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td>d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td>d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
</tbody>
</table>
<h3><span id="fu-zhi">复制</span><a href="#fu-zhi" class="header-anchor">#</a></h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20
行(常用)</td>
</tr>
<tr>
<td>y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td>yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td>y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td>y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td>p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！
举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那
10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？
那么原本的第 20 行会被推到变成 30 行。 (常用)</td>
</tr>
</tbody>
</table>
<h3><span id="che-xiao-yu-chong-zuo">撤销与重做</span><a href="#che-xiao-yu-chong-zuo" class="header-anchor">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>撤销 (常用)</td>
</tr>
<tr>
<td>[Ctrl]+r</td>
<td>重做上一个动作 (常用)</td>
</tr>
</tbody>
</table>
<h3><span id="cha-kan-li-shi-shu-ru">查看历史输入</span><a href="#cha-kan-li-shi-shu-ru" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q + (Ctrl + :)</span><br></pre></td></tr></table></figure>
<h2><span id="shu-ru-mo-shi">输入模式</span><a href="#shu-ru-mo-shi" class="header-anchor">#</a></h2>
<p>在命令模式下按下
<strong>i</strong>就进入了输入模式。在输入模式中，可以使用以下按键：</p>
<ul>
<li>字符按键以及Shift组合，输入字符</li>
<li>ENTER，回车键，换行</li>
<li>BACK SPACE，退格键，<strong>删除光标前一个字符</strong></li>
<li>DEL，删除键，<strong>删除光标后一个字符</strong></li>
<li>方向键，在文本中移动光标</li>
<li>HOME/END，移动光标到行首/行尾</li>
<li>Page Up/Page Down，上/下翻页</li>
<li>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li>ESC，退出输入模式，<strong>切换到命令模式</strong></li>
</ul>
<h2><span id="di-xian-ming-ling-mo-shi">底线命令模式</span><a href="#di-xian-ming-ling-mo-shi" class="header-anchor">#</a></h2>
<p>在命令模式下按下 <strong>:（英文冒号）</strong>
就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:q          退出程序</span><br><span class="line">:q!         若曾修改过档案，又不想储存，使用 ! 为强制离开不储存</span><br><span class="line">:w          保存文件</span><br><span class="line">:w!         若文件属性为『只读』时，强制写入该档案。到底能不能写入， 还是跟权限有关</span><br><span class="line"></span><br><span class="line">----环境的变更----</span><br><span class="line">:set nu      显示行号，设定之后，会在每一行的前缀显示该行的行号</span><br><span class="line">:set nonu    与 set nu 相反，为取消行号</span><br><span class="line"></span><br><span class="line">ESC         退出底线命令模式</span><br></pre></td></tr></table></figure>
惊叹号 <strong>("!")</strong> 在 vim 当中，常常具有『强制』的意思</p>
<h2><span id="geng-gai-vim-pei-zhi">更改vim配置</span><a href="#geng-gai-vim-pei-zhi" class="header-anchor">#</a></h2>
<p>打开配置文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;vim&#x2F;vimrc</span><br></pre></td></tr></table></figure>
如设置显示行号, 跳转到文本末尾, 输入
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set number  &quot;显示行号</span><br></pre></td></tr></table></figure></p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<p>1.<a href="https://www.runoob.com/linux/linux-vim.html" title="Linux vi/vim">Linux vi/vim</a></p>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 7.ln指令</title>
    <url>/2021/02/04/linux-7-ln%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux ln命令是一个非常重要而且常用命令，它用于
<strong>为文件或者目录创建链接</strong>。</p>
<h2><span id="links-types">Links types</span><a href="#links-types" class="header-anchor">#</a></h2>
<p><a href="http://liuw.tech/2021/02/21/深入理解linux-2-soft-link-hard-link/">soft
link/hard link</a></p>
<h2><span id="shi-yong-fang-fa">使用方法</span><a href="#shi-yong-fang-fa" class="header-anchor">#</a></h2>
<h3><span id="p-mo-ren-ye-shi-chuang-jian-hard-links">-P （默认也是）创建 Hard links</span><a href="#p-mo-ren-ye-shi-chuang-jian-hard-links" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ln -P my_file.txt my_link.txt</span><br><span class="line"></span><br><span class="line">$ ln my_file.txt my_link.txt</span><br></pre></td></tr></table></figure>
<h3><span id="s-chuang-jian-symlinks-soft-links">-s 创建 Symlinks(Soft links)</span><a href="#s-chuang-jian-symlinks-soft-links" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ln -s [OPTIONS] FILE LINK</span><br></pre></td></tr></table></figure>
<ul>
<li><ol type="1">
<li>创建一个软链接 my_link.txt, 指向my_file.txt
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ln -s my_file.txt my_link.txt</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><ol start="2" type="1">
<li>给文件创建 Symlinks
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ln -s &#x2F;mnt&#x2F;my_drive&#x2F;movies ~&#x2F;my_movies</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<h3><span id="f-force-qiang-zhi-fu-gai">-f (--force) 强制覆盖</span><a href="#f-force-qiang-zhi-fu-gai" class="header-anchor">#</a></h3>
<p>如果创建一个已经存在的 Symlinks, 会报错
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ln -s my_file.txt my_link.txt</span><br><span class="line"></span><br><span class="line">ln: failed to create symbolic link &#39;my_link.txt&#39;: File exists</span><br></pre></td></tr></table></figure></p>
<p>使用 <strong>-f 强制覆盖</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ln -sf my_file.txt my_link.txt</span><br></pre></td></tr></table></figure></p>
<h3><span id="yi-chu-symlinks">移除Symlinks</span><a href="#yi-chu-symlinks" class="header-anchor">#</a></h3>
<ul>
<li>unlink
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unlink symlink_to_remove</span><br></pre></td></tr></table></figure></li>
<li>rm
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ symlink_to_remove</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注： 不要在文件末尾加上 "/"</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://linuxize.com/post/how-to-create-symbolic-links-in-linux-using-the-ln-command/" title="Ln Command in Linux">Ln Command in Linux</a></li>
<li><a href="https://www.linuxrumen.com/cyml/50.html">Linux软链接和硬链接的区别之ln命令详解</a></li>
</ol>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 6.awk指令--linux三剑客boss</title>
    <url>/2021/01/20/linux-6-awk%E6%8C%87%E4%BB%A4-linux%E4%B8%89%E5%89%91%E5%AE%A2boss/</url>
    <content><![CDATA[<h2><span id="jiang-hu-chuan-yan-linux-you-san-jian-ke-er-awk-shi-san-jian-ke-de-lao-da-li-jian-chu-qiao-qian-long-sheng-tian">江湖传言linux有三剑客,
而awk 是三剑客的老大。利剑出鞘,潜龙升天。</span><a href="#jiang-hu-chuan-yan-linux-you-san-jian-ke-er-awk-shi-san-jian-ke-de-lao-da-li-jian-chu-qiao-qian-long-sheng-tian" class="header-anchor">#</a></h2>
<h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2>
<p>awk属于
<strong>一种编程语言</strong>，可以通过编程实现各种需要的<strong>文本处理需求</strong>。awk在其对
<strong>数据分析</strong>并生成报告时，显得尤为强大。简单来说awk就是把文件
<strong>逐行的读入</strong>，以
<strong>空格为默认分隔符</strong>将每行切片，切开的部分再进行各种分析处理。</p>
<p>awk有3个不同版本:
awk、nawk和gawk，未作特别说明，<strong>一般指gawk</strong>，gawk 是 AWK
的 GNU 版本。</p>
<h3><span id="awk-gong-zuo-liu-cheng">awk工作流程：</span><a href="#awk-gong-zuo-liu-cheng" class="header-anchor">#</a></h3>
<p>读入有
<strong>''换行符分割的一条记录</strong>，然后将记录按指定的域<strong>分隔符划分域</strong>，填充域，<strong>$0</strong>则表示<strong>所有域(原记录)</strong>,<strong><span class="math inline">\(1**表示**第一个域**,\)</span>n表示第n个域。</strong>默认<strong>域分隔符是
</strong>空白键 或 tab键**。</p>
<h2><span id="ji-ben-yong-fa">基本用法:</span><a href="#ji-ben-yong-fa" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk [选项参数] &#39;BEGIN&#123;命令 &#125; pattern&#123; 命令 &#125; END&#123; 命令 &#125;&#39;  文件名    # 行匹配语句 awk &#39;&#39; 只能用单引号</span><br></pre></td></tr></table></figure>
<h3><span id="pattern-mo-kuai">pattern模块</span><a href="#pattern-mo-kuai" class="header-anchor">#</a></h3>
<h4><span id="da-yin-mou-ji-lie">打印某几列</span><a href="#da-yin-mou-ji-lie" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;i am so busy&#39; | awk &#39;&#123;print $1, $2 $3&#125;&#39;</span><br><span class="line">i amso</span><br></pre></td></tr></table></figure>
<h4><span id="xuan-xiang-can-shu">选项参数</span><a href="#xuan-xiang-can-shu" class="header-anchor">#</a></h4>
<p>-F参数：指定分隔符
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;192.168.1.1&#39; | awk -F &quot;.&quot; &#39;&#123;print $2&#125;&#39;</span><br><span class="line">168</span><br><span class="line"></span><br><span class="line">$ echo &#39;I am leo。my qq is xxxxxx&#39; |awk -F &#39;[ ,]+&#39; &#39;&#123;print $3&quot; &quot;$7&#125;&#39;    # 多个分隔符</span><br><span class="line">leo xxxxxx</span><br></pre></td></tr></table></figure>
- 我们将字符串 i am so busy
通过管道传递给awk命令，相当于awk处理一个文件，该文件的内容就是i am so
busy,默认通过空格作为分隔符(不管列之间有多少个空格都将当作一个空格处理)i
am so busy就分割成四列了。 - 另外，我们发现pattern{ 命令
}中","输出时为空格" "。</p>
<h3><span id="begin-ding-yi-biao-tou">BEGIN 定义表头</span><a href="#begin-ding-yi-biao-tou" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat score.txt</span><br><span class="line">tom 60 60 60</span><br><span class="line">kitty 90 95 87</span><br><span class="line">jack 72 84 99</span><br><span class="line"></span><br><span class="line">$ awk &#39;BEGIN&#123;print &quot;姓名 语文 数学 英语&quot;&#125;&#123;printf &quot;%-8s%-5d%-5d%-5d\n&quot;,$1,$2,$3,$4&#125;&#39; score.txt     # 左对齐的操作(%-8s左对齐，宽8位)</span><br><span class="line"></span><br><span class="line">姓名 语文数学英语</span><br><span class="line">tom 60 60 60</span><br><span class="line">kitty 90 95 87</span><br><span class="line">jack 72 84 99</span><br></pre></td></tr></table></figure>
<h3><span id="end">END</span><a href="#end" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;BEGIN&#123;print &quot;姓名 语文 数学 英语 总成绩&quot;; \</span><br><span class="line">sum1&#x3D;0;sum2&#x3D;0;sum3&#x3D;0;sumall&#x3D;0&#125; \              # 这里定义了初始值</span><br><span class="line">&#123;printf &quot;%5s%5d%5d%5d%5d\n&quot;,$1,$2,$3,$4,$2+$3+$4;\</span><br><span class="line">sum1+&#x3D;$2;sum2+&#x3D;$3;sum3+&#x3D;$4;sumall+&#x3D;$2+$3+$4&#125;\</span><br><span class="line">END&#123;printf &quot;%5s%5d%5d%5d%5d\n&quot;,&quot;总成绩&quot;,sum1,sum2,sum3,sumall&#125;&#39;\</span><br><span class="line"> score.txt</span><br><span class="line"></span><br><span class="line">姓名 语文 数学 英语 总成绩</span><br><span class="line">  tom 60 60 60 180</span><br><span class="line">kitty 90 95 87 272</span><br><span class="line"> jack 72 84 99 255</span><br><span class="line">总成绩 222 239 246 707</span><br></pre></td></tr></table></figure>
<h2><span id="yun-suan-fu">运算符</span><a href="#yun-suan-fu" class="header-anchor">#</a></h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>= += -= *= /= %= ^= **=</td>
<td>赋值</td>
</tr>
<tr>
<td>?:</td>
<td>C条件表达式</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>~ 和 !~</td>
<td>匹配正则表达式和不匹配正则表达式</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= != ==</td>
<td>关系运算符</td>
</tr>
<tr>
<td>空格</td>
<td>连接</td>
</tr>
<tr>
<td>+ -</td>
<td>加，减</td>
</tr>
<tr>
<td>* / %</td>
<td>乘，除与求余</td>
</tr>
<tr>
<td>+ - !</td>
<td>一元加，减和逻辑非</td>
</tr>
<tr>
<td>^ ***</td>
<td>求幂</td>
</tr>
<tr>
<td>++ --</td>
<td>增加或减少，作为前缀或后缀</td>
</tr>
<tr>
<td>$</td>
<td>字段引用</td>
</tr>
<tr>
<td>in</td>
<td>数组成员</td>
</tr>
</tbody>
</table>
<h5><span id="example1-guo-lu-di-yi-lie-da-yu-2-de-xing">example1:过滤第一列大于2的行</span><a href="#example1-guo-lu-di-yi-lie-da-yu-2-de-xing" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;$1&gt;2&#39; log.txt    #命令</span><br><span class="line">#输出</span><br><span class="line">3 Are you like awk</span><br><span class="line">This&#39;s a test</span><br><span class="line">10 There are orange,apple,mongo</span><br></pre></td></tr></table></figure>
<h4><span id="exmple2-shu-chu-qi-shu-xing">exmple2：输出奇数行</span><a href="#exmple2-shu-chu-qi-shu-xing" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim demo.txt</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;usr&#x2F;bin&#x2F;zsh</span><br><span class="line">daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin</span><br><span class="line">bin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin</span><br><span class="line">sys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologin</span><br><span class="line">sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync</span><br><span class="line"></span><br><span class="line">$ awk -F &#39;:&#39; &#39;NR % 2 &#x3D;&#x3D; 1 &#123;print $1&#125;&#39; demo.txt</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">sync</span><br></pre></td></tr></table></figure>
<h4><span id="exmple3-shu-chu-di-yi-ge-zi-duan-deng-yu-zhi-ding-zhi-de-xing">exmple3：输出第一个字段等于指定值的行</span><a href="#exmple3-shu-chu-di-yi-ge-zi-duan-deng-yu-zhi-ding-zhi-de-xing" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -F &#39;:&#39; &#39;$1 &#x3D;&#x3D; &quot;root&quot; &#123;print $1&#125;&#39; demo.txt</span><br><span class="line">root</span><br><span class="line"></span><br><span class="line">$ awk -F &#39;:&#39; &#39;$1 &#x3D;&#x3D; &quot;root&quot; || $1 &#x3D;&#x3D; &quot;bin&quot; &#123;print $1&#125;&#39; demo.txt</span><br><span class="line">root</span><br><span class="line">bin</span><br></pre></td></tr></table></figure>
<h2><span id="if-yu-ju">if语句</span><a href="#if-yu-ju" class="header-anchor">#</a></h2>
<h5><span id="example1-shan-yong-if-else-pan-duan-yu-ju">example1:善用if else判断语句</span><a href="#example1-shan-yong-if-else-pan-duan-yu-ju" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;if($2&gt;&#x3D;90 )print $0&#125;&#39; score.txt</span><br><span class="line">kitty 90 95 87</span><br><span class="line">$ awk &#39;&#123;if($2&gt;&#x3D;90 )print $1,&quot;优秀&quot;; else print $1,&quot;良好&quot;&#125;&#39; score.txt</span><br><span class="line">tom 良好</span><br><span class="line">kitty 优秀</span><br><span class="line">jack 良好</span><br></pre></td></tr></table></figure>
<h2><span id="nei-zhi-bian-liang">内置变量</span><a href="#nei-zhi-bian-liang" class="header-anchor">#</a></h2>
<p>常用内置变量：</p>
<ul>
<li>FILENAME： 用于保存输入文件名称,<strong>当前文件名</strong>。</li>
<li>NF： 一条记录的 <strong>字段的数目</strong>。</li>
<li>NR：已经读出的记录数，就是
<strong>行号</strong>，<strong>从1开始</strong></li>
<li>OFS：用于设置输出分隔字符字符，默认空格。</li>
<li>FS：字段分隔符(默认是任何空格)。</li>
<li>ORS：用于设置输出记录分隔符，默认为新的一行。</li>
<li>RS：记录分隔符(默认是一个换行符)。</li>
<li>OFMT：<strong>数字的输出格式</strong>(默认值是%.6g)。</li>
<li>ENVIRON：读取环境变量。</li>
</ul>
<h5><span id="example1-zhi-cha-kan-test-txt-wen-jian-di-20-dao-di-30-xing">example1:只查看test.txt文件第20到第30行</span><a href="#example1-zhi-cha-kan-test-txt-wen-jian-di-20-dao-di-30-xing" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;if(NR&gt;&#x3D;20 &amp;&amp; NR&lt;&#x3D;30) print $0&#125;&#39; test.txt </span><br></pre></td></tr></table></figure>
<h4><span id="example2-bao-liu-xiao-shu-dian-hou-liang-wei">example2:保留小数点后两位</span><a href="#example2-bao-liu-xiao-shu-dian-hou-liang-wei" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;BEGIN&#123;OFMT&#x3D;&quot;%.2f&quot;;print 1.2567,12E-2&#125;&#39;</span><br><span class="line">1.26 0.12</span><br></pre></td></tr></table></figure>
<h4><span id="shu-chu-dao-shu-di-er-ge-zi-duan">输出倒数第二个字段</span><a href="#shu-chu-dao-shu-di-er-ge-zi-duan" class="header-anchor">#</a></h4>
<p>变量 <strong>NF</strong>表示当前行有多少个字段，因此 <strong><span class="math inline">\(NF**就代表 **最后一个字段**。
**\)</span>(NF-1)</strong>代表 <strong>倒数第二个字段</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -F &#39;:&#39; &#39;&#123;print $1, $(NF-1)&#125;&#39; demo.txt</span><br><span class="line">root &#x2F;root</span><br><span class="line">daemon &#x2F;usr&#x2F;sbin</span><br><span class="line">bin &#x2F;bin</span><br><span class="line">sys &#x2F;dev</span><br><span class="line">sync &#x2F;bin</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<p>1.<a href="https://zhuanlan.zhihu.com/p/35520021" title="awk 详解">awk 详解</a> 2.<a href="https://zhuanlan.zhihu.com/p/70482897" title="Linux三剑客传 | 老大：AWK">ILinux三剑客传 | 老大：AWK</a> 3.<a href="https://www.ruanyifeng.com/blog/2018/11/awk.html" title="awk 入门教程">awk 入门教程</a></p>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 8.nohup命令</title>
    <url>/2021/03/04/linux-8-nohup%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="nohup">nohup</span><a href="#nohup" class="header-anchor">#</a></h2>
<p>nohup在 <strong>忽略hangup signals</strong>的情况下运行给定命令,
可以实现
<strong>退出帐户/关闭终端</strong>之后<strong>继续运行相应的进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup command [arg]…</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在缺省情况下该作业的所有输出都被
<strong>重定向</strong>到一个名为<strong>nohup.out</strong>的文件中。</p></li>
<li><p>如果当前目录的 nohup.out 文件不可写，输出重定向到
<strong>$HOME/nohup.out</strong> 文件中。</p></li>
</ul>
<p>若要输出到
<strong>nohup.out以外</strong>的文件中，可以<strong>对其进行重定向</strong>。例如
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup make &gt; make.log</span><br></pre></td></tr></table></figure></p>
<ul>
<li>nohup
<strong>不会自动</strong>将它运行的命令放在后台；必须通过在命令行末尾
<strong>加上“＆”</strong>。</li>
</ul>
<h2><span id="nohup-he-amp-de-qu-bie">nohup和&amp;的区别</span><a href="#nohup-he-amp-de-qu-bie" class="header-anchor">#</a></h2>
<ul>
<li><p>&amp; ： 指在后台运行</p></li>
<li><p>nohup ： 不挂断的运行，注意
<strong>并没有后台运行的功能</strong>。用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；<strong>&amp;才是后台运行</strong></p></li>
<li><p>&amp;是指在后台运行，但当<strong>用户退出</strong>(挂起)的时候，<strong>命令</strong>自动也跟着<strong>退出</strong></p></li>
</ul>
<h4><span id="example-1">example 1</span><a href="#example-1" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh test.sh &amp; </span><br></pre></td></tr></table></figure>
<p>将sh test.sh任务放到后台
，<strong>关闭xshell</strong>，对应的<strong>任务</strong>也跟着<strong>停止</strong>。</p>
<h4><span id="example-2">example 2</span><a href="#example-2" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup sh test.sh  </span><br></pre></td></tr></table></figure>
<p>将sh
test.sh任务<strong>放到后台</strong>，<strong>关闭标准输入</strong>，终端<strong>不再能够接收任何输入（标准输入）</strong>，重定向标准输出和标准错误到当前目录下的<strong>nohup.out文件</strong>，即使<strong>关闭xshell退出当前session依然继续运行</strong>。</p>
<h4><span id="example-3">example 3</span><a href="#example-3" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup sh test.sh  &amp; </span><br></pre></td></tr></table></figure>
<p>将sh
test.sh任务<strong>放到后台</strong>，但是依然<strong>可以使用标准输入</strong>，<strong>终端能够接收任何输入</strong>，重定向标准输出和标准错误到<strong>当前目录下的nohup.out文件</strong>，即使<strong>关闭xshell退出当前session依然继续运行</strong>。</p>
<h4><span id="example-4">example 4</span><a href="#example-4" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup command &gt; myout.file 2&gt;&amp;1 &amp;   </span><br></pre></td></tr></table></figure>
<p>在上面的例子中，0 – stdin (standard input)，1 – stdout (standard
output)，2 – stderr (standard
error)；2&gt;&amp;1是<strong>将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file</strong>文件中。</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="http://www.gnu.org/software/coreutils/manual/html_node/nohup-invocation.html#nohup-invocation">nohup:
Run a command immune to hangups</a></li>
<li><a href="https://www.cnblogs.com/jinxiao-pu/p/9131057.html">nohup
详解</a></li>
</ol>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[linux] 9.crontab定期执行命令</title>
    <url>/2021/03/31/linux-9-crontab%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="what-is-crontab">what is crontab</span><a href="#what-is-crontab" class="header-anchor">#</a></h2>
<p><a href="https://man7.org/linux/man-pages/man5/crontab.5.html">crontab</a>
used to schedule the execution of programs(<strong>每分钟</strong>).
crontab被daemon进程所管理。 <a id="more"></a> -
用户各自定义<strong>的crontab</strong>, crontab下的Commands也只会
<strong>运行在从属的用户下</strong>.</p>
<ul>
<li><p>crond
命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p></li>
<li><p>注意：新创建的 cron 任务，不会马上执行，<strong>至少要过 2
分钟后才可以</strong>，当然你可以重启 cron 来马上执行。</p></li>
</ul>
<p>linux 任务调度的工作主要分为以下两类：</p>
<ol type="1">
<li>系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</li>
<li>个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</li>
</ol>
<h2><span id="how-to-use">how to use</span><a href="#how-to-use" class="header-anchor">#</a></h2>
<p>语法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab [ -u user ] &#123; -l | -r | -e &#125;</span><br></pre></td></tr></table></figure>
- u user 是指设定指定 user 的时程表。如不使用 -u user 的话, 默认
<strong>设定自己的时程表</strong>。</p>
<p>参数说明：</p>
<ul>
<li>e : 执行<strong>文字编辑器来设定时程表</strong>，内定的文字编辑器是
VI</li>
<li>r : <strong>删除</strong>目前的时程表</li>
<li>l : <strong>列出</strong>目前的时程表</li>
</ul>
<p>时间格式如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 command</span><br></pre></td></tr></table></figure>
- 当 f1 为 * 时表示每分钟都要执行 program，f2 为 *
时表示每小时都要执行程序 - 当 f1 为 a-b 时表示从第 a 分钟到第 b
分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行 - 当 f1
为 <em>/n 时表示每 n 分钟个时间间隔执行一次，f2 为 </em>/n 表示每 n
小时个时间间隔执行一次 - 当 f1 为 a, b, c,... 时表示第 a, b, c,...
分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12) </span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br></pre></td></tr></table></figure></p>
<h4><span id="more-example">more example</span><a href="#more-example" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * &#x2F;bin&#x2F;ls  # 每一分钟执行一次 &#x2F;bin&#x2F;ls</span><br><span class="line"></span><br><span class="line">20 0-23&#x2F;2 * * * echo &quot;haha&quot; # 每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....执行 echo &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">30 6 *&#x2F;10 * * ls  # 每月的1、11、21、31日是的6：30执行一次ls命令</span><br><span class="line"></span><br><span class="line">5 4 * * sun  echo &quot;run at 5 after 4 every sunday&quot;</span><br></pre></td></tr></table></figure>
<h2><span id="shi-ji-yun-yong">实际运用</span><a href="#shi-ji-yun-yong" class="header-anchor">#</a></h2>
<p>之前遇到了如下问题: <a href="http://liuw.tech/2021/06/09/problems-solution-linux%EF%BC%9Acannot-create-temp-file-for-here-document-No-space-left-on-device/">cannot
create temp file for here-document: No space left on device</a>
这是由于/var/log/里的log很快就满了, 因此使用crontab定期清理一波日志</p>
<h5><span id="1-qie-huan-dao-root">1.切换到root</span><a href="#1-qie-huan-dao-root" class="header-anchor">#</a></h5>
<p>只有root才有权限清理/var/log/文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>
##### 2. 编辑crontab
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
设置 <strong>每天早上10点</strong>定期清理日志文件, 如下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 10 * * * echo &quot;&quot; &gt; &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">* 10 * * * echo &quot;&quot; &gt; &#x2F;var&#x2F;log&#x2F;syslog</span><br></pre></td></tr></table></figure>
##### 3. 查看crontab是否生效
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># crontab -l</span><br><span class="line">* 10 * * * echo &quot;&quot; &gt; &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">* 10 * * * echo &quot;&quot; &gt; &#x2F;var&#x2F;log&#x2F;syslog</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://man7.org/linux/man-pages/man5/crontab.5.html">crontab</a></li>
<li><a href="https://www.runoob.com/linux/linux-comm-crontab.html">linux
crontab命令</a></li>
</ol>
]]></content>
      <categories>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[machine learning] 1.basic knowledge</title>
    <url>/2019/12/15/machine-learning-1-basic-knowledge/</url>
    <content><![CDATA[<p>这个专题主要是总结一下读《统计学习》的一些知识点，这一章简单介绍一些机器学习的相关概念。</p>
<h2><span id="tong-ji-xue-xi-san-yao-su">统计学习三要素</span><a href="#tong-ji-xue-xi-san-yao-su" class="header-anchor">#</a></h2>
<h3><span id="1-mo-xing-tiao-jian-gai-lu-fen-bu-huo-jue-ce-han-shu">1.模型 条件概率分布或决策函数</span><a href="#1-mo-xing-tiao-jian-gai-lu-fen-bu-huo-jue-ce-han-shu" class="header-anchor">#</a></h3>
<h3><span id="2-ce-lue">2.策略</span><a href="#2-ce-lue" class="header-anchor">#</a></h3>
<ol type="1">
<li>损失函数和风险函数</li>
<li>经验风险最小化和结构风险最小化</li>
</ol>
<ul>
<li><strong>经验风险最小化</strong>：当样本足够大时，可以保证很好效果，但
<strong>样本小</strong>时，往往会
<strong>过拟合</strong>（loss均值）</li>
<li><strong>结构风险最小化（structural
minimization，SRM）</strong>：为防止过拟合提出的策略， 等价于
<strong>正则化（regularization）</strong> ， 加入正则化项regularizer，
或罚项 penalty term。结构越复杂，正则化项（惩罚项）越大。</li>
</ul>
<h3><span id="3-suan-fa">3.算法</span><a href="#3-suan-fa" class="header-anchor">#</a></h3>
<h2><span id="guo-ni-he">过拟合</span><a href="#guo-ni-he" class="header-anchor">#</a></h2>
<ul>
<li>若一味追求提高训练数据的预测能力,
<strong>所选模型的复杂度往往比真是模型要高</strong>，这种现象叫过拟合。</li>
<li>过拟合也指学习时
<strong>选择的模型所包含的参数过多</strong>，以至于出现这一模型
<strong>对已知数据拟合很好，对于未知数据拟合很差</strong>。 可以说
<strong>模型选择旨在避免过拟合并且提高模型的预测能力</strong>。</li>
</ul>
<h2><span id="jiao-cha-yan-zheng">交叉验证</span><a href="#jiao-cha-yan-zheng" class="header-anchor">#</a></h2>
<p>训练集（训练数据）+ 验证集（模型选择）+ 测试集（测试）</p>
<h2><span id="fan-hua-neng-li">泛化能力</span><a href="#fan-hua-neng-li" class="header-anchor">#</a></h2>
<p>指该方法学习到的模型
<strong>对未知数据的预测能力</strong>，是学习方法本质上重要的性质。最多通过
<strong>测试误差来评价</strong>。</p>
<p>比较学习方法的泛化能力:比较 <strong>泛化误差上界</strong> 性质：
<strong>样本容量增加， 泛化误差趋于0</strong> 假设空间容量越大，
泛化误差越大</p>
<h2><span id="sheng-cheng-mo-xing-he-pan-bie-mo-xing">生成模型和判别模型</span><a href="#sheng-cheng-mo-xing-he-pan-bie-mo-xing" class="header-anchor">#</a></h2>
<p>根据P(X,Y)，求出条件概率分布P(Y|X)作为预测的模型，即生成模型P(Y|X)=P（X，Y）/P(X)
(给定输入X，产生输出Y的关系)</p>
<p><strong>生成方法</strong>： - 可还原出联合概率分布P(X,Y),
而判别方法不能。 生成方法的
<strong>收敛速度更快</strong>,当样本容量增加的时候，
学到的模型可以更快地收敛于真实模型； <strong>当存在隐变量时，
仍可以使用生成方法， 而判别方法则不能用</strong>。 -
由数据直接学习决策函数f(x)或条件概率分布 P(Y|X)作为预测模型
<strong>(K近邻法、 感知机、 决策树、 logistic回归模型、 最大熵模型、
支持向量机、 提升方法和条件随机场。)</strong></p>
<p><strong>判别方法</strong>： -
直接学习到条件概率或决策函数,<strong>直接进行预测</strong>,往往学习的
<strong>准确率更高</strong>;由于直接学习Y=f(X)或P(Y|X),可对数据进行各种程度上的
<strong>抽象、 定义特征并使用特征</strong>， 因此可以简化学习过程。</p>
<h2><span id="hui-gui-wen-ti">回归问题</span><a href="#hui-gui-wen-ti" class="header-anchor">#</a></h2>
<p>回归学习最常用的损失函数是 <strong>平方损失函数</strong>，
在此情况下， 回归问题可以由 著名的 <strong>最小二乘法(least
squares)</strong>求解。</p>
<h2><span id="biao-zhu-wen-ti">标注问题</span><a href="#biao-zhu-wen-ti" class="header-anchor">#</a></h2>
<p>监督学习，分类问题的推广，又是更复杂的结构预测（structure
prediction）问题的简单形式。</p>
<p>标注： tagging， 结构预测： structure prediction 输入： 观测序列，
输出： 标记序列或状态序列 学习和标注（预测）两个过程</p>
]]></content>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>[machine learning] 2.感知机</title>
    <url>/2019/12/15/machine-learning-2-%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<h2><span id="gan-zhi-ji">感知机</span><a href="#gan-zhi-ji" class="header-anchor">#</a></h2>
<p>输入为实例的特征向量,输出为实例的类别,取+1和-1;</p>
<p>感知机对应于输入空间中将实例划分为
<strong>正负两类</strong>的分离超平面,属于
<strong>判别模型</strong>;</p>
<p>导入 <strong>基于误分类的损失函数</strong>;</p>
<p>利用 <strong>梯度下降法</strong>对损失函数进行极小化;</p>
<p>感知机学习算法具有简单而易于实现的优点,分为
<strong>原始形式和对偶形式</strong>;</p>
<p>1957年由Rosenblatt提出,是
<strong>神经网络与支持向量机的基础</strong>。</p>
<h3><span id="ding-yi">定义</span><a href="#ding-yi" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f（x)&#x3D;sign(w*x+b)  </span><br></pre></td></tr></table></figure>
<p><strong>几何解释</strong>： 线性方程 w*x+b，=0
对应于超平面S，w为法向量，b为截距</p>
<h3><span id="ding-yi-sun-shi-han-shu">定义损失函数</span><a href="#ding-yi-sun-shi-han-shu" class="header-anchor">#</a></h3>
<p><img src="https://wx1.sinaimg.cn/mw1024/8746d7begy1g075iwuknoj20ot0hgwn2.jpg">
<img src="https://wx1.sinaimg.cn/mw1024/8746d7begy1g05trjcx4yj20mn07btaa.jpg">
<img src="https://wx1.sinaimg.cn/mw1024/8746d7begy1g05u16f5g4j20ni0a4jsx.jpg"></p>
<h3><span id="suan-fa">算法</span><a href="#suan-fa" class="header-anchor">#</a></h3>
<p><img src="https://wx4.sinaimg.cn/mw1024/8746d7begy1g05u16iygnj20na0cbtdi.jpg">
<img src="https://wx3.sinaimg.cn/mw1024/8746d7begy1g05u16h422j20nt0jfad9.jpg">
<img src="https://wx3.sinaimg.cn/mw1024/8746d7begy1g05u16iz5ej20ks0lan1f.jpg"></p>
<h3><span id="dui-ou-xing">对偶性</span><a href="#dui-ou-xing" class="header-anchor">#</a></h3>
<p><img src="https://wx1.sinaimg.cn/mw1024/8746d7begy1g05ufuy5ofj20mt0jp112.jpg">
<img src="https://wx2.sinaimg.cn/mw1024/8746d7begy1g05ufuvo0oj20mx0e4whw.jpg"></p>
]]></content>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>[mongo] 1.brief introdution</title>
    <url>/2021/01/06/mongo-1-brief-introdution/</url>
    <content><![CDATA[<h1><span id="what-is-mongodb">what is MongoDB</span><a href="#what-is-mongodb" class="header-anchor">#</a></h1>
<p>MongoDB 是一个
<strong>基于分布式文件存储</strong>的开源数据库系统。由
<strong>C++</strong> 语言编写。旨在为 <strong>WEB</strong>
应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB 是一个
<strong>介于关系数据库和非关系数据库之间</strong>的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>在高负载的情况下，添加更多的节点，可以保证服务器性能。</p>
<p>MongoDB 将数据存储为一个 <strong>文档</strong>，数据结构由
<strong>键值(key=&gt;value)对组成</strong>。MongoDB 文档类似于
<strong>JSON 对象</strong>。字段值
<strong>可以包含其他文档，数组及文档数组</strong>。</p>
<h1><span id="the-feature-of-mongodb">the feature of MongoDB</span><a href="#the-feature-of-mongodb" class="header-anchor">#</a></h1>
<ol type="1">
<li>MongoDB
是一个<strong>面向文档存储的数据库</strong>，操作起来比较简单和容易。</li>
<li>你可以在MongoDB记录中<strong>设置任何属性的索引</strong>
(如：FirstName="Sameer",Address="8 Gandhi
Road")来<strong>实现更快的排序</strong>。</li>
<li>你可以通过本地或者网络<strong>创建数据镜像</strong>，这使得MongoDB有<strong>更强的扩展性</strong>。</li>
<li>如果负载的增加（需要更多的存储空间和更强的处理能力）
，它可以<strong>分布在计算机网络中的其他节点</strong>上这就是所谓的<strong>分片</strong>。</li>
<li>Mongo支持<strong>丰富的查询表达式</strong>。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li>
<li>MongoDb
使用<strong>update()命令</strong>可以实现<strong>替换完成的文档（数据）</strong>或者一些指定的数据字段
。</li>
<li>Mongodb中的Map/reduce主要是用来<strong>对数据进行批量处理和聚合操作</strong>。</li>
<li><strong>Map和Reduce</strong>。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</li>
<li>Map函数和Reduce函数是使用Javascript编写的，并可以<strong>通过db.runCommand或mapreduce命令来执行MapReduce操作</strong>。</li>
<li><strong>GridFS</strong>是MongoDB中的一个内置功能，可以用于<strong>存放大量小文件</strong>。</li>
<li><strong>允许在服务端执行脚本</strong>，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li>
<li>支持
<strong>各种编程语言</strong>:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li>
</ol>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<p>1.<a href="https://www.runoob.com/mongodb/mongodb-intro.html" title="MongoDB 教程">MongoDB 教程</a> 2.<a href="https://docs.mongodb.com/manual/introduction/" title="Introduction to MongoDB">Introduction to MongoDB</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>[mongo] couldn&#39;t connect to server 127.0.0.1:27017</title>
    <url>/2021/04/06/mongo-couldn-t-connect-to-server-127-0-0-1-27017/</url>
    <content><![CDATA[<h2><span id="cuo-wu-pai-cha">错误排查</span><a href="#cuo-wu-pai-cha" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mongo</span><br><span class="line">MongoDB shell version: 3.0.12</span><br><span class="line">connecting to: test</span><br><span class="line">2021-04-06T10:58:44.862+0800 W NETWORK  Failed to connect to 127.0.0.1:27017, reason: errno:111 Connection refused</span><br><span class="line">2021-04-06T10:58:44.864+0800 E QUERY    Error: couldn&#39;t connect to server 127.0.0.1:27017 (127.0.0.1), connection attempt failed</span><br><span class="line">    at connect (src&#x2F;mongo&#x2F;shell&#x2F;mongo.js:179:14)</span><br><span class="line">    at (connect):1:6 at src&#x2F;mongo&#x2F;shell&#x2F;mongo.js:179</span><br><span class="line">exception: connect failed</span><br></pre></td></tr></table></figure>
<p>这个错误是由于mongo shell不能与mongod server通信，可能的原因有: -
mongod server没启动 - ip和端口不正确</p>
<p>查看进程是否启动
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|grep mongo</span><br></pre></td></tr></table></figure>
果然没有启动,尝试启动
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mongod --dbpath &#x2F;var&#x2F;lib&#x2F;mongodb&#x2F; --repair</span><br><span class="line">2021-04-06T10:53:01.376+0800 I CONTROL  [initandlisten] MongoDB starting : pid&#x3D;12221 port&#x3D;27017 dbpath&#x3D;&#x2F;var&#x2F;lib&#x2F;mongodb&#x2F; 64-bit host&#x3D;g37-dev-acfd361f</span><br><span class="line">2021-04-06T10:53:01.376+0800 I CONTROL  [initandlisten] db version v3.0.12</span><br><span class="line">2021-04-06T10:53:01.376+0800 I CONTROL  [initandlisten] git version: 33934938e0e95d534cebbaff656cde916b9c3573</span><br><span class="line">2021-04-06T10:53:01.376+0800 I CONTROL  [initandlisten] build info: Linux build14.ny.cbi.10gen.cc 2.6.32-431.3.1.el6.x86_64 #1 SMP Fri Jan 3 21:39:27 UTC 2014 x86_64 BOOST_LIB_VERSION&#x3D;1_49</span><br><span class="line">2021-04-06T10:53:01.376+0800 I CONTROL  [initandlisten] allocator: tcmalloc</span><br><span class="line">2021-04-06T10:53:01.376+0800 I CONTROL  [initandlisten] options: &#123; repair: true, storage: &#123; dbPath: &quot;&#x2F;var&#x2F;lib&#x2F;mongodb&#x2F;&quot; &#125; &#125;</span><br><span class="line">2021-04-06T10:53:01.400+0800 I STORAGE  [initandlisten] exception in initAndListen: 98 Unable to create&#x2F;open lock file: &#x2F;var&#x2F;lib&#x2F;mongodb&#x2F;mongod.lock errno:13 Permission denied Is a mongod instance already running?, terminating</span><br><span class="line">2021-04-06T10:53:01.401+0800 I CONTROL  [initandlisten] dbexit:  rc: 100</span><br></pre></td></tr></table></figure>
这是因为权限不够，用 <strong>stat</strong> 查看
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># stat &#x2F;var&#x2F;lib&#x2F;mongodb</span><br><span class="line">  File: ‘&#x2F;var&#x2F;lib&#x2F;mongodb’</span><br><span class="line">  Size: 60              Blocks: 0          IO Block: 4096   directory</span><br><span class="line">Device: fd00h&#x2F;64768d    Inode: 1235426     Links: 4</span><br><span class="line">Access: (0755&#x2F;drwxr-xr-x)  Uid: (  505&#x2F; mongodb)   Gid: (  505&#x2F; mongodb)</span><br><span class="line">Access: 2021-04-06 10:49:04.428179272 +0800</span><br><span class="line">Modify: 2021-04-06 10:48:40.036107174 +0800</span><br><span class="line">Change: 2021-04-06 10:48:40.036107174 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
仅mongodb用户可读可写</p>
<h4><span id="solution-1-xiu-gai-lu-jing">solution 1：修改路径</span><a href="#solution-1-xiu-gai-lu-jing" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod --dbpath &#x2F;home&#x2F;liuwen03&#x2F;mongo&#x2F; --repair</span><br><span class="line">mongod --dbpath &#x2F;home&#x2F;liuwen03&#x2F;mongo&#x2F; --journal</span><br></pre></td></tr></table></figure>
<h4><span id="solution-2-xiu-gai-wen-jian-quan-xian">solution 2：修改文件权限</span><a href="#solution-2-xiu-gai-wen-jian-quan-xian" class="header-anchor">#</a></h4>
<p>sudo chmod ... # need to do</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://stackoverflow.com/questions/13312358/mongo-couldnt-connect-to-server-127-0-0-127017">stackoverflow
mongo</a></li>
<li><a href="https://stackoverflow.com/questions/15229412/unable-to-create-open-lock-file-data-mongod-lock-errno13-permission-denied">Unable
to create/open lock file: /data/mongod.lock errno:13 Permission
denied</a></li>
</ol>
]]></content>
      <categories>
        <category>mongo</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[problems solution] hexo部署Spawn failed</title>
    <url>/2022/01/25/problems-solution-hexo%E9%83%A8%E7%BD%B2Spawn-failed/</url>
    <content><![CDATA[<h2><span id="wen-ti-miao-shu">问题描述</span><a href="#wen-ti-miao-shu" class="header-anchor">#</a></h2>
<p>执行hexo g -d部署时, 有如下报错 <a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: Authentication failed for &#39;https:&#x2F;&#x2F;github.com&#x2F;sysuleo&#x2F;sysuleo.github.io.git&#x2F;&#39;</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (E:\sysuleo.github.io_resource\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (E:\sysuleo.github.io_resource\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:275:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br></pre></td></tr></table></figure></p>
<h2><span id="wen-ti-jie-jue">问题解决</span><a href="#wen-ti-jie-jue" class="header-anchor">#</a></h2>
<ol type="1">
<li>删除.deploy_git文件夹;</li>
<li>输入
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure></li>
<li>依次执行：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ol>
<h3><span id="can-kao-lian-jie">参考连接</span><a href="#can-kao-lian-jie" class="header-anchor">#</a></h3>
<ol type="1">
<li><a href="https://github.com/hexojs/hexo/issues/3043">HEXO进行部署时候出现错误，该如何解决</a></li>
<li><a href="https://blog.csdn.net/HTL2018/article/details/106876940">hexo发生error：spawn
failed错误的解决方法</a></li>
</ol>
]]></content>
      <categories>
        <category>problems solution</category>
      </categories>
      <tags>
        <tag>problems solution</tag>
      </tags>
  </entry>
  <entry>
    <title>[mongo] 2. skip、limit and sort</title>
    <url>/2021/05/31/mongo-2-skip%E3%80%81limit-and-set/</url>
    <content><![CDATA[<h2><span id="skip-limit-he-sort-cao-zuo">skip(), limit() 和 sort()操作</span><a href="#skip-limit-he-sort-cao-zuo" class="header-anchor">#</a></h2>
<p>MongoDB使用find()方法查询后，可能需要对于<strong>返回结果进行排序</strong>。在有些查询中，我们<strong>并不需要返回全部结果</strong>，而是按指定的<strong>页长和页码</strong>返回指定数量的结果。本节来学习一下
查询操作中常用的 <strong>skip(), limit() 和 sort()</strong>操作。</p>
<h3><span id="limit">limit()</span><a href="#limit" class="header-anchor">#</a></h3>
<ul>
<li>find()方法查询文档后，其<strong>默认返回前20条数据</strong>。</li>
<li>要限制MongoDB查询结果数，使用limit()方法, 读取指定数量的数据，如返回
<strong>NUMBER条</strong>数据：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure>
<h3><span id="skip">skip()</span><a href="#skip" class="header-anchor">#</a></h3>
<ul>
<li>跳过指定数量的数据, <strong>指定查询偏移量</strong></li>
<li>通过搭配limit() , 可以实现分页查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure>
<h3><span id="sort">sort()</span><a href="#sort" class="header-anchor">#</a></h3>
<ul>
<li>实现查询结果排序</li>
<li>使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1
是用于降序排列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span><br></pre></td></tr></table></figure>
<h2><span id="mongodb-shu-ju-fen-ye">MongoDB 数据分页</span><a href="#mongodb-shu-ju-fen-ye" class="header-anchor">#</a></h2>
<h3><span id="shi-yong-skip-limit-he-sort-zu-he">使用 skip(), limit() 和
sort()组合</span><a href="#shi-yong-skip-limit-he-sort-zu-he" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.myCollection.find().sort(&#123;&quot;_id&quot;:1&#125;).skip(10).limit(10)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sort将数据根据_id排序</p></li>
<li><p>skip指跳过前10条记录，也可以说是从第10条开始</p></li>
<li><p>limit限制查询10条数据</p></li>
<li><p>结果为<strong>按_id升序排序后的第10-19条的数据</strong></p></li>
</ul>
<p>然而, 根据<a href="https://blog.csdn.net/wangliqiang1014/article/details/16861337?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">MongoDB
数据分页和排序 limit,skip,sort用户</a>测试结果而言：
<strong>skip的大小严重影响性能</strong>，应该严格<strong>避免特别大的skip操作</strong>。</p>
<h3><span id="bi-mian-bi-jiao-da-de-skip-cao-zuo">避免比较大的skip操作</span><a href="#bi-mian-bi-jiao-da-de-skip-cao-zuo" class="header-anchor">#</a></h3>
<p>分页查询时，可以记录上一条查询的score值，用如下方法获取数据(按score降序取数据)：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.scores.find(&#123;lid: lid, score: &#123;$lt: last_score&#125;&#125;).sort(&#123;score: -1&#125;).limit(20)</span><br></pre></td></tr></table></figure></p>
<h3><span id="fen-pi-jia-zai-shu-ju">分批加载数据</span><a href="#fen-pi-jia-zai-shu-ju" class="header-anchor">#</a></h3>
<p>下面仅为实现思路, 不是正确的实现
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _load_callback(infos):</span><br><span class="line">    if infos:</span><br><span class="line">        next_id &#x3D; None</span><br><span class="line">        for info in infos:</span><br><span class="line">            uid &#x3D; info.get(&#39;_id&#39;)</span><br><span class="line">            ...</span><br><span class="line">            next_id &#x3D; uid</span><br><span class="line"></span><br><span class="line">        if len(infos) &lt; 1000:</span><br><span class="line">            pass # do finish operation</span><br><span class="line">        else:</span><br><span class="line">            # continue load</span><br><span class="line">            self._load_db(next_id)  # 记录上一条查询的id值</span><br><span class="line">    else:</span><br><span class="line">        pass # do finish operation</span><br><span class="line"></span><br><span class="line">def _load_db(self, begin_id&#x3D;&#39;&#39;):</span><br><span class="line">    &quot;&quot;&quot;分批加载数据,batch_size&#x3D;1000&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    infos &#x3D; db.COLLECTION_NAME.find(&#123;&#39;_id&#39;: &#123;&#39;$gt&#39;: begin_id,&#125;&#125;).sort(&#123;&#39;_id&#39;: 1&#125;).limit(1000)</span><br><span class="line">    self._load_callback(infos)</span><br><span class="line"></span><br><span class="line">self._load_db() </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>mongo</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[problems solution] linux：cannot create temp file for here-document: No space left on device</title>
    <url>/2021/06/09/problems-solution-linux%EF%BC%9Acannot-create-temp-file-for-here-document-No-space-left-on-device/</url>
    <content><![CDATA[<h2><span id="wen-ti-miao-shu">问题描述</span><a href="#wen-ti-miao-shu" class="header-anchor">#</a></h2>
<p>在linux系统下，用<strong>Tab键自动补全</strong>时，报如下错误：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sh dojo-bash: cannot create temp file for here-document: No space left on device</span><br></pre></td></tr></table></figure></p>
<h2><span id="wen-ti-ding-wei">问题定位</span><a href="#wen-ti-ding-wei" class="header-anchor">#</a></h2>
<ol type="1">
<li>df -h查看磁盘空间
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0       7.8G  7.8G   20K 100% &#x2F;</span><br><span class="line">udev             10M     0   10M   0% &#x2F;dev</span><br><span class="line">tmpfs           3.2G  353M  2.8G  11% &#x2F;run</span><br><span class="line">tmpfs           7.9G   56K  7.9G   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vdc1       200G   47G  154G  24% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;vda1       236M   34M  190M  15% &#x2F;boot</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里的/dev/dm-0 空间已满
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;dev&#x2F;dm-0       7.8G  7.8G   20K 100% &#x2F;</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>df -i查看磁盘Inodes消耗 和 剩余量
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem        Inodes  IUsed     IFree IUse% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0         129312 127969      1343   99% &#x2F;</span><br><span class="line">udev             2056585    356   2056229    1% &#x2F;dev</span><br><span class="line">tmpfs            2058885    501   2058384    1% &#x2F;run</span><br><span class="line">tmpfs            2058885     15   2058870    1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs            2058885      4   2058881    1% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs            2058885     13   2058872    1% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vdc1      209713152 371880 209341272    1% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;vda1          62248    328     61920    1% &#x2F;boot</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里的/dev/dm-0 Inodes已用99%
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;dev&#x2F;dm-0         129312 127969      1343   99% &#x2F;</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>分析 /dev/dm-0</li>
</ol>
<p>迅速查找 '/' 路径下 各文件占用大小
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo du -h --max-depth&#x3D;1 &#x2F;</span><br><span class="line"></span><br><span class="line">32M     .&#x2F;boot</span><br><span class="line">4.0M    .&#x2F;etc</span><br><span class="line">0       .&#x2F;media</span><br><span class="line">3.6G    .&#x2F;var</span><br><span class="line">3.7G    .&#x2F;usr</span><br><span class="line">205M    .&#x2F;lib</span><br><span class="line">0       .&#x2F;lib64</span><br><span class="line">8.9M    .&#x2F;bin</span><br><span class="line">7.8M    .&#x2F;sbin</span><br><span class="line">du: cannot access ‘.&#x2F;proc&#x2F;12844&#x2F;task&#x2F;12844&#x2F;fd&#x2F;4’: No such file or directory</span><br><span class="line">du: cannot access ‘.&#x2F;proc&#x2F;12844&#x2F;task&#x2F;12844&#x2F;fdinfo&#x2F;4’: No such file or directory</span><br><span class="line">du: cannot access ‘.&#x2F;proc&#x2F;12844&#x2F;fd&#x2F;4’: No such file or directory</span><br><span class="line">du: cannot access ‘.&#x2F;proc&#x2F;12844&#x2F;fdinfo&#x2F;4’: No such file or directory</span><br><span class="line">0       .&#x2F;proc</span><br><span class="line">27M     .&#x2F;tmp</span><br><span class="line">0       .&#x2F;dev</span><br><span class="line">47G     .&#x2F;home</span><br><span class="line">341M    .&#x2F;root</span><br><span class="line">0       .&#x2F;sys</span><br><span class="line">337M    .&#x2F;run</span><br><span class="line">0       .&#x2F;mnt</span><br><span class="line">0       .&#x2F;srv</span><br><span class="line">0       .&#x2F;opt</span><br><span class="line">55G     .</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li><p>定位/var 和 /usr 查看/var路径
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -lh --max-depth&#x3D;1 &#x2F;var</span><br><span class="line">349M    &#x2F;var&#x2F;lib</span><br><span class="line">65M     &#x2F;var&#x2F;cache</span><br><span class="line">3.2G    &#x2F;var&#x2F;log</span><br><span class="line">0       &#x2F;var&#x2F;tmp</span><br><span class="line">64K     &#x2F;var&#x2F;spool</span><br><span class="line">6.7M    &#x2F;var&#x2F;backups</span><br><span class="line">0       &#x2F;var&#x2F;local</span><br><span class="line">0       &#x2F;var&#x2F;opt</span><br><span class="line">144K    &#x2F;var&#x2F;mail</span><br><span class="line">192K    &#x2F;var&#x2F;initsh</span><br><span class="line">3.6G    &#x2F;var</span><br></pre></td></tr></table></figure>
这里/var/log有3.2G，可以删除一波</p></li>
<li><p>重新查看df -h 和 df -i
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0       7.8G  7.4G  368M  96% &#x2F;</span><br><span class="line">udev             10M     0   10M   0% &#x2F;dev</span><br><span class="line">tmpfs           3.2G  345M  2.9G  11% &#x2F;run</span><br><span class="line">tmpfs           7.9G   56K  7.9G   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vdc1       200G   47G  154G  24% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;vda1       236M   34M  190M  15% &#x2F;boot</span><br><span class="line"></span><br><span class="line">$df -i</span><br><span class="line">Filesystem        Inodes  IUsed     IFree IUse% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0        1619760 127756   1492004    8% &#x2F;</span><br><span class="line">udev             2056585    356   2056229    1% &#x2F;dev</span><br><span class="line">tmpfs            2058885    501   2058384    1% &#x2F;run</span><br><span class="line">tmpfs            2058885     15   2058870    1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs            2058885      4   2058881    1% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs            2058885     13   2058872    1% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vdc1      209713152 371880 209341272    1% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;vda1          62248    328     61920    1% &#x2F;boot</span><br></pre></td></tr></table></figure>
<strong>磁盘占用还是很大</strong>，但是<strong>inodes数量降下来</strong>了。</p></li>
</ol>
<p>最后，kill掉启动的python进程后，随着时间推移，/dev/dm-0
几分钟内降到了53%。</p>
<p>个人猜测是由于这些
<strong>python进程一直在写/var/lo</strong>g，虽然在系统上清空了/var/log下的文件，但是
<strong>这些进程还在占用这些log文件，linux未能及时回收</strong>。</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://superuser.com/questions/131519/what-is-this-dm-0-device/594011">What
is this dm-0 device?</a></li>
<li><a href="https://www.reddit.com/r/linuxadmin/comments/80bi15/what_is_devdm0_that_is_100_used/">what
is /dev/dm-0 that is 100% used?</a></li>
</ol>
]]></content>
      <categories>
        <category>problems solution</category>
      </categories>
      <tags>
        <tag>problems solution</tag>
      </tags>
  </entry>
  <entry>
    <title>[problems solution] windows cmd cd无效问题</title>
    <url>/2021/04/22/problems-solution-windows-cmd-cd%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2><span id="wen-ti-miao-shu">问题描述</span><a href="#wen-ti-miao-shu" class="header-anchor">#</a></h2>
<p>在windows下， 打开cmd.exe, 默认进入到当前用户主目录下， 发现除了C:，
可以通过 <strong>cd、dir</strong> 指令 去到C:， <strong>不能通过 cd e:
进入到其他盘</strong></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\liuwen03&gt;cd ..</span><br><span class="line"></span><br><span class="line">C:\Users&gt;cd e:</span><br><span class="line">E:\</span><br><span class="line"></span><br><span class="line">C:\Users&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="solution">solution</span><a href="#solution" class="header-anchor">#</a></h2>
<ol type="1">
<li>在 cd 和盘符<strong>之间</strong>加上 <strong>/d</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\liuwen03&gt;cd &#x2F;d e:</span><br><span class="line"></span><br><span class="line">E:\&gt;</span><br></pre></td></tr></table></figure></li>
<li>直接用 盘符 e:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users&gt;e:</span><br><span class="line"></span><br><span class="line">E:\&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>problems solution</category>
      </categories>
      <tags>
        <tag>problems solution</tag>
      </tags>
  </entry>
  <entry>
    <title>[problems solution] linux:删除大文件，磁盘没有释放空间</title>
    <url>/2021/07/26/problems-solution-linux-%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6%EF%BC%8C%E7%A3%81%E7%9B%98%E6%B2%A1%E6%9C%89%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2><span id="wen-ti-miao-shu">问题描述</span><a href="#wen-ti-miao-shu" class="header-anchor">#</a></h2>
<p>用tab自动补全报错 No space left on device
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd my-bash: cannot create temp file for here-document: No space left on device</span><br></pre></td></tr></table></figure>
<a id="more"></a> 查看磁盘空间，发现/dev/dm-0占用100%
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0       7.8G  7.8G   20K 100% &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
用du -h --max-depth / 分析出/var/log文件占用了很大的空间</p>
<p>暴力地用 rm -r /var/log/
删除,再次查看usr文件,发现var空间下已无log文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rm -r &#x2F;var&#x2F;log&#x2F;</span><br><span class="line"></span><br><span class="line"># du -h --max-depth&#x3D;1 &#x2F;var</span><br><span class="line">337M    &#x2F;var&#x2F;lib</span><br><span class="line">90M     &#x2F;var&#x2F;cache</span><br><span class="line">0       &#x2F;var&#x2F;tmp</span><br><span class="line">48M     &#x2F;var&#x2F;spool</span><br><span class="line">6.3M    &#x2F;var&#x2F;backups</span><br><span class="line">0       &#x2F;var&#x2F;local</span><br><span class="line">0       &#x2F;var&#x2F;opt</span><br><span class="line">144K    &#x2F;var&#x2F;mail</span><br><span class="line">192K    &#x2F;var&#x2F;initsh</span><br><span class="line">481M    &#x2F;var</span><br></pre></td></tr></table></figure>
查看磁盘空间还是却未变
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0       7.8G  7.8G   20K 100% &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
## 问题排查与解决
突然想到可能是var/log文件还被占用着，磁盘空间没有成功释放。使用lsof查看
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># lsof  -u root|grep var&#x2F;log</span><br><span class="line">rsyslogd  16083 root    5w      REG              253,0    4149248   27063243 &#x2F;var&#x2F;log&#x2F;auth.log (deleted)</span><br><span class="line">rsyslogd  16083 root    6w      REG              253,0 1463746560   27104493 &#x2F;var&#x2F;log&#x2F;syslog (deleted)</span><br><span class="line">rsyslogd  16083 root    7w      REG              253,0 1826508800   27063246 &#x2F;var&#x2F;log&#x2F;messages (deleted)</span><br><span class="line">rsyslogd  16083 root    8w      REG              253,0    3448832   27063245 &#x2F;var&#x2F;log&#x2F;cron.log (deleted)</span><br><span class="line">rsyslogd  16083 root   10w      REG              253,0    2568192   27063241 &#x2F;var&#x2F;log&#x2F;mail.log (deleted)</span><br><span class="line">rsyslogd  16083 root   11w      REG              253,0    2568192   27104495 &#x2F;var&#x2F;log&#x2F;mail.info (deleted)</span><br><span class="line">rsyslogd  16083 root   12w      REG              253,0    2568192   27063239 &#x2F;var&#x2F;log&#x2F;mail.warn (deleted)</span><br><span class="line">rsyslogd  16083 root   13w      REG              253,0    2564096   27063240 &#x2F;var&#x2F;log&#x2F;mail.err (deleted)</span><br><span class="line">rsyslogd  16083 root   14w      REG              253,0    3464038   27063242 &#x2F;var&#x2F;log&#x2F;daemon.log (deleted)</span><br><span class="line">rsyslogd  16083 root   15w      REG              253,0      20480   27063244 &#x2F;var&#x2F;log&#x2F;user.log (deleted)</span><br><span class="line">rsyslogd  16083 root   16w      REG              253,0        528   27104496 &#x2F;var&#x2F;log&#x2F;kern.log (deleted)</span><br><span class="line">rsyslogd  16083 root   17w      REG              253,0        528   27063254 &#x2F;var&#x2F;log&#x2F;debug (deleted)</span><br></pre></td></tr></table></figure>
果然被rsyslogd程序占用中，重启一波rsyslogd，发现成功释放了磁盘空间
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;rsyslog restart</span><br><span class="line"></span><br><span class="line"># df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0       7.8G  4.7G  3.1G  61% &#x2F;</span><br></pre></td></tr></table></figure></p>
<h2><span id="wen-ti-si-kao">问题思考</span><a href="#wen-ti-si-kao" class="header-anchor">#</a></h2>
<p>暴力使用rm -r 清除正在被占用的文件例如 var/log，并不会释放磁盘空间。
可以在删除之前 <strong>先清空</strong>文件，<strong>再删除</strong>文件
这样能<strong>快速释放磁盘空间</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo “” &gt; xxx.log</span><br><span class="line">rm -rf xxx.log</span><br></pre></td></tr></table></figure></p>
<h2><span id="ru-he-ding-qi-qing-li">如何定期清理</span><a href="#ru-he-ding-qi-qing-li" class="header-anchor">#</a></h2>
<p>crontab指令可以定期执行命令, 对于定期清理日志,
当然也要用crontab。具体定期清理方式请阅读 <a href="http://liuw.tech/2021/03/31/linux-9-crontab%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/">crontab定期执行命令</a>指令,</p>
]]></content>
      <categories>
        <category>problems solution</category>
      </categories>
      <tags>
        <tag>problems solution</tag>
      </tags>
  </entry>
  <entry>
    <title>[problems solution] windows 环境变量失效问题</title>
    <url>/2021/10/22/problems-solution-windows-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2><span id="1-wen-ti-miao-shu">1. 问题描述</span><a href="#1-wen-ti-miao-shu" class="header-anchor">#</a></h2>
<p>原本用得好好的python命令, 在cmd中突然就用不了了。 在
<strong>系统属性-高级系统设置-环境变量-用户变量-Path</strong>中，查看是否设置了python.exe的路径,
奇怪的是存在该路径. 为什么找不到会python了呢？ <a id="more"></a></p>
<h2><span id="2-wen-ti-jie-jue">2.问题解决</span><a href="#2-wen-ti-jie-jue" class="header-anchor">#</a></h2>
<p>经过一番查证, 发现与知乎问题: <a href="https://www.zhihu.com/question/31459186">Win10
设置了环境变量，但是没有用啊，怎么回事？</a>完美契合，原来大家也遇到了这个问题。</p>
<p>知乎提到了许多种解决方法, 大部分都没能解决我的问题。最后我将
<strong>python路径提到Path最前面</strong>, 然后参考<a href="https://segmentfault.com/a/1190000039754002">Windows 10
修改环境变量不重启生效的解决方案</a>, 步骤如下: 1. <strong>win +
R</strong> 进入 cmd 2. 键入 <strong>set PATH=C</strong>: 关闭窗口 3.
同样方式打开 cmd, 键入 <strong>echo
%PATH%</strong>，会打印出新配置的环境变量</p>
<p>验证是否可以调用python, 普天同庆, 发现问题已解决！</p>
<p>至于为什么会好端端地就出现异常, 为什么提到最前面就能恢复正常,
还无从考证~</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://www.zhihu.com/question/31459186">Win10
设置了环境变量，但是没有用啊，怎么回事？</a></li>
<li><a href="https://segmentfault.com/a/1190000039754002">Windows 10
修改环境变量不重启生效的解决方案</a></li>
</ol>
]]></content>
      <categories>
        <category>problems solution</category>
      </categories>
      <tags>
        <tag>problems solution</tag>
      </tags>
  </entry>
  <entry>
    <title>[problems solution] windows下 FATAL Port *** has been used排查</title>
    <url>/2020/12/17/problems-solution-windows%E4%B8%8B%E7%89%B9%E5%AE%9A%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h3><span id="fen-xi-bao-cuo">分析报错</span><a href="#fen-xi-bao-cuo" class="header-anchor">#</a></h3>
<p>最近写博客时，遇到用hexo s指令失败报错的问题
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FATAL Port 4000 has been used. Try other port instead.</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: listen EADDRINUSE: address already in use :::4000</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析该报错，发现端口4000已经被占用</p>
<h2><span id="cha-zhao-jin-cheng">查找进程</span><a href="#cha-zhao-jin-cheng" class="header-anchor">#</a></h2>
<p>查找端口号 4000的网络占用
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$netstat -ano|grep 4000</span><br></pre></td></tr></table></figure>
- -a 显示所有连接和侦听端口。 - -n 以数字形式显示地址和端口号。 - -o
显示拥有的与每个连接关联的进程 ID
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协议      本地地址                外部地址                状态           PID(这一行输入netstat -ano 在头部会显示)</span><br><span class="line">TCP    0.0.0.0:4000           0.0.0.0:0              LISTENING       21144</span><br><span class="line">TCP    0.0.0.0:14000          0.0.0.0:0              LISTENING       21144</span><br><span class="line">TCP    127.0.0.1:55016        127.0.0.1:55017        ESTABLISHED     24000</span><br><span class="line">TCP    127.0.0.1:55017        127.0.0.1:55016        ESTABLISHED     24000</span><br><span class="line">TCP    [::]:4000              [::]:0                 LISTENING       21144</span><br><span class="line">TCP    [::]:14000             [::]:0                 LISTENING       21144</span><br><span class="line">TCP    [::1]:4000             [::1]:55146            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55147            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55152            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55166            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55167            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55174            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55177            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55178            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55183            TIME_WAIT       0</span><br><span class="line">TCP    [::1]:4000             [::1]:55186            TIME_WAIT       0</span><br></pre></td></tr></table></figure>
可以看到端口号 4000被 PID 21144占用</p>
<h2><span id="cha-zhao-ying-yong">查找应用</span><a href="#cha-zhao-ying-yong" class="header-anchor">#</a></h2>
<p>查找进程号包含 21144的所有进程
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tasklist|findstr &quot;21144&quot;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">映像名称                       PID  会话名                     会话  内存使用(这一行输入tasklist在头部会显示)</span><br><span class="line">Code.exe                     21144 Console                    1    200,664 K</span><br></pre></td></tr></table></figure>
<p>好家伙，就是这个Code.exe占用了</p>
<h2><span id="kill-diao-ying-yong">kill掉应用</span><a href="#kill-diao-ying-yong" class="header-anchor">#</a></h2>
<p>通过查看占用端口号的进程，可以直接杀掉进程（这一步谨慎操作，别杀了不能杀的进程，那就Good
Game了）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taskkill &#x2F;pid 21144 -f -t</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">taskkill &#x2F;pid 21144 &#x2F;f  &#x2F;t</span><br></pre></td></tr></table></figure>
- /pid processid 指定要终止的进程的 PID。 - /f 指定强制终止进程。 - /t
终止指定的进程和由它启用的子进程</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://blog.csdn.net/mymhj/article/details/90171785" title="在windows下查看端口被占用情况">在windows下查看端口被占用情况</a></li>
</ol>
]]></content>
      <categories>
        <category>problems solution</category>
      </categories>
      <tags>
        <tag>problems solution</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 1.对象</title>
    <url>/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>面向对象理论中 <strong>“ 类 ”和“ 对象 ”</strong> 这两个重要概念，在
Python 内部均 <strong>以对象的形式存在</strong>。
<strong>“类”是一种对象</strong>，称为 <strong>类型对象</strong>
；“类”实例化生成的“对象”也是对象，称为 <strong>实例对象</strong> 。</p>
<p>根据对象不同特点还可进一步分类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>可变对象</td>
<td>对象创建后可以修改</td>
</tr>
<tr>
<td>不可变对象</td>
<td>对象创建后不能修改</td>
</tr>
<tr>
<td>定长对象</td>
<td>对象大小固定</td>
</tr>
<tr>
<td>变长对象</td>
<td>对象大小不固定</td>
</tr>
</tbody>
</table>
<p>那么，对象在 Python 内部到底长啥样呢？ 由于 Python 是由 C
语言实现的，因此 Python 对象在 C 语言层面应该是一个
<strong>结构体</strong> ，组织对象占用的内存。
不同类型的对象，数据及行为均可能不同，因此可以大胆猜测：<strong>不同类型的对象由不同的结构体表示</strong>。
对象也有一些共性，比如每个对象都需要有一个 <strong>引用计数 ，用于实现
垃圾回收机制</strong> 。 因此，还可以进一步猜测：表示对象的结构体有一个
<strong>公共头部</strong> 。</p>
<h2><span id="pyobject-dui-xiang-de-ji-shi">PyObject，对象的基石</span><a href="#pyobject-dui-xiang-de-ji-shi" class="header-anchor">#</a></h2>
<p>在 Python 内部，对象都由 <strong>PyObject 结构体</strong>表示，
对象引用则是指针 PyObject * 。 PyObject 结构体定义于头文件 object.h
，路径为 Include/object.h ，代码如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _object &#123;</span><br><span class="line">    _PyObject_HEAD_EXTRA   &#x2F;&#x2F;公共头部</span><br><span class="line">    Py_ssize_t ob_refcnt;  &#x2F;&#x2F;引用计数</span><br><span class="line">    struct _typeobject *ob_type;  &#x2F;&#x2F;类型指针</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
除了 _PyObject_HEAD_EXTRA 宏，结构体包含以下两个字段： - 引用计数 (
ob_refcnt ) - 类型指针 ( ob_type )</p>
<p><strong>引用计数</strong>
很好理解：对象被其他地方引用时加一，引用解除时减一；
当引用计数为零，便可将对象回收，这是最简单的垃圾回收机制。 类型指针
指向对象的 类型对象 ，类型对象 描述 实例对象 的数据及行为。</p>
<p>回过头来看 _PyObject_HEAD_EXTRA 宏的定义，同样在 Include/object.h
头文件内：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef Py_TRACE_REFS</span><br><span class="line">&#x2F;* Define pointers to support a doubly-linked list of all live heap objects. *&#x2F;</span><br><span class="line">#define _PyObject_HEAD_EXTRA            \</span><br><span class="line">    struct _object *_ob_next;           \</span><br><span class="line">    struct _object *_ob_prev;</span><br><span class="line"></span><br><span class="line">#define _PyObject_EXTRA_INIT 0, 0,</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">#define _PyObject_HEAD_EXTRA</span><br><span class="line">#define _PyObject_EXTRA_INIT</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>如果 <strong>Py_TRACE_REFS 有定义，宏展开为两个指针，看名字是用来实现
双向链表</strong> 的：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _object *_ob_next;</span><br><span class="line">struct _object *_ob_prev;</span><br></pre></td></tr></table></figure>
结合注释，双向链表用于 <strong>跟踪所有 活跃堆对象</strong>
，一般不启用，不深入介绍。 对于 变长对象 ，需要在 PyObject
基础上加入长度信息，这就是 <strong>PyVarObject</strong> ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; &#x2F;* Number of items in variable part *&#x2F;</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>
<strong>变长对象比普通对象多一个字段 ob_size
，用于记录元素个数</strong>：</p>
<table style="width:29%;">
<colgroup>
<col style="width: 29%">
</colgroup>
<tbody>
<tr>
<td>于具体对象，视其大小是否固定，需要包含头部 PyObject 或 PyVarObject
。 为此，头文件准备了两个宏定义，方便其他对象使用：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PyObject_HEAD          PyObject ob_base;</span><br><span class="line">#define PyObject_VAR_HEAD      PyVarObject ob_base;</span><br></pre></td></tr></table></figure>
例如，对于大小固定的 浮点对象 ，只需在 PyObject 头部基础上， 用一个
双精度浮点数 double 加以实现：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD  &#x2F;&#x2F;浮点数是定长对象</span><br><span class="line"></span><br><span class="line">    double ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure></td>
</tr>
</tbody>
</table>
<div style="width:100%;margin:auto">
<img src="/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%AF%B9%E8%B1%A1/%5Bpython%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5D1.%E5%AF%B9%E8%B1%A12.png" class title="PyVarFloat图">
</div>
<table style="width:24%;">
<colgroup>
<col style="width: 23%">
</colgroup>
<thead>
<tr>
<th>而对于大小不固定的 列表对象 ，则需要在 PyVarObject 头部基础上，
用一个动态数组加以实现，数组存储列表包含的对象，即 PyObject 指针：</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如图， PyListObject 底层
<strong>由一个数组实现</strong>，关键字段是以下 3 个： ob_item ，指向
<strong>动态数组 的指针</strong>，数组保存元素对象指针； allocated
，<strong>动态数组总长度</strong>，即列表当前的 容量 ； ob_size
，<strong>当前元素个数</strong>，即列表当前的 长度 ；
列表容量不足时，<strong>Python 会自动扩容</strong>，具体做法在讲解 list
源码时再详细介绍。 最后，介绍两个用于初始化对象头部的宏定义。
其中，PyObject_HEAD_INIT 一般用于 定长对象 ，将<strong>引用计数
ob_refcnt 设置为 1 并将对象类型 ob_type 设置成给定类型</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PyObject_HEAD_INIT(type)        \</span><br><span class="line">    &#123; _PyObject_EXTRA_INIT              \</span><br><span class="line">    1, type &#125;,</span><br></pre></td></tr></table></figure>
PyVarObject_HEAD_INIT 在 PyObject_HEAD_INIT 基础上进一步设置 长度字段
ob_size ，一般用于 变长对象 ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PyVarObject_HEAD_INIT(type, size)       \</span><br><span class="line">    &#123; PyObject_HEAD_INIT(type) size &#125;,</span><br></pre></td></tr></table></figure>
后续在研读源码过程中，将经常见到这两个宏定义。</p>
<h1><span id="pytypeobject-lei-xing-de-ji-shi">PyTypeObject，类型的基石</span><a href="#pytypeobject-lei-xing-de-ji-shi" class="header-anchor">#</a></h1>
<p>在 PyObject 结构体，我们看到了 Python 中所有对象共有的信息。
对于内存中的任一个对象，不管是何类型，它刚开始几个字段肯定符合我们的预期：
<strong>引用计数 、 类型指针 以及变长对象特有的 元素个数</strong> 。
随着研究不断深入，我们发现有一些棘手的问题没法回答：
不同类型的对象所需内存空间不同，创建对象时从哪得知内存信息呢？
对于给定对象，怎么判断它支持什么操作呢？ 对于我们初步解读过的
PyFloatObject 和 PyListObject ，并不包括这些信息。
事实上，这些作为对象的 <strong>元信息</strong>
，应该由一个独立实体保存，与对象所属 类型 密切相关。 注意到， PyObject
中包含一个指针 ob_type ，指向一个 类型对象 ，秘密就藏在这里。类型对象
<strong>PyTypeObject</strong> 也在 Include/object.h
中定义，字段较多，只讨论关键部分：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    const char *tp_name; &#x2F;* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; *&#x2F;</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; &#x2F;* For allocation *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Methods to implement standard operations *&#x2F;</span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line"></span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;* Attribute descriptor and subclassing stuff *&#x2F;</span><br><span class="line">    struct _typeobject *tp_base;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ......</span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>
可见 类型对象 PyTypeObject 是一个 <strong>变长对象</strong>
，包含变长对象头部。 专有字段有： - 类型名称 ，即 tp_name 字段； -
类型的继承信息，例如 tp_base 字段指向基类对象； - 创建实例对象时所需的
内存信息 ，即 tp_basicsize 和 tp_itemsize 字段； - 该类型支持的相关
操作信息 ，即 tp_print 、 tp_getattr 等函数指针；</p>
<p>PyTypeObject 就是 <strong>类型对象 在 Python
中的表现形式</strong>，对应着<strong>面向对象中“类”的概念</strong>。
PyTypeObject 结构很复杂，但是我们不必在此刻完全弄懂它。
先有个大概的印象，知道 PyTypeObject 保存着对象的 元信息 ，描述对象的
类型 即可。 接下来，以 浮点 为例，考察 类型对象 和 实例对象
在内存中的形态和关系：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; float</span><br><span class="line">&lt;class &#39;float&#39;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; pi &#x3D; 3.14</span><br><span class="line">&gt;&gt;&gt; e &#x3D; 2.71</span><br><span class="line">&gt;&gt;&gt; type(pi) is float</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
float 为
<strong>浮点类型对象，系统中只有唯一一个，保存了所有浮点实例对象的元信息</strong>。
而浮点实例对象就有很多了，圆周率 pi 是一个，自然对数 e
是另一个，当然还有其他。 代码中各个对象在内存的形式如下图所示：</p>
<p>其中，两个浮点 实例对象 都是 <strong>PyFloatObject 结构体</strong>，
除了公共头部字段 ob_refcnt 和 ob_type ，专有字段
<strong>ob_fval</strong> 保存了对应的数值。 浮点 类型对象 是一个
PyTypeObject 结构体， 保存了类型名、内存分配信息以及浮点相关操作。
实例对象 ob_type 字段指向类型对象， Python 据此判断对象类型，
进而获悉关于对象的元信息，如操作方法等。 再次提一遍，float 、 pi 以及 e
等变量只是一个指向实际对象的指针。 由于浮点 <strong>类型对象
全局唯一</strong>，在 C 语言层面
<strong>作为一个全局变量静态定义</strong>即可，Python 的确就这么做。
浮点类型对象就藏身于 Object/floatobject.c 中， PyFloat_Type 是也：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyFloat_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;float&quot;,</span><br><span class="line">    sizeof(PyFloatObject),</span><br><span class="line">    0,</span><br><span class="line">    (destructor)float_dealloc,                  &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    (reprfunc)float_repr,                       &#x2F;* tp_repr *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
其中，第 2 行初始化 ob_refcnt 、 ob_type 以及 ob_size 三个字段； 第 3
行将 tp_name 字段初始化成类型名称 float ；再往下是各种操作的函数指针。
注意到 ob_type 指针指向 PyType_Type ，这也是一个静态定义的全局变量。
由此可见，代表“ 类型的类型 ” 即 type 的那个对象应该就是 PyType_Type
了。</p>
<h1><span id="pytype-type-lei-xing-de-lei-xing">PyType_Type，类型的类型</span><a href="#pytype-type-lei-xing-de-lei-xing" class="header-anchor">#</a></h1>
<p>我们初步考察了 float 类型对象，知道它在 C 语言层面是 PyFloat_Type
全局静态变量。 类型是一种对象，它也有自己的类型，也就是 Python 中的 type
：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; float.__class__</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br></pre></td></tr></table></figure>
自定义类型也是如此：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Foo(object):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Foo.__class__</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br></pre></td></tr></table></figure>
那么， type 在 C 语言层面又长啥样呢？ 围观 PyFloat_Type 时，我们通过
ob_type 字段揪住了 <strong>PyType_Type</strong> 。 的确，它就是 type
的肉身。 PyType_Type 在 Object/typeobject.c 中定义（也是
<strong>重写PyTypeObject结构体</strong>）：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyType_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;type&quot;,                                     &#x2F;* tp_name *&#x2F;</span><br><span class="line">    sizeof(PyHeapTypeObject),                   &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    sizeof(PyMemberDef),                        &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    (destructor)type_dealloc,                   &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    (reprfunc)type_repr,                        &#x2F;* tp_repr *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
内建类型和自定义类对应的 <strong>PyTypeObject</strong> 对象都是这个通过
PyType_Type 创建的。 PyType_Type 在 Python
的类型机制中是一个至关重要的对象，它是所有类型的类型，称为
<strong>元类型 ( meta class )。
借助元类型</strong>，你可以实现很多神奇的高级操作。 注意到，
<strong>PyType_Type 将自己的 ob_type 字段设置成它自己</strong>(第 2
行)，这跟我们在 Python 中看到的行为是吻合的：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type.__class__</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type.__class__ is type</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
至此，元类型 type 在对象体系里的位置非常清晰了：</p>
<table style="width:8%;">
<colgroup>
<col style="width: 8%">
</colgroup>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h1><span id="pybaseobject-type-lei-xing-zhi-ji">PyBaseObject_Type，类型之基</span><a href="#pybaseobject-type-lei-xing-zhi-ji" class="header-anchor">#</a></h1>
<p>object 是另一个特殊的类型，它是 <strong>所有类型的基类</strong>。
那么，怎么找到它背后的实体呢？ 理论上，通过 PyFloat_Type 中 tp_base
字段顺藤摸瓜即可。 然而，我们发现这个字段在并没有初始化：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0,                                          &#x2F;* tp_base *&#x2F;</span><br></pre></td></tr></table></figure>
这又是什么鬼？ 接着查找代码中 PyFloat_Type 出现的地方，我们在
Object/object.c 发现了蛛丝马迹：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (PyType_Ready(&amp;PyFloat_Type) &lt; 0)</span><br><span class="line">    Py_FatalError(&quot;Can&#39;t initialize float type&quot;);</span><br></pre></td></tr></table></figure>
敢情 PyFloat_Type 静态定义后还是个半成品呀！ PyType_Ready
对它做进一步加工，将 PyFloat_Type 中 tp_base 字段初始化成
PyBaseObject_Type ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int</span><br><span class="line">PyType_Ready(PyTypeObject *type)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    base &#x3D; type-&gt;tp_base;</span><br><span class="line">    if (base &#x3D;&#x3D; NULL &amp;&amp; type !&#x3D; &amp;PyBaseObject_Type) &#123;</span><br><span class="line">        base &#x3D; type-&gt;tp_base &#x3D; &amp;PyBaseObject_Type;</span><br><span class="line">        Py_INCREF(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
PyBaseObject_Type 就是 PyTypeObject 背后的实体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyBaseObject_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;object&quot;,                                   &#x2F;* tp_name *&#x2F;</span><br><span class="line">    sizeof(PyObject),                           &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    object_dealloc,                             &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    object_repr,                                &#x2F;* tp_repr *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到， ob_type 字段指向 PyType_Type 跟 object 在 Python
中的行为时相吻合的：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; object.__class__</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br></pre></td></tr></table></figure>
又注意到 PyType_Ready 函数初始化 PyBaseObject_Type 时，不设置 tp_base
字段。
因为继承链必须有一个终点，不然对象沿着继承链进行属性查找时便陷入死循环。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(object.__base__)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
至此，我们完全弄清了 Python
对象体系中的所有实体以及关系，得到一幅完整的图画：</p>
<table style="width:8%;">
<colgroup>
<col style="width: 8%">
</colgroup>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>创建一个对象时, 先创建一个
<strong>类型对象PyTypeObject</strong>(类型对象自始至终都是
<strong>只要一个的, 在C源码中, 就是定义了一个全局的变量</strong>),
保存要创建对象的类型信息, 接着再在
<strong>该类型对象的方法中创建指定的对象</strong>, 并将类型对象
PyTypeObject 置为该对象的属性之一, 如创建一个int对象,
先在PyInt_Type对象创建封装了信息之后再创建PyIntObject对象。</p></li>
<li><p>Python相比较于其他语言的好处是
<strong>其doc文档就在程序之中</strong>,
通过<strong>PyTypeObject结构体中的doc属性</strong>可以看到。</p></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python]弱引用weakref介绍</title>
    <url>/2020/11/16/python-%E5%BC%B1%E5%BC%95%E7%94%A8weakref%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>虽然一般情况下python无需像cpp一样需要手动
内存申请和释放，但是某些情况，我们需要自己去管理对象的销毁，让它的生命周期符合我们的预期。weakref就是一种方式。</p>
<h2><span id="1-gai-nian">1. 概念</span><a href="#1-gai-nian" class="header-anchor">#</a></h2>
<p>首先需要了解的是在 Python 里每个对象都有一个
<strong>引用计数</strong>，当这个引用计数为 0 时，Python 的garbage
collection(GC)是可以 <strong>安全销毁这个对象</strong>的，
比如对一个对象创建引用则计数加 1,删除引用则计数减 1 。</p>
<p>weakref 模块允许
<strong>对一个对象创建弱引用</strong>，弱引用不像正常引用,
<strong>弱引用不会增加引用计数</strong>，也就是说
<strong>当一个对象上只有弱引用时，GC是可以销毁该对象的</strong>。</p>
<h2><span id="2-weakref-ref">2 weakref.ref</span><a href="#2-weakref-ref" class="header-anchor">#</a></h2>
<h3><span id="2-1-weakref-ref-yong-fa">2.1 weakref.ref用法</span><a href="#2-1-weakref-ref-yong-fa" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import weakref</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; class DBO(object):</span><br><span class="line">...     pass</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dbo1 &#x3D; DBO()                    # 创建对象，引用+1</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)           # 调用sys.getrefcount，该函数引用了dbo1，对象引用+1</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; weakref_dbo &#x3D; weakref.ref(dbo1) # 创建弱引用</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)           # 弱引用没有增加引用计数</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; weakref_dbo                     # 弱引用指向的对象</span><br><span class="line">&lt;weakref at 0x7f9b0316d3c0; to &#39;DBO&#39; at 0x7f9b03166ed0&gt;</span><br><span class="line">&gt;&gt;&gt; dbo2 &#x3D; weakref_dbo()            # 获取弱引用指向的对象</span><br><span class="line">&gt;&gt;&gt; dbo1 is dbo2                    # dbo1和dbo2引用的是同一个对象</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)           # 对象上的引用计数加 1</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo2)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; dbo1 &#x3D; None                     # 删除引用</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)           # 这个数字是None对象的引用次数</span><br><span class="line">2545</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; weakref_dbo</span><br><span class="line">&lt;weakref at 0x7f9b0316d3c0; to &#39;DBO&#39; at 0x7f9b03166ed0&gt;</span><br><span class="line">&gt;&gt;&gt; dbo2 &#x3D; None                     # 删除引用</span><br><span class="line">&gt;&gt;&gt; weakref_dbo                     # 当对象引用计数为0时，弱引用失效</span><br><span class="line">&lt;weakref at 0x7f9b0316d3c0; dead&gt;</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(dbo1)</span><br><span class="line">2546</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<h3><span id="2-1-weakref-ref-yuan-ma">2.1 weakref.ref源码</span><a href="#2-1-weakref-ref-yuan-ma" class="header-anchor">#</a></h3>
<p>接下来我们看看它的源码套餐，定义在objects/weakrefObjects.c中
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyWeakref_NewRef(PyObject *ob, PyObject *callback)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*PyWeakReference是一个弱引用对象，result做临时存储*&#x2F;</span><br><span class="line">    PyWeakReference *result &#x3D; NULL;</span><br><span class="line">    PyWeakReference **list;</span><br><span class="line">    PyWeakReference *ref, *proxy;</span><br><span class="line">    &#x2F;*检查当前对象类型是否支持弱引用*&#x2F;</span><br><span class="line">    if (!PyType_SUPPORTS_WEAKREFS(Py_TYPE(ob))) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     &quot;cannot create weak reference to &#39;%s&#39; object&quot;,</span><br><span class="line">                     Py_TYPE(ob)-&gt;tp_name);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*获取弱引用链表指针*&#x2F;</span><br><span class="line">    list &#x3D; GET_WEAKREFS_LISTPTR(ob);</span><br><span class="line">    &#x2F;*根据*list，给 ref 和 proxy 赋值*&#x2F;</span><br><span class="line">    get_basic_refs(*list, &amp;ref, &amp;proxy);</span><br><span class="line">    if (callback &#x3D;&#x3D; Py_None)</span><br><span class="line">        callback &#x3D; NULL;</span><br><span class="line">    if (callback &#x3D;&#x3D; NULL)</span><br><span class="line">        &#x2F;* return existing weak reference if it exists *&#x2F;</span><br><span class="line">        result &#x3D; ref;</span><br><span class="line">    if (result !&#x3D; NULL)</span><br><span class="line">        &#x2F;*给当前weak reference引用加1*&#x2F;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;* Note: new_weakref() can trigger cyclic GC, so the weakref</span><br><span class="line">           list on ob can be mutated.  This means that the ref and</span><br><span class="line">           proxy pointers we got back earlier may have been collected,</span><br><span class="line">           so we need to compute these values again before we use</span><br><span class="line">           them.</span><br><span class="line">            使用之前，先确认ob对象没有被析构</span><br><span class="line">            *&#x2F;</span><br><span class="line">        result &#x3D; new_weakref(ob, callback);</span><br><span class="line">        if (result !&#x3D; NULL) &#123;</span><br><span class="line">            get_basic_refs(*list, &amp;ref, &amp;proxy);</span><br><span class="line">            if (callback &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                if (ref &#x3D;&#x3D; NULL)</span><br><span class="line">                    insert_head(result, list);</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;* Someone else added a ref without a callback</span><br><span class="line">                       during GC.  Return that one instead of this one</span><br><span class="line">                       to avoid violating the invariants of the list</span><br><span class="line">                       of weakrefs for ob. *&#x2F;</span><br><span class="line">                    Py_DECREF(result);</span><br><span class="line">                    Py_INCREF(ref);</span><br><span class="line">                    result &#x3D; ref;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                PyWeakReference *prev;</span><br><span class="line"></span><br><span class="line">                prev &#x3D; (proxy &#x3D;&#x3D; NULL) ? ref : proxy;</span><br><span class="line">                if (prev &#x3D;&#x3D; NULL)</span><br><span class="line">                    insert_head(result, list);</span><br><span class="line">                else</span><br><span class="line">                    insert_after(result, prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (PyObject *) result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>weakref.proxy proxy
像是弱引用对象，它们的行为就是它们所引用的对象的行为，这样就
<strong>不必 首先调用弱引用对象来访问背后的对象</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from socket import *</span><br><span class="line">&gt;&gt;&gt; s &#x3D; socket(AF_INET, SOCK_STREAM)</span><br><span class="line">&gt;&gt;&gt; ref_s &#x3D; weakref.ref(s)</span><br><span class="line">&gt;&gt;&gt; ref_s</span><br><span class="line">&lt;weakref at 0x7f9b0316d3c0; to &#39;_socketobject&#39; at 0x7f9b0310b910&gt;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;socket._socketobject object at 0x7f9b0310b910&gt;</span><br><span class="line">&gt;&gt;&gt; proxy_s &#x3D; weakref.proxy(s)</span><br><span class="line">&gt;&gt;&gt; proxy_s</span><br><span class="line">&lt;weakproxy at 0x7f9b03117208 to _socketobject at 0x7f9b0310b910&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; ref_s.close()               #  不能直接调用对象方法</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#39;weakref&#39; object has no attribute &#39;close&#39;</span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>&gt;&gt;&gt; ref_s().close()              #  不能直接调用对象方法，要加上()
&gt;&gt;&gt;
&gt;&gt;&gt; proxy_s.close()              #  可以直接调用对象方法
&gt;&gt;&gt; 
&gt;&gt;&gt; sys.getrefcount(s)
2
&gt;&gt;&gt; ref_s
&lt;weakref at 0x7f9b0316d3c0; to &#39;_socketobject&#39; at 0x7f9b0310b910&gt;
&gt;&gt;&gt; r = ref_s()
&gt;&gt;&gt; r.close()
&gt;&gt;&gt; sys.getrefcount(s)
3
&gt;&gt;&gt; ref_s
&lt;weakref at 0x7f9b0316d3c0; to &#39;_socketobject&#39; at 0x7f9b0310b910&gt;
&gt;&gt;&gt; del ref_s
&gt;&gt;&gt; ref_s
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;ref_s&#39; is not defined
&gt;&gt;&gt;</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>[python]常用API记录</title>
    <url>/2020/10/22/python-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>这篇文章用来记录工作和学习过程中遇到的一些python常用api方法。</p>
<h2><span id="os-mo-kuai">os模块</span><a href="#os-mo-kuai" class="header-anchor">#</a></h2>
<h3><span id="os-walk">os.walk()</span><a href="#os-walk" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.walk(top[, topdown&#x3D;True[, onerror&#x3D;None[, followlinks&#x3D;False]]])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong> top -- 是你所要遍历的目录的地址,
<strong>返回的是一个三元组(root,dirs,files)</strong>。 - root
所指的是当前正在遍历的这个文件夹的本身的地址 - dirs 是一个 list
，内容是该文件夹中所有的目录的名字(不包括子目录) - files 同样是 list ,
内容是该文件夹中所有的文件(不包括子目录)</p>
<p>topdown --可选，为 True，则优先遍历 top 目录，否则优先遍历 top
的子目录(默认为开启)。如果 topdown 参数为 True，walk
会遍历top文件夹，与top 文件夹中每一个子目录。</p>
<p>onerror -- 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。
followlinks -- 可选，如果为 True，则会遍历目录下的快捷方式(linux
下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为
False，则优先遍历 top 的子目录。</p>
<h3><span id="os-getenv-key-default-none">os.getenv(key, default = None)</span><a href="#os-getenv-key-default-none" class="header-anchor">#</a></h3>
<p>返回环境变量键的值(如果存在)，否则返回默认值。</p>
<h3><span id="os-path-abspath-file">os.path.abspath(<strong>file</strong>)</span><a href="#os-path-abspath-file" class="header-anchor">#</a></h3>
<ul>
<li><strong>获取的当前执行脚本的完整路径</strong></li>
<li>只有当在脚本中执行的时候，os.path.abspath(<strong>file</strong>)才会起作用，因为该命令是获取的当前执行脚本的完整路径，如果在交互模式或者terminate
终端中运行会报没有__file__这个错误</li>
</ul>
<h3><span id="os-path-dirname-path">os.path.dirname(path)</span><a href="#os-path-dirname-path" class="header-anchor">#</a></h3>
<p>去掉文件名，返回目录</p>
<h3><span id="os-environ-get">os.environ.get（）</span><a href="#os-environ-get" class="header-anchor">#</a></h3>
<p>是python中os模块获取环境变量的一个方法</p>
<h2><span id="getattr-object-name-default">getattr(object, name[,
default])</span><a href="#getattr-object-name-default" class="header-anchor">#</a></h2>
<p>getattr() 函数用于返回一个<strong>对象属性值</strong>。 - object --
对象。 - name -- 字符串，对象属性。 - default --
默认返回值，如果不提供该参数，在没有对应属性时，将触发
AttributeError。</p>
<h2><span id="shutil-copyfile-src-dst">shutil.copyfile(src, dst)</span><a href="#shutil-copyfile-src-dst" class="header-anchor">#</a></h2>
<p><strong>复制文件内容</strong>（不包含元数据）<strong>从src到dst</strong>。
<strong>dst必须是完整的目标文件名</strong>; 如果src和dst是
<strong>同一文件，就会引发错误shutil.Error</strong>。
<strong>dst必须是可写的</strong>，否则将引发异常IOError。如果dst已经存在，它会被替换。</p>
<h2><span id="property"><span class="citation" data-cites="property">@property</span></span><a href="#property" class="header-anchor">#</a></h2>
<p>Python内置的@property装饰器就是负责<strong>把一个方法变成属性调用</strong>的.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&#39;score must be an integer!&#39;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&#39;score must between 0 ~ 100!&#39;)</span><br><span class="line">        self._score &#x3D; value</span><br></pre></td></tr></table></figure>
<span class="citation" data-cites="property的实现比较复杂">@property的实现比较复杂</span>，我们先考察如何使用。<strong>把一个getter方法变成属性</strong>，只需要加上@property就可以了，此时，<span class="citation" data-cites="property本身">@property本身</span><strong>又创建了另一个装饰器@score.setter</strong>，负责<strong>把一个setter方法变成属性赋值</strong>，于是，我们就拥有一个可控的属性操作：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; Student()</span><br><span class="line">&gt;&gt;&gt; s.score &#x3D; 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.score &#x3D; 9999</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure></p>
<p>还可以<strong>定义只读属性</strong>，<strong>只定义getter方法，不定义setter方法就是一个只读属性</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        return self._birth</span><br><span class="line"></span><br><span class="line">    @birth.setter</span><br><span class="line">    def birth(self, value):</span><br><span class="line">        self._birth &#x3D; value</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2014 - self._birth</span><br></pre></td></tr></table></figure>
上面的<strong>birth是可读可写的</strong>，而<strong>age就是一个只读属性</strong>。</p>
<h2><span id="python-zhong-han-shu-qian-tian-jia-yi-ji-de-yong-fa">python中函数前添加*以及**的用法</span><a href="#python-zhong-han-shu-qian-tian-jia-yi-ji-de-yong-fa" class="header-anchor">#</a></h2>
<p>转自：http://blog.csdn.net/delphiwcdj/article/details/5746560
当要使函数接收元组或字典形式的参数
的时候，有一种特殊的方法，它分别使用*和**前缀
。这种方法在函数需要获取可变数量的参数 的时候特别有用。</p>
<p>[注意] [1] 由于在args变量前有*前缀
，所有多余的函数参数都会作为一个元组存储在args中
。如果使用的是<strong>前缀 ，多余的参数则会被认为是一个字典的健/值对 。
[2] 对于def func(<em>args):，</em>args表示把传进来的位置参数存储在
</strong>tuple（元组）args里面<strong>。例如，调用func(1, 2, 3)
，args就表示(1, 2, 3)这个元组 。 [3] 对于 def
func(</strong>args):，<strong>args表示把参数
</strong>作为字典的健-值对存储在dict（字典）args里面**。例如，调用func(a='I',
b='am', c='wcdj') ，args就表示{'a':'I', 'b':'am', 'c':'wcdj'}这个字典 。
[4]
注意普通参数与*和**参数公用的情况，一般将*和**参数放在参数列表最后。</p>
<h2><span id="globals">globals()</span><a href="#globals" class="header-anchor">#</a></h2>
<p>以字典类型返回<strong>当前位置的全部全局变量</strong></p>
<h2><span id="locals-han-shu">locals() 函数</span><a href="#locals-han-shu" class="header-anchor">#</a></h2>
<p>locals() 函数会
<strong>以字典类型返回当前位置的全部局部变量</strong>。 对于函数, 方法,
lambda 函式, 类, 以及实现了 <strong>call</strong> 方法的类实例, 它都返回
True。</p>
<h2><span id="lambad-han-shu-yong-fa">lambad函数用法</span><a href="#lambad-han-shu-yong-fa" class="header-anchor">#</a></h2>
<p>####（1）直接赋给一个变量，然后再像一般函数那样调用
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c&#x3D;lambda x,y,z:x*y*z</span><br><span class="line">c(2,3,4)</span><br><span class="line"></span><br><span class="line">24</span><br></pre></td></tr></table></figure>
当然，也可以在函数后面直接传递实参
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lambda x:x**2)(3)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
####（2）将lambda函数作为参数传递给其他函数比如说结合map、filter、sorted、reduce等一些Python内置函数使用，下面举例说明。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fliter(lambda x:x%3&#x3D;&#x3D;0,[1,2,3,4,5,6])</span><br><span class="line"></span><br><span class="line">[3,6]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">squares &#x3D; map(lambda x:x**2,range(5)</span><br><span class="line">print(lsit(squares))</span><br><span class="line">[0,1,4,9,16]</span><br></pre></td></tr></table></figure>
与sorted函数结合使用，比如：创建由元组构成的列表：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;[(&#39;b&#39;,3),(&#39;a&#39;,2),(&#39;d&#39;,4),(&#39;c&#39;,1)]</span><br></pre></td></tr></table></figure>
按照第一个元素排序
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted(a,key&#x3D;lambda x:x[0])</span><br><span class="line">[(&#39;a&#39;,2),(&#39;b&#39;,3),(&#39;c&#39;,1),(&#39;d&#39;,4)]</span><br></pre></td></tr></table></figure>
按照第二个元素排序
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted(a,key&#x3D;lambda x:x[1])</span><br><span class="line">[(&#39;c&#39;,1),(&#39;a&#39;,2),(&#39;b&#39;,3),(&#39;d&#39;,4)]</span><br></pre></td></tr></table></figure>
与reduce函数结合使用
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">print(reduce(lambda a,b:&#39;&#123;&#125;,&#123;&#125;&#39;.format(a,b),[1,2,3,4,5,6,7,8,9]))</span><br><span class="line"></span><br><span class="line">1,2,3,4,5,6,7,8,9</span><br></pre></td></tr></table></figure>
####（3）嵌套使用将lambda函数嵌套到普通函数中，lambda函数本身做为return的值
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def increment(n):</span><br><span class="line">    return lambda x:x+n</span><br><span class="line"></span><br><span class="line">f&#x3D;increment(4)</span><br><span class="line">f(2)</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
####（4）字符串联合，有默认值，也可以用x=(lambda...)这种格式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;(lambda x&#x3D;&#39;Boo&#39;,y&#x3D;&#39;Too&#39;,z&#x3D;&#39;Z00&#39;：x+y+z)</span><br><span class="line">print(x(&#39;Foo&#39;))</span><br><span class="line"></span><br><span class="line">&#39;FooTooZoo&#39;</span><br></pre></td></tr></table></figure>
####（5）在tkinter中定义内联的callback函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from tkinter import Button,mainloop</span><br><span class="line"></span><br><span class="line">x&#x3D;Button(text&#x3D;&#39;Press me&#39;,command&#x3D;(lambda :sys.stdout.write(&#39;Hello,World\n&#39;)))</span><br><span class="line">x.pack()</span><br><span class="line">x.mainloop()</span><br></pre></td></tr></table></figure>
这段代码还是挺有意思的，希望小伙伴们可以复制粘贴运行一下哈。
####（6）判断字符串是否以某个字母开头有
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Names &#x3D; [&#39;Anne&#39;, &#39;Amy&#39;, &#39;Bob&#39;, &#39;David&#39;, &#39;Carrie&#39;, &#39;Barbara&#39;, &#39;Zach&#39;]</span><br><span class="line">B_Name&#x3D; filter(lambda x: x.startswith(&#39;B&#39;),Names)</span><br><span class="line">print(B_Name)</span><br><span class="line"></span><br><span class="line">[&#39;Bob&#39;, &#39;Barbara&#39;]</span><br></pre></td></tr></table></figure>
####（7）求两个列表元素的和
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [1,2,3,4]</span><br><span class="line">b &#x3D; [5,6,7,8]</span><br><span class="line">print(list(map(lambda x,y:x+y, a,b)))</span><br><span class="line"></span><br><span class="line">[6,8,10,12]</span><br></pre></td></tr></table></figure>
####（8）求字符串每个单词的长度
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentence &#x3D; &quot;Welcome To Beijing!&quot;</span><br><span class="line">words &#x3D; sentence.split()</span><br><span class="line">lengths  &#x3D; map(lambda x:len(x),words)</span><br><span class="line">print(list(lengths))</span><br><span class="line">[7,2,8]</span><br></pre></td></tr></table></figure></p>
<h2><span id="for-else-jie-gou">for else结构</span><a href="#for-else-jie-gou" class="header-anchor">#</a></h2>
<p>for else 结构还是第一次见，于是记录一下。如果for循环
<strong>正常结束，else中语句执行</strong>。如果是
<strong>break</strong>的，则 <strong>不执行</strong>。</p>
<p>简单使用场景:寻找100以内的素数之和
(这个应该是较暴力算法，这里不讨论算法问题)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum&#x3D;0</span><br><span class="line">for n in range(2,100):</span><br><span class="line">    for i in range(2,n):</span><br><span class="line">        if n%i&#x3D;&#x3D;0:          # 不是素数</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        sum+&#x3D;n              # 加上素数</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure></p>
<h2><span id="shan-yong-san-mu-yun-suan">善用三目运算</span><a href="#shan-yong-san-mu-yun-suan" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; 3 if res &gt; 3 else 1</span><br></pre></td></tr></table></figure>
<h2><span id="jie-shou-dong-tai-can-shu-sys-argv">接受动态参数sys.argv</span><a href="#jie-shou-dong-tai-can-shu-sys-argv" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># test.py</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">def main(argv)</span><br><span class="line">    print(argv)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python test.py 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2><span id="binascii-er-jin-zhi-he-ascii-ma-hu-zhuan">binascii --- 二进制和 ASCII
码互转</span><a href="#binascii-er-jin-zhi-he-ascii-ma-hu-zhuan" class="header-anchor">#</a></h2>
<p><a href="https://docs.python.org/zh-cn/3/library/binascii.html" title="binascii --- 二进制和 ASCII 码互转">binascii介绍</a> ###
返回二进制数据 data 的十六进制表示形式
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binascii.b2a_hex(data[, sep[, bytes_per_sep&#x3D;1]])</span><br><span class="line">binascii.hexlify(data[, sep[, bytes_per_sep&#x3D;1]])</span><br></pre></td></tr></table></figure>
data
的每个字节都被转换为相应的2位十六进制表示形式。因此返回的字节对象的长度是
data 的两倍。</p>
<h3><span id="fan-hui-you-shi-liu-jin-zhi-zi-fu-chuan-hexstr-biao-shi-de-er-jin-zhi-shu-ju">返回由十六进制字符串
hexstr 表示的二进制数据</span><a href="#fan-hui-you-shi-liu-jin-zhi-zi-fu-chuan-hexstr-biao-shi-de-er-jin-zhi-shu-ju" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binascii.a2b_hex(hexstr)</span><br><span class="line">binascii.unhexlify(hexstr)</span><br></pre></td></tr></table></figure>
<p>此函数功能与 b2a_hex() 相反。 hexstr 必须包含
<strong>偶数个十六进制数字</strong>（可以是大写或小写），否则会引发
Error 异常。</p>
<h2><span id="zlip">zlip</span><a href="#zlip" class="header-anchor">#</a></h2>
<ul>
<li><p>字符串：使用 <strong>zlib.compress</strong>可以压缩字符串。使用
<strong>zlib.decompress</strong>可以解压字符串。</p></li>
<li><p>数据流：压缩：<strong>compressobj</strong>，解压：<strong>decompressobj</strong></p></li>
</ul>
<h2><span id="cpickle">cPickle</span><a href="#cpickle" class="header-anchor">#</a></h2>
<h4><span id="cpickle-dump">cPickle.dump</span><a href="#cpickle-dump" class="header-anchor">#</a></h4>
<p>将python对象序列化
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cPickle.dump(obj, file, protocol&#x3D;None, *, fix_imports&#x3D;True, buffer_callback&#x3D;None)</span><br></pre></td></tr></table></figure></p>
<h4><span id="cpickle-load">cPickle.load</span><a href="#cpickle-load" class="header-anchor">#</a></h4>
<p>载入本地文件，恢复python对象
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; data &#x3D; cPickle.load(open(&quot;test\\data.pkl&quot;,&quot;rb&quot;))</span><br></pre></td></tr></table></figure></p>
<h4><span id="cpickle-dumps">cPickle.dumps</span><a href="#cpickle-dumps" class="header-anchor">#</a></h4>
<p>将python对象序列化保存到一个字符串变量中
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; data_string &#x3D; cPickle.dumps(data)</span><br></pre></td></tr></table></figure></p>
<h4><span id="cpickle-loads">cPickle.loads</span><a href="#cpickle-loads" class="header-anchor">#</a></h4>
<p>从字符串变量中载入python对象
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; data &#x3D; cPickle.loads(data_string)</span><br></pre></td></tr></table></figure></p>
<h2><span id="pyflakes">pyflakes</span><a href="#pyflakes" class="header-anchor">#</a></h2>
<p>检查加载字符串代码是否有错
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pyflakes.api import checkCode</span><br><span class="line">a &#x3D; f.read()</span><br><span class="line">checkCode(a, my_Reporter(sys.stdout, sys.stderr)) # my_Reporter是pyflakes.reporter的拓展</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 3.float解析</title>
    <url>/2020/11/10/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-float%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1><span id="nei-bu-jie-gou">内部结构</span><a href="#nei-bu-jie-gou" class="header-anchor">#</a></h1>
<p>float 实例对象在 Include/floatobject.h 中定义如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD   &#x2F;&#x2F;定长对象共用的头部</span><br><span class="line">    double ob_fval;  &#x2F;&#x2F;额外字段,存储对象所承载的浮点值</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure></p>
下面是浮点<strong>实例对象</strong>内部结构图：
<div style="width:95%;margin:auto">
<img src="/2020/11/10/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-float%E8%A7%A3%E6%9E%90/%5Bpython%5Dfloat1.png" class title="PyFloatObject图">
</div>
<h2><span id="float-lei-xing-dui-xiang">float 类型对象</span><a href="#float-lei-xing-dui-xiang" class="header-anchor">#</a></h2>
<p>与实例对象不同， <strong>float 类型对象 全局唯一</strong>
，因此可以作为 <strong>全局变量</strong> 定义。 在 C 文件
<strong>Objects/floatobject.c</strong> 中，我们找到了代表 float
类型对象的<strong>全局变量 PyFloat_Type</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyFloat_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;float&quot;,                                  &#x2F;*tp_name 字段保存类型名称，常量 float*&#x2F;</span><br><span class="line">    sizeof(PyFloatObject),</span><br><span class="line">    0,</span><br><span class="line">    (destructor)float_dealloc,                  &#x2F;* tp_dealloc 对象销毁相关*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_print *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_getattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_reserved *&#x2F;</span><br><span class="line">    (reprfunc)float_repr,                       &#x2F;* tp_repr 生成语法字符串表示形式的函数*&#x2F;</span><br><span class="line">    &amp;float_as_number,                           &#x2F;* tp_as_number 数值操作集*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc)float_hash,                       &#x2F;* tp_hash 哈希值生成函数*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_call *&#x2F;</span><br><span class="line">    (reprfunc)float_repr,                       &#x2F;* tp_str 生成普通字符串表示形式的函数*&#x2F;</span><br><span class="line">    PyObject_GenericGetAttr,                    &#x2F;* tp_getattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_buffer *&#x2F;</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   &#x2F;* tp_flags *&#x2F;</span><br><span class="line">    float_new__doc__,                           &#x2F;* tp_doc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_traverse *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_clear *&#x2F;</span><br><span class="line">    float_richcompare,                          &#x2F;* tp_richcompare *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_weaklistoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iter *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iternext *&#x2F;</span><br><span class="line">    float_methods,                              &#x2F;* tp_methods *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_members *&#x2F;</span><br><span class="line">    float_getset,                               &#x2F;* tp_getset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_base *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dict *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_get *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_set *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dictoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_init 对象创建相关(tp_init 函数指针在这为空，因为float对象简单，只需要tp_new赋值就行)*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_alloc 对象创建相关*&#x2F;</span><br><span class="line">    float_new,                                  &#x2F;* tp_new 对象创建相关*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PyFloat_Type 中保存了很多关于浮点对象的 <strong>元信息</strong></p>
<p>PyFloat_Type 很重要，作为浮点 <strong>类型对象</strong>
，它决定了<strong>浮点 实例对象 的 生死和行为</strong> 。</p>
<h1><span id="dui-xiang-de-chuang-jian">对象的创建</span><a href="#dui-xiang-de-chuang-jian" class="header-anchor">#</a></h1>
<p>调用<strong>类型对象 float 创建实例对象</strong>: Python 执行的是
type 类型对象中的 <strong>tp_call</strong> 函数。 tp_call 函数进而调用
<strong>float 类型对象的 tp_new 函数创建实例对象</strong>， 再调用
<strong>tp_init 函数对其进行初始化</strong>：</p>
<div style="width:95%;margin:auto">
<img src="/2020/11/10/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-float%E8%A7%A3%E6%9E%90/%5Bpython%5Dfloat_create.jpg" class title="Float对象创建图">
</div>
<p>除了通用的流程， Python 为内置对象实现了对象创建 API
，简化调用，提高效率：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyFloat_FromDouble(double fval);  &#x2F;*通过浮点值创建浮点对象*&#x2F;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyFloat_FromString(PyObject *v);  &#x2F;*通过字符串对象创建浮点对象*&#x2F;</span><br></pre></td></tr></table></figure></p>
<p>以 <strong>PyFloat_FromDouble</strong> 为例，特化的对象创建流程如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyFloat_FromDouble(double fval)</span><br><span class="line">&#123;</span><br><span class="line">    PyFloatObject *op &#x3D; free_list;</span><br><span class="line">    &#x2F;*为对象 分配内存空间，优先使用空闲对象缓存池 *&#x2F;</span><br><span class="line">    if (op !&#x3D; NULL) &#123;                 </span><br><span class="line">        free_list &#x3D; (PyFloatObject *) Py_TYPE(op);</span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;*空闲对象缓存池为空，调用PyObject_MALLOC申请内存 *&#x2F;</span><br><span class="line">    else &#123;</span><br><span class="line">        op &#x3D; (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));</span><br><span class="line">        if (!op)</span><br><span class="line">            return PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* Inline PyObject_New *&#x2F;</span><br><span class="line">    (void)PyObject_INIT(op, &amp;PyFloat_Type);</span><br><span class="line"></span><br><span class="line">    &#x2F;*将 ob_fval 字段初始化为指定 浮点值 *&#x2F;</span><br><span class="line">    op-&gt;ob_fval &#x3D; fval;    </span><br><span class="line">    return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面用到的宏 PyObject_INIT 在头文件 Include/objimpl.h 中定义为：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PyObject_INIT(op, typeobj) \</span><br><span class="line">    ( Py_TYPE(op) &#x3D; (typeobj), _Py_NewReference((PyObject *)(op)), (op) )  &#x2F;&#x2F;前半部分调用  Py_TYPE(op) 初始化 对象类型 字段 ob_type，后面语句初始化 引用计数 字段 ob_refcnt</span><br></pre></td></tr></table></figure></p>
<p>上面提到的宏定义 <strong>Py_TYPE</strong>，位于 Include/object.h
头文件：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Py_TYPE(ob) (((PyObject*)(ob))&amp;ob_type)</span><br></pre></td></tr></table></figure>
它的作用是：将 <strong>给定对象的类型对象取出,
返回对象的ob_type字段</strong>。</p>
<p>宏 _Py_NewReference，在 Include/Object.h 中定义：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _Py_NewReference(op) (                          \</span><br><span class="line">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</span><br><span class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</span><br><span class="line">    Py_REFCNT(op) &#x3D; 1)   &#x2F;*将对象引用计数初始化为 1*&#x2F;</span><br></pre></td></tr></table></figure></p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%">
</colgroup>
<tbody>
<tr>
<td># 对象的销毁 当对象不再需要时， Python 通过 <strong>Py_DECREF 或者
Py_XDECREF 宏减少引用计数</strong>； 当引用计数降为 0 时， Python 通过
**_Py_Dealloc** 宏回收对象：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _Py_Dealloc(op) (                               \</span><br><span class="line">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span><br><span class="line">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))   &#x2F;*调用类型对象 **PyFloat_Type 中的 tp_dealloc 函数指针*&#x2F;</span><br></pre></td></tr></table></figure>
因此，实际调用的函数是 float_dealloc (代码在下一小节 空闲对象缓存池
中解析)：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">float_dealloc(PyFloatObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    if (PyFloat_CheckExact(op)) &#123;</span><br><span class="line">      &#x2F;*空闲对象缓存池满了，直接销毁*&#x2F;</span><br><span class="line">        if (numfree &gt;&#x3D; PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">            PyObject_FREE(op);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        numfree++;</span><br><span class="line">        Py_TYPE(op) &#x3D; (struct _typeobject *)free_list;</span><br><span class="line">        free_list &#x3D; op;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
总结起来，对象从创建到销毁整个生命周期所涉及的
<strong>关键函数、宏及调用关系</strong> 如下：</td>
</tr>
</tbody>
</table>
<h1><span id="kong-xian-dui-xiang-huan-cun-chi">空闲对象缓存池</span><a href="#kong-xian-dui-xiang-huan-cun-chi" class="header-anchor">#</a></h1>
<p>浮点运算背后涉及 大量临时对象创建以及销毁 ，以下面计算为例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; area &#x3D; pi * r ** 2</span><br></pre></td></tr></table></figure>
这个语句首先计算半径 r **
2，中间结果由一个<strong>临时对象</strong>来保存，假设是 t ；
然后计算圆周率 <strong>pi 与 t 的乘积</strong>，得到最终结果并赋值给变量
area ； 最后，销毁<strong>临时对象 t</strong> 。
这么简单的语句，背后居然都隐藏着一个
<strong>临时对象的创建以及销毁</strong>操作！</p>
<p>创建对象时需要分配内存，销毁对象时又需要回收内存。
大量临时对象创建销毁 ，意味着 大量内存分配回收操作
，这显然是是不可接受的。</p>
<p>因此 <strong>Python
在浮点对象销毁后，并不急于回收内存</strong>，而是<strong>将对象放入一个
空闲链表</strong> 。
后续需要创建浮点对象时，先到空闲链表中取，省去分配内存的开销。</p>
浮点对象的空闲链表同样在 Objects/floatobject.c 中定义：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef PyFloat_MAXFREELIST</span><br><span class="line">#define PyFloat_MAXFREELIST    100           &#x2F;*该宏  限制空闲链表的 最大长度 ，避免占用过多内存*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">static int numfree &#x3D; 0;                     &#x2F;*维护空闲链表 当前长度*&#x2F;</span><br><span class="line">static PyFloatObject *free_list &#x3D; NULL;    &#x2F;*指向空闲链表 头节点 的指针*&#x2F;</span><br></pre></td></tr></table></figure>
为了保持简洁， Python 把 <strong>ob_type 字段当作 next
指针来用</strong>，将 <strong>空闲对象串成链表</strong>：
<div style="width:95%;margin:auto">

</div>
<p>因此创建浮点对象时，可以从 <strong>链表中取出空闲对象</strong>，省去
<strong>申请内存的开销</strong>！ 以 PyFloat_FromDouble 为例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyFloatObject *op &#x3D; free_list;                  &#x2F;*op指向第一个 空闲对象*&#x2F;</span><br><span class="line">if (op !&#x3D; NULL) &#123;</span><br><span class="line">    free_list &#x3D; (PyFloatObject *) Py_TYPE(op);  &#x2F;*free_list指向第一个 空闲对象(op)的ob_type所指向的 下一个空闲对象(相当于链表的头部删除)*&#x2F;</span><br><span class="line">    numfree--;                                  &#x2F;*更新空闲链表维护的数量*&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    op &#x3D; (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));    &#x2F;*free_list为空时，重新分配内存*&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象销毁时， Python 将其缓存在空闲链表中，以备后用。考察
float_dealloc 函数：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (numfree &gt;&#x3D; PyFloat_MAXFREELIST)  &#123;   &#x2F;*销毁时，判断free_list是否达到最大容量*&#x2F;</span><br><span class="line">    PyObject_FREE(op);                   &#x2F;*回收对象内*&#x2F;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">numfree++;                                      </span><br><span class="line">Py_TYPE(op) &#x3D; (struct _typeobject *)free_list;  &#x2F;*op的ob_type指向当前 第一个空闲对象*&#x2F;</span><br><span class="line">free_list &#x3D; op;                                 &#x2F;* free_list指向op(相当于链表的头部插入)*&#x2F;</span><br></pre></td></tr></table></figure>
空闲对象缓存池在 <strong>提高对象分配效率</strong>
方面发挥着至关重要的作用。</p>
<h1><span id="dui-xiang-de-xing-wei">对象的行为</span><a href="#dui-xiang-de-xing-wei" class="header-anchor">#</a></h1>
<p>PyFloat_Type 中定义了很多函数指针，包括 tp_repr 、 tp_str 、 tp_hash
等。 这些函数指针将一起决定 float 对象的行为，例如 tp_hash
函数决定浮点哈希值的计算：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pi &#x3D; 3.14</span><br><span class="line">&gt;&gt;&gt; hash(pi)</span><br><span class="line">322818021289917443</span><br></pre></td></tr></table></figure>
tp_hash 函数指针指向 <strong>float_hash 函数</strong>，实现了
<strong>针对浮点对象的哈希值算法</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Py_hash_t</span><br><span class="line">float_hash(PyFloatObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    return _Py_HashDouble(v-&gt;ob_fval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## 数值操作集 由于加减乘除等数值操作很常见， Python 将其抽象成数值操作集
<strong>PyNumberMethods</strong> 。 数值操作集 PyNumberMethods 在头文件
<strong>Include/object.h</strong> 中定义：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    &#x2F;* Number implementations must check *both*</span><br><span class="line">    arguments for proper type and implement the necessary conversions</span><br><span class="line">    in the slot functions themselves. *&#x2F;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>
PyNumberMethods
定义了各种数学算子的处理函数，数值计算最终由这些函数执行。
处理函数根据参数个数可以分为： <strong>一元函数 ( unaryfunc )、 二元函数
( binaryfunc )</strong>等。</p>
<ul>
<li>一元函数 ( unaryfunc ): 需要传入一个参数的函数。</li>
<li>二元函数 ( binaryfunc): 需要传入两个参数的函数。</li>
</ul>
<p>回到 Objects/floatobject.c 观察浮点对象数值操作集 float_as_number
是如何初始化的：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyNumberMethods float_as_number &#x3D; &#123;</span><br><span class="line">    float_add,          &#x2F;* nb_add *&#x2F;</span><br><span class="line">    float_sub,          &#x2F;* nb_subtract *&#x2F;</span><br><span class="line">    float_mul,          &#x2F;* nb_multiply *&#x2F;</span><br><span class="line">    float_rem,          &#x2F;* nb_remainder *&#x2F;</span><br><span class="line">    float_divmod,       &#x2F;* nb_divmod *&#x2F;</span><br><span class="line">    float_pow,          &#x2F;* nb_power *&#x2F;</span><br><span class="line">    (unaryfunc)float_neg, &#x2F;* nb_negative *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    0,                  &#x2F;* nb_inplace_add *&#x2F;</span><br><span class="line">    0,                  &#x2F;* nb_inplace_subtract *&#x2F;</span><br><span class="line">    0,                  &#x2F;* nb_inplace_multiply *&#x2F;</span><br><span class="line">    0,                  &#x2F;* nb_inplace_remainder *&#x2F;</span><br><span class="line">    0,                  &#x2F;* nb_inplace_power *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
以加法为例，以下语句在 Python 内部最终由 float_add 函数执行：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1.5</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1.1</span><br><span class="line">&gt;&gt;&gt; a + b</span><br><span class="line">2.6</span><br></pre></td></tr></table></figure>
float_add 是一个 二元函数 ，位于 Objects/floatobject.h 中：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">float_add(PyObject *v, PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    double a,b;</span><br><span class="line">    &#x2F;&#x2F;将两个参数对象转化成浮点值，CONVERT_TO_DOUBLE是一个宏，将PyFloatObject里面的ob_fval抽出来给double变量</span><br><span class="line">    CONVERT_TO_DOUBLE(v, a);</span><br><span class="line">    CONVERT_TO_DOUBLE(w, b);</span><br><span class="line">    PyFPE_START_PROTECT(&quot;add&quot;, return 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对两个浮点值求和</span><br><span class="line">    a &#x3D; a + b;</span><br><span class="line">    PyFPE_END_PROTECT(a)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个新浮点对象保存计算结果并返回</span><br><span class="line">    return PyFloat_FromDouble(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
浮点数计算一般都遵循
<strong>IEEE-754</strong>标准，如果计算时出现了错误，那么需要
<strong>将IEEE-754异常转换成Python中的异常</strong>，而
<strong>PyFPE_START_PROTECT和PyFPE_END_PROTECT</strong>这两个宏就是用来干这件事情的。
它们的定义在Include/pyfpe.h中，并且Python3.9的时候会被删除掉。</p>
<p>所以如果是 <strong>C中的两个浮点数相加，直接a +
b就可以了，编译之后就是一条简单的机器指令</strong>，然而
<strong>Python则需要额外做很多其它工作</strong>。从一个简单的加法上面就可以看出来Python为什么会比C慢几十倍了。</p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<ol type="1">
<li><a href="https://www.imooc.com/read/76/article/1902" title="小试牛刀，解剖浮点对象 float">小试牛刀，解剖浮点对象
float</a></li>
<li><a href="https://my.oschina.net/u/4355012/blog/4464067" title="浮点数的底层实现">浮点数的底层实现</a></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 2.对象的生命周期</title>
    <url>/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1><span id="c-api">C API</span><a href="#c-api" class="header-anchor">#</a></h1>
<p>开始讨论对象创建前，先介绍 Python 提供的 C API 。 Python 是用 C
写成的，对外提供了 C API ，让用户可以从 C 环境中与其交互。 Python
内部也大量使用这些 API ，为了更好研读源码，先系统了解 API
组成结构很有必要。 C API 分为两类： <strong>泛型 API 以及 特型
API</strong>。</p>
<h2><span id="fan-xing-api">泛型 API</span><a href="#fan-xing-api" class="header-anchor">#</a></h2>
<p>泛型 API 与类型无关，属于 抽象对象层 ( Abstract Object Layer )，简称
AOL 。 这类 API 参数是 PyObject*
，<strong>可处理任意类型的对象</strong>， API 内部根据对象类型区别处理。
以对象打印函数为例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int PyObject_Print(PyObject *op, FILE *fp, int flags)</span><br></pre></td></tr></table></figure></p>
<p>接口第一个参数为待打印对象，可以是任意类型的对象，因此参数类型是
PyObject* 。 Python 内部一般都是通过 PyObject*
引用对象，以达到泛型化的目的。 <strong>对于任意类型的对象，均可调用
PyObject_Print 将其打印出来</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印浮点对象</span><br><span class="line">PyObject *fo &#x3D; PyFloatObject_FromDouble(3.14);</span><br><span class="line">PyObject_Print(fo, stdout, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印整数对象</span><br><span class="line">PyObject *lo &#x3D; PyFloatObject_FromLong(100);</span><br><span class="line">PyObject_Print(lo, stdout, 0);</span><br><span class="line">PyObject_Print 接口内部根据对象类型，决定如何输出对象。</span><br></pre></td></tr></table></figure></p>
<h2><span id="te-xing-api">特型 API</span><a href="#te-xing-api" class="header-anchor">#</a></h2>
<p>特型 API 与类型相关，属于 具体对象层 ( Concrete Object Layer )，简称
COL 。 这类 API 只能作用于某种类型的对象，例如浮点对象 PyFloatObject 。
Python 内部为每一种内置对象提供了这样一组 API ，举例如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyObject * PyFloat_FromDouble(double fval)</span><br></pre></td></tr></table></figure>
PyFloat_FromDouble 创建一个浮点对象，并将它初始化为给定值 fval 。</p>
<h1><span id="dui-xiang-de-chuang-jian">对象的创建</span><a href="#dui-xiang-de-chuang-jian" class="header-anchor">#</a></h1>
<p>经过前面的理论学习，我们知道对象的 <strong>元数据</strong>
保存在对应的 <strong>类型对象</strong> 中，元数据当然也包括
<strong>对象如何创建 的信息</strong>。 因此，有理由相信 <strong>实例对象
由 类型对象</strong> 创建。 不管创建对象的流程如何，最终的关键步骤都是
<strong>分配内存</strong> 。 Python 对 内建对象
是无所不知的，因此可以提供 C API ，直接分配内存并执行初始化。 以
PyFloat_FromDouble 为例，在接口内部为 PyFloatObject
结构体分配内存，并初始化相关字段即可。 对于用户自定义的类型 class
Dog(object) ， Python 就无法事先提供 PyDog_New 这样的 C API 了。
这种情况下，就只能通过 Dog 所对应的类型对象创建实例对象了。
至于需要分配多少内存，如何进行初始化，答案就需要在
<strong>类型对象</strong> 中找了。 总结起来，Python
内部一般通过这两种方法创建对象： - 通过 <strong>C API</strong> ，例如
PyFloat_FromDouble ，多用于内建类型； -
通过<strong>类型对象</strong>，例如 Dog ，多用于自定义类型；
通过类型对象创建实例对象，是一个更通用的流程，<strong>同时支持内置类型和自定义类型</strong>。
以创建浮点对象为例，我们还可以通过浮点类型 PyFloat_Type 来创建：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pi &#x3D; float(&#39;3.14&#39;)</span><br><span class="line">&gt;&gt;&gt; pi</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>
例子中我们通过调用类型对象 float ，实例化了一个浮点实例 pi
，<strong>对象居然还可以调用！</strong>在 Python
中，可以被调用的对象就是 <strong>可调用对象</strong> 。</p>
<p>问题来了，可调用对象被调用时，执行什么函数呢？
由于类型对象保存着实例对象的元信息， float 类型对象的类型是 type
，因此秘密应该就隐藏在 type 中。 再次考察 PyType_Type ，我们找到了
<strong>tp_call 字段</strong>，这是一个 <strong>函数指针</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyType_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;type&quot;,                                     &#x2F;* tp_name *&#x2F;</span><br><span class="line">    sizeof(PyHeapTypeObject),                   &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    sizeof(PyMemberDef),                        &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    (ternaryfunc)type_call,                     &#x2F;* tp_call *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当实例对象被调用时，便执行 tp_call 字段保存的处理函数。 因此，
float(‘3.14’) 在 C 层面等价于：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyFloat_Type.ob_type.tp_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>
即：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyType_Type.tp_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>
最终执行， type_call 函数：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type_call(&amp;PyFloat_Type, args, kwargs)</span><br></pre></td></tr></table></figure>
调用参数通过 args 和 kwargs
两个对象传递，先不展开，留到函数机制中详细介绍。 接着围观 type_call
函数，定义于 Include/typeobject.c ，关键代码如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *obj;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    obj &#x3D; type-&gt;tp_new(type, args, kwds);   &#x2F;&#x2F;为对象分配内存</span><br><span class="line">    obj &#x3D; _Py_CheckFunctionResult((PyObject*)type, obj, NULL);</span><br><span class="line">    if (obj &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    type &#x3D; Py_TYPE(obj);                     &#x2F;&#x2F;获取PyType_Type</span><br><span class="line">    if (type-&gt;tp_init !&#x3D; NULL) &#123;</span><br><span class="line">        int res &#x3D; type-&gt;tp_init(obj, args, kwds);   &#x2F;&#x2F;初始化对象</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            assert(PyErr_Occurred());</span><br><span class="line">            Py_DECREF(obj);                  &#x2F;&#x2F;引用减一</span><br><span class="line">            obj &#x3D; NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            assert(!PyErr_Occurred());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，关键的步骤有两个： 1. 调用类型对象 tp_new 函数指针 申请内存
(第 7 行)； 2. 必要时调用类型对象 tp_init 函数指针对对象进行 初始化 (第
15 行)； 至此，对象的创建过程已经非常清晰了：</p>
<div style="width:80%;margin:auto">
<img src="/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%5Bpython%5D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png" class title="PyVarObject图">
</div>
<hr>
<p>总结一下，float 类型对象是 可调用对象 ，调用 float 即可创建实例对象：
1. 调用 float ， Python 最终执行其类型对象 type 的 tp_call 函数； 2.
tp_call 函数调用 float 的 tp_new 函数为实例对象分配 内存空间 ； 3.
tp_call 函数必要时进一步调用 tp_init 函数对实例对象进行 初始化 ；</p>
<h1><span id="dui-xiang-de-duo-tai-xing">对象的多态性</span><a href="#dui-xiang-de-duo-tai-xing" class="header-anchor">#</a></h1>
<p>Python 创建一个对象，比如 PyFloatObject ，会分配内存，并进行初始化。
此后， Python 内部 <strong>统一通过一个 PyObject*
变量来保存和维护这个对象</strong>，而不是通过 PyFloatObject* 变量。 通过
PyObject* 变量保存和维护对象，可以
<strong>实现更抽象的上层逻辑</strong>，而不用关心对象的实际类型和实现细节。
以对象哈希值计算为例，假设有这样一个函数接口：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Py_hash_t PyObject_Hash(PyObject *v);</span><br></pre></td></tr></table></figure>
该函数可以计算任意对象的哈希值，不管对象类型是啥。
例如，计算浮点对象哈希值：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyObject *fo &#x3D; PyFloatObject_FromDouble(3.14);</span><br><span class="line">PyObject_Hash(fo);</span><br></pre></td></tr></table></figure>
对于其他类型，例如整数对象，也是一样的：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyObject *lo &#x3D; PyLongObject_FromLong(100);</span><br><span class="line">PyObject_Hash(lo);</span><br></pre></td></tr></table></figure>
然而，对象类型不同，其行为也千差万别，哈希值计算方法便是如此。
PyObject_Hash 函数如何解决这个问题呢？ 到 Object/object.c 中寻找答案：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Py_hash_t</span><br><span class="line">PyObject_Hash(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;类似强制类型转换，但是不像c++一样，用父类指针调用子类就行</span><br><span class="line">    &#x2F;&#x2F;这里的结构体里面指针有ob_type和tp_hash，标记了类型和哈希函数</span><br><span class="line">    PyTypeObject *tp &#x3D; Py_TYPE(v);</span><br><span class="line">    if (tp-&gt;tp_hash !&#x3D; NULL)</span><br><span class="line">        return (*tp-&gt;tp_hash)(v);</span><br><span class="line">    &#x2F;* To keep to the general practice that inheriting</span><br><span class="line">    * solely from object in C code should work without</span><br><span class="line">    * an explicit call to PyType_Ready, we implicitly call</span><br><span class="line">    * PyType_Ready here and then check the tp_hash slot again</span><br><span class="line">    * 隐式调用PyType_Ready，然后再次检查tp_hash插槽</span><br><span class="line">    *&#x2F;</span><br><span class="line">    if (tp-&gt;tp_dict &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        if (PyType_Ready(tp) &lt; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        if (tp-&gt;tp_hash !&#x3D; NULL)</span><br><span class="line">            return (*tp-&gt;tp_hash)(v);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* Otherwise, the object can&#39;t be hashed *&#x2F;</span><br><span class="line">    return PyObject_HashNotImplemented(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数先通过 <strong>ob_type 指针找到对象的类型</strong> (第 4 行)；
然后通过类型对象的 <strong>tp_hash
函数指针，调用对应的哈希值计算函数</strong> (第 6 行)。 换句话讲，
PyObject_Hash 根据对象的类型，调用不同的函数版本。 这不就是 多态 吗？
通过 ob_type 字段， <strong>Python 在 C 语言层面实现了对象的 多态
特性</strong>， 思路跟 C++ 中的 虚表指针 有异曲同工之妙。</p>
<h1><span id="dui-xiang-de-xing-wei">对象的行为</span><a href="#dui-xiang-de-xing-wei" class="header-anchor">#</a></h1>
<p>不同对象的行为不同，比如哈希值计算方法就不同，由类型对象中 tp_hash
字段决定。 除了 tp_hash ，我们看到 PyTypeObject
结构体还定义了很多函数指针，这些指针最终都会指向某个函数，或者为空。
这些函数指针可以看做是 <strong>类型对象（PyTypeObject）</strong>
中定义的 操作 ，这些操作决定对应 <strong>实例对象 在运行时的
行为</strong> 。 尽管如此，不同对象也有一些共性。 举个例子，整数对象 和
浮点对象 都支持加减乘除等 数值型操作 ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3.14 * 3.14</span><br><span class="line">9.8596</span><br></pre></td></tr></table></figure>
元组对象 tuple 和 列表对象 list 都支持下标操作：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; (&#39;apple&#39;, &#39;banana&#39;, &#39;car&#39;, &#39;dog&#39;)</span><br><span class="line">&gt;&gt;&gt; t[-1]</span><br><span class="line">&#39;dog&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l &#x3D; [&#39;alpha&#39;, &#39;beta&#39;]</span><br><span class="line">&gt;&gt;&gt; l[-1]</span><br><span class="line">&#39;beta&#39;</span><br></pre></td></tr></table></figure>
因此，以对象行为为依据，可以 <strong>对对象进行分类</strong>：</p>
<div style="width:80%;margin:auto">
<img src="/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%5Bpython%5D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png" class title="PyVarObject图">
</div>
<hr>
<p>Python 便以此为依据，为每个类别都定义了一个 标准操作集 ： -
PyNumberMethods 结构体定义了 数值型 操作； - PySequenceMethods
结构体定义了 序列型 操作； - PyMappingMethods 结构体定义了 关联型
操作；</p>
<p>只要 类型对象 提供相关 操作集 ， 实例对象 便具备对应的 行为 。
操作集字段如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    const char *tp_name; &#x2F;* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; *&#x2F;</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; &#x2F;* For allocation *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;* Method suites for standard classes *&#x2F;</span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;* Functions to access object as input&#x2F;output buffer *&#x2F;</span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>
以 float 为例，类型对象 PyFloat_Type 相关字段是这样初始化的：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyNumberMethods float_as_number &#x3D; &#123;</span><br><span class="line">    float_add,          &#x2F;* nb_add *&#x2F;</span><br><span class="line">    float_sub,          &#x2F;* nb_subtract *&#x2F;</span><br><span class="line">    float_mul,          &#x2F;* nb_multiply *&#x2F;</span><br><span class="line">    float_rem,          &#x2F;* nb_remainder *&#x2F;</span><br><span class="line">    float_divmod,       &#x2F;* nb_divmod *&#x2F;</span><br><span class="line">    float_pow,          &#x2F;* nb_power *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;PyFloat_Type是PyTypeObject结构体类型，只是重写了</span><br><span class="line">&#x2F;&#x2F;注意与c++父类区分开，这里只是重定义了一些具体参数</span><br><span class="line">PyTypeObject PyFloat_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;float&quot;,</span><br><span class="line">    sizeof(PyFloatObject),</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &amp;float_as_number,                           &#x2F;* tp_as_number *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>字段 <strong>tp_as_number 非空</strong>，因此 float 对象
<strong>支持数值型操作</strong> ；</li>
<li>字段 <strong>tp_as_sequence 为空</strong>，因此 float 对象
<strong>不支持序列型操作</strong> ；</li>
<li>字段 tp_as_mapping 为空，因此 float 对象
<strong>不支持关联型操作</strong> ； 注意到， float_as_number
变量中相关函数指针都初始化为对应的 float 版本操作函数。</li>
</ul>
<h1><span id="yin-yong-ji-shu">引用计数</span><a href="#yin-yong-ji-shu" class="header-anchor">#</a></h1>
<p>C/C++
赋予程序员极大的自由，可以任意申请内存，并按自己的意图灵活管理。
然而，权利的另一面则对应着 责任 ，一旦内存不再使用，程序员必须将其释放。
这给程序员带来极大的 工作负担 ，并导致大量问题： <strong>内存泄露 、
野指针 、 越界访问</strong> 等。 许多后来兴起的开发语言，如 Java 、
Golang 等，选择 由语言本身负责内存的管理 。 垃圾回收机制
的引入，程序员摆脱了内存管理的噩梦，可以更专注于业务逻辑。
于此同时，开发人员失去了灵活使用内存的机会，也牺牲了一定的执行效率。
随着垃圾回收机制日益完善，可在大部分对性能要求不苛刻的场景中引入，利大于弊。
Python 也采用垃圾回收机制，代替程序员进行繁重的内存管理，提升开发效率
的同时，降低 bug 发生的几率。 Python 垃圾回收机制的关键是对象的
<strong>引用计数</strong> ，它决定了一个对象的生死。 我们知道每个 Python
对象都有一个 <strong>ob_refcnt</strong> 字段，记录着对象当前的引用计数。
当对象被其他地方引用时， ob_refcnt 加一； 当引用解除时， ob_refcnt
减一。 当 ob_refcnt 为零，说明对象已经没有任何引用了，这时便可将其回收。
Python 对象创建后，引用计数设为 1 ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 3.14</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<strong>这里引用计数为啥是 2 呢</strong>？ 对象
<strong>作为函数参数传递，需要将引用计数加一(重)，避免对象被提前销毁</strong>；函数返回时，再将引用计数减一。
因此，例子中 getrefcount 函数看到的对象引用计数为 2 。
接着，变量赋值让对象多了一个引用，这很好理解：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
将对象放在容器对象中，引用计数也增加了，符合预期：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; l &#x3D; [a]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[3.14]</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
我们将 b 变量删除，引用计数减少了：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; del b</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
接着，将列表清空，引用计数进一步下降：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; l.clear()</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
最后，将变量 a 删除后，引用计数降为 0 ，便不复存在了：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; del a</span><br></pre></td></tr></table></figure>
在 Python 中，很多场景都涉及引用计数的调整，例如： -
<strong>容器操作</strong>； - <strong>变量赋值</strong>； -
<strong>函数参数传递</strong>； - <strong>属性操作</strong>；</p>
<p>为此， Python 定义了两个非常重要的宏，用于维护对象应用计数。 其中，
Py_INCREF 将对象应用计数加一 ( 3 行)：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Py_INCREF(op) (                         \</span><br><span class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="line">    ((PyObject *)(op))-&gt;ob_refcnt++)</span><br></pre></td></tr></table></figure>
Py_DECREF 将引用计数减一 ( 5 行)，并在引用计数为 0 是回收对象 ( 8 行)：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Py_DECREF(op)                                   \</span><br><span class="line">    do &#123;                                                \</span><br><span class="line">        PyObject *_py_decref_tmp &#x3D; (PyObject *)(op);    \</span><br><span class="line">        if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="line">        --(_py_decref_tmp)-&gt;ob_refcnt !&#x3D; 0)             \</span><br><span class="line">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span><br><span class="line">        else</span><br><span class="line">            \\ 调用对象对应的析构函数销毁对象 </span><br><span class="line">            _Py_Dealloc(_py_decref_tmp);                \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure>
当一个对象引用计数为 0 ， Python
便调用对象对应的析构函数销毁对象，但这并不意味着对象内存一定会回收。
为了提高内存分配效率， Python 为一些
<strong>常用对象维护了内存池</strong>，
<strong>对象回收后内存进入内存池中</strong>，以便下次使用，由此
避免频繁申请、释放内存 。 内存池
技术作为程序开发的高级话题，需要更大的篇幅，放在后续章节中介绍。</p>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 4.不溢出的整数int</title>
    <url>/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/</url>
    <content><![CDATA[<h1><span id="zheng-shu-yi-chu">整数溢出</span><a href="#zheng-shu-yi-chu" class="header-anchor">#</a></h1>
<p>c语言中，32位机器的int 长度为32 位，表示的范围: [-2147483648,
2147483647], 超过这个范围就会溢出了。
由于整数溢出现象的存在，程序员需要结合业务场景，<strong>谨慎选择数据类型</strong>。</p>
<p>而在python中，就没有整数溢出的烦恼。 Python
可以计算十的一百次方，这在其他语言是不可想象的：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 ** 100</span><br><span class="line">10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>
也许我们过去都接触过
<strong>c语言大整数的实现</strong>，接下来我们来看看python如何实现大整数。</p>
<h1><span id="int-dui-xiang">int 对象</span><a href="#int-dui-xiang" class="header-anchor">#</a></h1>
<p>int 对象在 Include/longobject.h 头文件中定义：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _longobject PyLongObject; &#x2F;* Revealed in longintrepr.h *&#x2F;</span><br></pre></td></tr></table></figure>
顺着注释去 Include/longintrepr.h 中，找到了实现 int 对象的结构体：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _longobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD        &#x2F;*可变长对象都具有的公共头部*&#x2F;</span><br><span class="line">    digit ob_digit[1];     &#x2F;*这里存储int的整数值*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在 Include/longintrepr.h 头文件，可以找到 <strong>digit</strong>
字段的定义：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if PYLONG_BITS_IN_DIGIT &#x3D;&#x3D; 30</span><br><span class="line">typedef uint32_t digit;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">#elif PYLONG_BITS_IN_DIGIT &#x3D;&#x3D; 15</span><br><span class="line">typedef unsigned short digit;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
由此可知<strong>digit 就是一个 C 语言整数</strong>，因此 <strong>int
对象是通过整数数组来实现大整数的</strong>。至于整数数组用什么整数类型来实现，
Python 提供了两个版本，一个是 <strong>32 位的 uint32_t ，一个是 16 位的
unsigned short</strong> ，编译 Python 解析器时可以
<strong>通过宏定义指定选用的版本</strong>。</p>
<p>Python 作者为什么要这样设计呢？这主要是
<strong>出于内存方面的考量：对于范围不大的整数，用 16
位整数表示即可</strong>，用 32 位就有点浪费。</p>
<p>整数对象| 对象大小（16位）| 对象大小（32位） -:-|-:-|-:- 1|24 + 2 * 1
= 26|24 + 4 * 1 = 28 1000000 |24 + 2 * 2 = 28|24 + 4 * 1 = 28
10000000000 |24 + 2 * 3 = 30|24 + 4 * 2 = 32</p>
<hr>
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/PyIntObject.jpg" class title="PyIntObject图">
</div>
<h5><span id="q-ob-digit-shu-zu-chang-du-ke-neng-da-yu-1-er-wei-shi-me-zai-jie-gou-ti-ding-yi-zhong-ob-digit-shu-zu-chang-du-que-gu-ding-wei-1">Q：ob_digit
数组长度可能大于1，而为什么在结构体定义中， ob_digit 数组长度却固定为
1？</span><a href="#q-ob-digit-shu-zu-chang-du-ke-neng-da-yu-1-er-wei-shi-me-zai-jie-gou-ti-ding-yi-zhong-ob-digit-shu-zu-chang-du-que-gu-ding-wei-1" class="header-anchor">#</a></h5>
<p>由于 C 语言中 <strong>数组长度不是类型信息</strong>，我们可以
<strong>根据实际需要为 ob_digit 数组分配足够的内存，并将其当成长度为 n
的数组</strong>操作。这也是 C 语言中一个常用的编程技巧。长度信息在
<strong>PyVarObject(PyVarObject比PyObjcet多了个ob_size字段，详细定义可以看<a href="http://liuw.tech/2020/10/11/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%AF%B9%E8%B1%A1/" title="[python源码分析] 1.对象">[python源码分析]
1.对象</a>)中的ob_size中</strong>。</p>
<h1><span id="shi-xian-da-zheng-shu">实现大整数</span><a href="#shi-xian-da-zheng-shu" class="header-anchor">#</a></h1>
<p>整数分为 <strong>正数 、 负数 和 零</strong> ， Python 规定不同整数在
int 对象中的存储方式，要点可以总结为 3 条：</p>
<p>整数 <strong>绝对值</strong> 根据实际情况分为若干部分，保存于
ob_digit 数组中； <strong>ob_digit 数组长度 保存于 ob_size
字段</strong>，对于 <strong>负整数 的情况，ob_size
为负</strong>（这里可以说就很精妙了）； 整数 <strong>零 以 ob_size 等于
0 来表示</strong>，<strong>ob_digit 数组为空</strong>； 接下来，我们以 5
个典型的例子详细介绍这几条规则：</p>
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/bigInt.jpg" class title="bigInt图">
</div>
<ol type="1">
<li>对于整数 0 ， ob_size 字段等于 0 ， ob_digit
数组为空，无需分配。</li>
<li>对于整数 10 ，其绝对值保存于 ob_digit 数组中，数组长度为 1 ，
ob_size 字段等于 1 。</li>
<li>对于整数 -10 ，其绝对值同样保存于 ob_digit 数组中，但由于 -10
为负数， <strong>ob_size 字段等于 -1</strong> 。</li>
<li>对于整数 1073741824 ( 2 的 30 次方)，由于 <strong>Python 只使用 32
整数的后 30 位</strong>，因此
<strong>需要另一个整数才能存储</strong>，整数数组长度为 2
。绝对值这样计算：<span class="math inline">\(2^{30}*1+2^0*0=10737418242\)</span></li>
<li>对于整数 -4294967297 (负的 2 的 32 次方加 1 )，同样要长度为 2 的
ob_digit 数组，但 ob_size 字段为负。绝对值这样计算：<span class="math inline">\(2^{30}*4+2^0*1=42949672972\)</span></li>
</ol>
<h3><span id="wei-shi-me-python-zhi-yong-ob-digit-shu-zu-zheng-shu-de-hou-30-wei">为什么 Python
只用 ob_digit 数组整数的后 30 位？</span><a href="#wei-shi-me-python-zhi-yong-ob-digit-shu-zu-zheng-shu-de-hou-30-wei" class="header-anchor">#</a></h3>
<p>这跟 <strong>加法进位有关</strong>。如果全部 32
位都用来保存绝对值，那么为了保证加法不溢出(产生进位)，需要先强制转换成
64 位类型后在进行计算。但 <strong>牺牲最高 1
位后，加法运算便不用担心进位溢出了</strong>。那么，为什么 Python
牺牲最高 2 位呢？应该是 <strong>为了和 16 位整数方案统一起来：如果选用
16 位整数作为数组， Python 则只使用其中 15 位</strong>。</p>
<h1><span id="xiao-zheng-shu-jing-tai-dui-xiang-chi">小整数静态对象池</span><a href="#xiao-zheng-shu-jing-tai-dui-xiang-chi" class="header-anchor">#</a></h1>
<p>小整数对象池在 Objects/longobject.c 中实现，关键代码如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*小整数池的范围通过宏来定义的, 默认是-5-257,我们可以通过修改此处的宏来调整小整数池的大小, 但是需要对python进行重新编译*&#x2F;</span><br><span class="line">#ifndef NSMALLPOSINTS</span><br><span class="line">#define NSMALLPOSINTS           257   &#x2F;*该宏规定了对象池 正数个数 (从 0 开始，包括 0 )，默认 257 个*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#ifndef NSMALLNEGINTS</span><br><span class="line">#define NSMALLNEGINTS           5     &#x2F;*该宏规定了对象池 负数个数 ，默认 5 个*&#x2F;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];  &#x2F;*一个整数对象数组，保存预先创建好的小整数对象*&#x2F;</span><br></pre></td></tr></table></figure></p>
<p>如果在[-5,
257)范围内，会直接返回存于small_ints的对象，所以小整数只会存在一个实例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; longobject.c</span><br><span class="line">static PyObject * </span><br><span class="line">get_small_int(sdigit ival)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    assert(-NSMALLNEGINTS &lt;&#x3D; ival &amp;&amp; ival &lt; NSMALLPOSINTS);</span><br><span class="line">    v &#x3D; (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">#ifdef COUNT_ALLOCS</span><br><span class="line">    if (ival &gt;&#x3D; 0)</span><br><span class="line">        quick_int_allocs++;</span><br><span class="line">    else</span><br><span class="line">        quick_neg_int_allocs++;</span><br><span class="line">#endif</span><br><span class="line">    return v;</span><br></pre></td></tr></table></figure></p>
<p>至于为什么选择静态缓存从 <strong>-5 到 256</strong>
之间的小整数，主要是出于某种 权衡 ：<strong>这个范围内的整数使用
频率很高 ，而缓存这些小整数的 内存开销相对可控</strong>
。很多程序开发场景都没有固定的正确答案，需要根据实际情况平衡利弊。</p>
<p>理解了静态对象池，如下现象就很好理解了：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 1 + 0</span><br><span class="line">&gt;&gt;&gt; b &#x3D; 1 * 1</span><br><span class="line">&gt;&gt;&gt; id(a), id(b)</span><br><span class="line">(4408209536, 4408209536)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c &#x3D; 1000 + 0</span><br><span class="line">&gt;&gt;&gt; d &#x3D; 1000 * 1</span><br><span class="line">&gt;&gt;&gt; id(c), id(d)</span><br><span class="line">(4410298224, 4410298160)</span><br></pre></td></tr></table></figure></p>
<p>由于整数对象是 <strong>不可变对象</strong>
，任何<strong>整数运算结果都以新对象返回</strong>，而<strong>对象创建销毁开销却不小</strong>。为了优化整数对象的性能，
Python 在启动时将使用 频率较高 的小整数预先创建好，这就是
<strong>小整数缓存池</strong> 。默认情况下，小整数缓存池缓存 <strong>从
-5 到 256 之间的整数</strong>。</p>
<h1><span id="shu-xue-yun-suan">数学运算</span><a href="#shu-xue-yun-suan" class="header-anchor">#</a></h1>
根据我们在 PyTypeObject 中学到的知识，对象的行为由对象的 类型
决定。因此，整数对象
<strong>数学运算的秘密藏在整数类型对象中</strong>。在
<strong>Objects/longobject.c</strong> 中找到整数类型对象( PyLong_Type
)，其定义如下所示：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyLong_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;int&quot;,                                      &#x2F;* tp_name *&#x2F;</span><br><span class="line">    offsetof(PyLongObject, ob_digit),           &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    sizeof(digit),                              &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_vectorcall_offset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_getattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_async *&#x2F;</span><br><span class="line">    long_to_decimal_string,                     &#x2F;* tp_repr *&#x2F;</span><br><span class="line">    &amp;long_as_number,                            &#x2F;* tp_as_number *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc)long_hash,                        &#x2F;* tp_hash *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_call *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_str *&#x2F;</span><br><span class="line">    PyObject_GenericGetAttr,                    &#x2F;* tp_getattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_buffer *&#x2F;</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               &#x2F;* tp_flags *&#x2F;</span><br><span class="line">    long_doc,                                   &#x2F;* tp_doc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_traverse *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_clear *&#x2F;</span><br><span class="line">    long_richcompare,                           &#x2F;* tp_richcompare *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_weaklistoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iter *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iternext *&#x2F;</span><br><span class="line">    long_methods,                               &#x2F;* tp_methods *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_members *&#x2F;</span><br><span class="line">    long_getset,                                &#x2F;* tp_getset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_base *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dict *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_get *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_set *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dictoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_init *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_alloc *&#x2F;</span><br><span class="line">    long_new,                                   &#x2F;* tp_new *&#x2F;</span><br><span class="line">    PyObject_Del,                               &#x2F;* tp_free *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
类型对象中， <strong>tp_as_number 是一个关键字段。该字段指向一个
PyNumberMethods 结构体</strong>，结构体保存了 <strong>各种数学运算的
函数指针 </strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyNumberMethods long_as_number &#x3D; &#123;</span><br><span class="line">    (binaryfunc)long_add,       &#x2F;*nb_add*&#x2F;</span><br><span class="line">    (binaryfunc)long_sub,       &#x2F;*nb_subtract*&#x2F;</span><br><span class="line">    (binaryfunc)long_mul,       &#x2F;*nb_multiply*&#x2F;</span><br><span class="line">    long_mod,                   &#x2F;*nb_remainder*&#x2F;</span><br><span class="line">    long_divmod,                &#x2F;*nb_divmod*&#x2F;</span><br><span class="line">    long_pow,                   &#x2F;*nb_power*&#x2F;</span><br><span class="line">    (unaryfunc)long_neg,        &#x2F;*nb_negative*&#x2F;</span><br><span class="line">    (unaryfunc)long_long,       &#x2F;*tp_positive*&#x2F;</span><br><span class="line">    (unaryfunc)long_abs,        &#x2F;*tp_absolute*&#x2F;</span><br><span class="line">    (inquiry)long_bool,         &#x2F;*tp_bool*&#x2F;</span><br><span class="line">    (unaryfunc)long_invert,     &#x2F;*nb_invert*&#x2F;</span><br><span class="line">    long_lshift,                &#x2F;*nb_lshift*&#x2F;</span><br><span class="line">    (binaryfunc)long_rshift,    &#x2F;*nb_rshift*&#x2F;</span><br><span class="line">    long_and,                   &#x2F;*nb_and*&#x2F;</span><br><span class="line">    long_xor,                   &#x2F;*nb_xor*&#x2F;</span><br><span class="line">    long_or,                    &#x2F;*nb_or*&#x2F;</span><br><span class="line">    long_long,                  &#x2F;*nb_int*&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
下图展示了 <strong>整数对象 、 整数类型对象 以及
整数数学运算处理函数</strong> 之间的关系：
<div style="width:100%;margin:auto">
<img src="/2020/11/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%B4%E6%95%B0int/IntOp.jpg" class title="IntOp图">
</div>
<h3><span id="jia-fa">加法</span><a href="#jia-fa" class="header-anchor">#</a></h3>
<p>如何为一个由数组表示的大整数实现加法？问题答案得在 long_add
函数中找，该函数是整数对象 加法处理函数 。我们再接再厉，扒开 long_add
函数看个究竟(同样位于 Objects/longobject.c )：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">long_add(PyLongObject *a, PyLongObject *b)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;*定义变量 z 用于临时保存计算结果*&#x2F;</span><br><span class="line">    PyLongObject *z;  </span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    如果参与运算的整数对象底层数组长度均不超过 1 ，直接用 MEDIUM_VALUE 宏将整数对象转化成 C 整数类型进行运算，</span><br><span class="line">    性能损耗极小。满足这个条件的整数范围在 -1073741823~1073741823 之间，足以覆盖程序运行时的绝大部分运算场景</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (Py_ABS(Py_SIZE(a)) &lt;&#x3D; 1 &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;&#x3D; 1) &#123;</span><br><span class="line">        return PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    if (Py_SIZE(a) &lt; 0) &#123;</span><br><span class="line">        if (Py_SIZE(b) &lt; 0) &#123;</span><br><span class="line">          &#x2F;*如果两个整数均为 负数 ，调用 x_add 计算两者绝对值之和，再将结果符号设置为负( 16 行处)*&#x2F;</span><br><span class="line">            z &#x3D; x_add(a, b);</span><br><span class="line">            if (z !&#x3D; NULL) &#123;</span><br><span class="line">                assert(Py_REFCNT(z) &#x3D;&#x3D; 1);</span><br><span class="line">                Py_SIZE(z) &#x3D; -(Py_SIZE(z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;*如果 a 为负数， b 为正数，调用 x_sub 计算 b 和 a 的绝对值之差即为最终结果*&#x2F;</span><br><span class="line">        else</span><br><span class="line">            z &#x3D; x_sub(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (Py_SIZE(b) &lt; 0)</span><br><span class="line">            z &#x3D; x_sub(a, b);</span><br><span class="line">        else</span><br><span class="line">        &#x2F;*如果两个整数均为正数，调用 x_add 计算两个绝对值之和即为最终结果*&#x2F;</span><br><span class="line">            z &#x3D; x_add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    return (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### x_add x_add 用于计算两个整数对象绝对值之和，源码同样位于
Objects/longobject.c ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyLongObject *</span><br><span class="line">x_add(PyLongObject *a, PyLongObject *b)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;*取ob_size的绝对值*&#x2F;</span><br><span class="line">    Py_ssize_t size_a &#x3D; Py_ABS(Py_SIZE(a)), size_b &#x3D; Py_ABS(Py_SIZE(b));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*用变量z 临时存储计算结果*&#x2F;</span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    &#x2F;*临时进位*&#x2F;</span><br><span class="line">    digit carry &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ensure a is the larger of the two: *&#x2F;</span><br><span class="line">    if (size_a &lt; size_b) &#123;</span><br><span class="line">     &#x2F;*如果 a 数组长度比较小，将 a 、 b 交换，数组长度较大的那个在前面*&#x2F;</span><br><span class="line">        &#123; PyLongObject *temp &#x3D; a; a &#x3D; b; b &#x3D; temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp &#x3D; size_a;</span><br><span class="line">            size_a &#x3D; size_b;</span><br><span class="line">            size_b &#x3D; size_temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*创建新整数对象，用于保存计算结果（注意到长度必须比 a 和 b 都大一，因为可能有进位）*&#x2F;</span><br><span class="line">    z &#x3D; _PyLong_New(size_a+1);</span><br><span class="line"></span><br><span class="line">    if (z &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    &#x2F;*遍历 b 底层数组，与 a 对应部分相加并保存到 z 中，需要特别注意进位计算*&#x2F;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; ++i) &#123;</span><br><span class="line">        carry +&#x3D; a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] &#x3D; carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;&#x3D; PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*遍历 a 底层数组剩余部分，与进位相加后保存到 z 中，同样需要特别注意进位计算*&#x2F;</span><br><span class="line">    for (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        carry +&#x3D; a-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] &#x3D; carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;&#x3D; PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*将进位写入 z 底层数组最高位单元中*&#x2F;</span><br><span class="line">    z-&gt;ob_digit[i] &#x3D; carry;</span><br><span class="line">    &#x2F;*去除计算结果 z 底层数组中前面多余的零，因为最后的进位可能为零*&#x2F;</span><br><span class="line">    return long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<ol type="1">
<li><a href="https://www.imooc.com/read/76/article/1903" title="Python 源码深度剖析/07 int 对象，永不溢出的整数">Python
源码深度剖析/07 int 对象，永不溢出的整数</a></li>
<li><a href="https://www.imooc.com/read/76/article/1904" title="Python 源码深度剖析/08 int 源码解析：如何实现大整数运算？">Python
源码深度剖析/08 int 源码解析：如何实现大整数运算？</a></li>
<li><a href="https://blog.csdn.net/weixin_34174132/article/details/89699621?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" title="Python3源码—整数对象">Python3源码—整数对象</a></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 5.bytes</title>
    <url>/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/</url>
    <content><![CDATA[<p>由于一个字节8bit最多只能表示 <strong>256
种字符</strong>，用来表示英文字符绰绰有余，想覆盖非英文字符便捉襟见肘了。为了表示众多的非英文字符(比如汉字)，计算机先驱们发明了
<strong>多字节编码</strong> ——通过
<strong>多个字节来表示一个字符</strong>。由于
<strong>原始字节序列不维护编码信息</strong>，操作不慎便导致各种乱码现象。</p>
<p>Python 提供的解决方案是 <strong>Unicode 字符串 ( str )对象</strong>，
Unicode
可以表示各种字符，无需关心编码。然而存储或者网络通讯时，字符串对象不可避免要
<strong>序列化 成字节序列</strong>。为此， Python 额外提供了
<strong>字节序列对象—— bytes</strong> 。</p>
<div style="width:100%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/str_and_bytes.jpg" class title="str_and_bytes图">
</div>
<p>如上图， str 对象统一表示一个 <strong>字符串</strong>
，不需要关心编码；计算机通过 <strong>字节序列
与存储介质和网络介质打交道</strong>，字节序列由 <strong>bytes
对象</strong>表示；存储或传输 str 对象时，需要将其
<strong>序列化</strong> 成字节序列，序列化过程也是 <strong>编码</strong>
的过程。</p>
<h2><span id="dui-xiang-jie-gou">对象结构</span><a href="#dui-xiang-jie-gou" class="header-anchor">#</a></h2>
<p>bytes 对象用于表示由若干字节组成的 字节序列 以及相关的 操作
，并不关心字节序列的 含义 。因此， bytes 应该一种 <strong>变长 、
不可变</strong> 对象 ，内部由 <strong>C 数组</strong> 实现。如下图:</p>
<div style="width:100%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/bytes_head.png" class title="bytes_head图">
</div>
<ol type="1">
<li><p>ob_sval 字节序列对象 PyBytesObject 中，确实藏着一个字符数组
ob_sval 。注意到 <strong>ob_sval 数组长度定义为 1</strong> ，这是 C
语言中定义 <strong>变长数组</strong>
的技巧（ob_sval存储的是地址）。</p></li>
<li><p>ob_snash <strong>ob_shash</strong> ，它用于保存字节序列的 哈希值
。 由于计算 <strong>bytes
对象哈希值需要遍历其内部的字符数组</strong>，开销相对较大。因此， Python
<strong>第一次计算</strong> 哈希值时，选择 将哈希值缓存到
<strong>ob_shash字段</strong>中，以
<strong>空间换时间</strong>，避免重复计算。</p></li>
<li><p>ob_size 每个PyVarObject内部都有个
<strong>ob_size</strong>字段，PyBytesObject使用此字段存储大小信息以
<strong>保持len（）操作的O（1）时间复杂度</strong>，并跟踪非ascii字符串的大小（内部可以为空字符）</p></li>
</ol>
<h3><span id="kong-dui-xiang-yang-li">空对象样例</span><a href="#kong-dui-xiang-yang-li" class="header-anchor">#</a></h3>
<div style="width:100%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/bytes_empty.png" class title="bytes_empty图">
</div>
<p>Python 为待存储的字节序列 <strong>额外分配一个字节，用于在末尾处保存
\0 ，以便兼容 C 字符串</strong>。从上图可以看出，就算空 bytes 对象( b''
)也是要占用内存空间的，至少变长对象 公共头部 是少不了的。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sys.getsizeof(b&#39;&#39;)</span><br><span class="line">33</span><br></pre></td></tr></table></figure></p>
<p>bytes 对象占用的内存空间可分为以下个部分进行计算：</p>
<ul>
<li>PyVarObject公共头部 24 字节，ob_refcnt 、 ob_type 、 ob_size
每个字段各占用 8 字节；</li>
<li>哈希值 ob_shash 占用 8 字节；</li>
<li>字节序列本身，假设是 n 字节；</li>
<li>额外 1 字节用于存储末尾处的 \0 ；</li>
</ul>
<p>因此，bytes 对象空间计算公式为 24+8+n+124+8+n+1，即 33+n33+n，其中 n
为字节序列长度(也是len的取值)。 经过上面的学习，我们可以知道
<strong>len(byte对象) = n</strong>，len显示的只是
<strong>ob_size字段</strong>的值，而bytes对象真实占用内存量还
<strong>需要加 33</strong>.</p>
<h3><span id="ascii-yang-li">ascii样例</span><a href="#ascii-yang-li" class="header-anchor">#</a></h3>
<div style="width:100%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-bytes/bytes_ascii.png" class title="bytes_ascii图">
</div>
<h2><span id="dui-xiang-xing-wei">对象行为</span><a href="#dui-xiang-xing-wei" class="header-anchor">#</a></h2>
<p>对象的行为由对象的 <strong>类型</strong> 决定，因而我们需要到 bytes
类型对象(PyBytes_Type)中寻找答案。在
<strong>Objects/bytesobject.c</strong> 源码文件中，我们找到 bytes
类型对象 的定义：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyBytes_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;bytes&quot;,</span><br><span class="line">    PyBytesObject_SIZE,</span><br><span class="line">    sizeof(char),</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &amp;bytes_as_number,                           &#x2F;* tp_as_number 保存着 数值运算 处理函数的指针*&#x2F;</span><br><span class="line">    &amp;bytes_as_sequence,                         &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    &amp;bytes_as_mapping,                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc)bytes_hash,                       &#x2F;* tp_hash *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
bytes 对象居然支持数据操作？bytes_as_number 结构体中只定义了一个操作——
模运算 ( % )：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyNumberMethods bytes_as_number &#x3D; &#123;</span><br><span class="line">    0,              &#x2F;*nb_add*&#x2F;</span><br><span class="line">    0,              &#x2F;*nb_subtract*&#x2F;</span><br><span class="line">    0,              &#x2F;*nb_multiply*&#x2F;</span><br><span class="line">    bytes_mod,      &#x2F;*nb_remainder*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">static PyObject *</span><br><span class="line">bytes_mod(PyObject *self, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    if (!PyBytes_Check(self)) &#123;</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;实现字符串格式化</span><br><span class="line">    return _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),</span><br><span class="line">                             arg, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由此可见， bytes 对象只是 <strong>借用 %
运算符实现字符串格式化</strong>，谈不上支持数值运算，虚惊一场：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;msg: a&#x3D;%d b&#x3D;%d&#39; % (1, 2)</span><br><span class="line">b&#39;msg: a&#x3D;1 b&#x3D;2&#39;</span><br></pre></td></tr></table></figure></p>
<h2><span id="xu-lie-xing-cao-zuo">序列型操作</span><a href="#xu-lie-xing-cao-zuo" class="header-anchor">#</a></h2>
<p>众所周知， <strong>bytes 是 序列型对象</strong>
，序列型操作才是研究重点。我们在 bytes_as_sequence
结构体中找到相关定义：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PySequenceMethods bytes_as_sequence &#x3D; &#123;</span><br><span class="line">    (lenfunc)bytes_length, &#x2F;*sq_length*&#x2F;</span><br><span class="line">    (binaryfunc)bytes_concat, &#x2F;*sq_concat*&#x2F;</span><br><span class="line">    (ssizeargfunc)bytes_repeat, &#x2F;*sq_repeat*&#x2F;</span><br><span class="line">    (ssizeargfunc)bytes_item, &#x2F;*sq_item*&#x2F;</span><br><span class="line">    0,                  &#x2F;*sq_slice*&#x2F;</span><br><span class="line">    0,                  &#x2F;*sq_ass_item*&#x2F;</span><br><span class="line">    0,                  &#x2F;*sq_ass_slice*&#x2F;</span><br><span class="line">    (objobjproc)bytes_contains &#x2F;*sq_contains*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
由此可见， bytes 支持的 序列型操作 包括以下 5 个： - sq_length
，查询序列长度； - sq_concat ，将两个序列合并为一个； - sq_repeat
，将序列重复多次； - sq_item ，取出给定下标序列元素； -
sq_contains，包含关系判断；</p>
<h3><span id="chang-du">长度</span><a href="#chang-du" class="header-anchor">#</a></h3>
<p>最简单的序列型操作是 长度查询 ，直接返回 ob_size 字段即可：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Py_ssize_t</span><br><span class="line">bytes_length(PyBytesObject *a)</span><br><span class="line">&#123;</span><br><span class="line">    return Py_SIZE(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="he-bing">合并</span><a href="#he-bing" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;abc&#39; + b&#39;cba&#39;</span><br><span class="line">b&#39;abccba&#39;</span><br></pre></td></tr></table></figure>
<p>合并操作将两个 bytes 对象拼接成一个，由 bytes_concat 函数处理：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">bytes_concat(PyObject *a, PyObject *b)</span><br><span class="line">&#123;</span><br><span class="line">    Py_buffer va, vb;   &#x2F;&#x2F;定义局部变量 va 、 vb 用于维护缓冲区</span><br><span class="line">    PyObject *result &#x3D; NULL;  &#x2F;&#x2F;新建临时变量，保存合并结果</span><br><span class="line"></span><br><span class="line">    va.len &#x3D; -1;</span><br><span class="line">    vb.len &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F;获取字节序列所在缓冲区</span><br><span class="line">    if (PyObject_GetBuffer(a, &amp;va, PyBUF_SIMPLE) !&#x3D; 0 ||</span><br><span class="line">        PyObject_GetBuffer(b, &amp;vb, PyBUF_SIMPLE) !&#x3D; 0) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError, &quot;can&#39;t concat %.100s to %.100s&quot;,</span><br><span class="line">                     Py_TYPE(b)-&gt;tp_name, Py_TYPE(a)-&gt;tp_name);</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Optimize end cases *&#x2F;</span><br><span class="line">    if (va.len &#x3D;&#x3D; 0 &amp;&amp; PyBytes_CheckExact(b)) &#123;  &#x2F;&#x2F;如果第一个对象长度为 0 ，第二个对象就是结果</span><br><span class="line">        result &#x3D; b;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line">    if (vb.len &#x3D;&#x3D; 0 &amp;&amp; PyBytes_CheckExact(a)) &#123;    &#x2F;&#x2F;第二个对象长度为 0 ，第一个对象就是结果</span><br><span class="line">        result &#x3D; a;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (va.len &gt; PY_SSIZE_T_MAX - vb.len) &#123;   &#x2F;&#x2F;长度超过限制则报错</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result &#x3D; PyBytes_FromStringAndSize(NULL, va.len + vb.len);  &#x2F;&#x2F;临时 bytes 对象用于保存合并结果，长度为待合并对象长度之和</span><br><span class="line">    if (result !&#x3D; NULL) &#123;</span><br><span class="line">        memcpy(PyBytes_AS_STRING(result), va.buf, va.len);</span><br><span class="line">        memcpy(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    if (va.len !&#x3D; -1)</span><br><span class="line">        PyBuffer_Release(&amp;va);</span><br><span class="line">    if (vb.len !&#x3D; -1)</span><br><span class="line">        PyBuffer_Release(&amp;vb);</span><br><span class="line">    return result;  &#x2F;&#x2F;返回结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
bytes_concat 函数逻辑很直白，<strong>将两个 bytes
对象的缓冲区</strong>拷贝到一起形成新 bytes 对象。</p>
<h3><span id="shu-ju-kao-bei-de-xian-jing">数据拷贝的陷阱</span><a href="#shu-ju-kao-bei-de-xian-jing" class="header-anchor">#</a></h3>
<p>考察以下表达式——合并 3 个 bytes 对象：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; result &#x3D; a + b + c</span><br></pre></td></tr></table></figure>
这个语句执行时，分成两步进行合并：先将 a 和 b 合并，得到临时结果 t
，再将 t 和 c 合并得到最终结果 result ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; a + b</span><br><span class="line">&gt;&gt;&gt; result &#x3D; t + c</span><br></pre></td></tr></table></figure>
这个过程中，<strong>a 和 b 的数据需要被拷贝两遍</strong>！</p>
<div style="width:100%;margin:auto">

</div>
<p>合并 <strong>n 个 bytes 对象，头两个对象需要拷贝 n-1</strong>
次，只有最后一个对象不需要重复拷贝。平均下来，每个对象大约要拷贝
<strong>n/2</strong> 次！</p>
<h3><span id="nei-jian-fang-fa-join">内建方法 join</span><a href="#nei-jian-fang-fa-join" class="header-anchor">#</a></h3>
bytes 对象提供了一个内建方法 join ，可高效合并多个 bytes 对象：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; result &#x3D; b&#39;&#39;.join(segments)</span><br></pre></td></tr></table></figure>
join
方法对数据拷贝进行了优化：<strong>先遍历待合并对象</strong>，<strong>计算总长度</strong>；然后根据总长度
<strong>创建目标对象</strong>；最后再
<strong>遍历待合并对象</strong>，逐一拷贝数据。这样一来，每个对象均只需拷贝一次，解决了重复拷贝的陷阱。
<div style="width:100%;margin:auto">

</div>
<h2><span id="zi-fu-huan-chong-chi">字符缓冲池</span><a href="#zi-fu-huan-chong-chi" class="header-anchor">#</a></h2>
<p>为了优化单字节 <strong>bytes</strong> 对象(也可称为 字符对象
)的创建效率， Python 内部维护了一个 字符缓冲池 ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyBytesObject *characters[UCHAR_MAX + 1];</span><br></pre></td></tr></table></figure>
Python 内部 <strong>创建单字节 bytes</strong>
对象时，先检查目标对象是否已在缓冲池中。PyBytes_FromStringAndSize
函数是负责创建 bytes 对象的通用接口，同样位于
<strong>Objects/bytesobject.c</strong> 中：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    if (size &lt; 0) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">            &quot;Negative size passed to PyBytes_FromStringAndSize&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果目标对象为 单字节对象 且 已在字符缓冲池 中，直接返回已缓存对象</span><br><span class="line">    if (size &#x3D;&#x3D; 1 &amp;&amp; str !&#x3D; NULL &amp;&amp;</span><br><span class="line">        (op &#x3D; characters[*str &amp; UCHAR_MAX]) !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">#ifdef COUNT_ALLOCS</span><br><span class="line">        one_strings++;</span><br><span class="line">#endif</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        return (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建新 bytes 对象并拷贝字节序列</span><br><span class="line">    op &#x3D; (PyBytesObject *)_PyBytes_FromSize(size, 0);</span><br><span class="line">    if (op &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    if (str &#x3D;&#x3D; NULL)</span><br><span class="line">        return (PyObject *) op;</span><br><span class="line"></span><br><span class="line">    memcpy(op-&gt;ob_sval, str, size);</span><br><span class="line">    &#x2F;* share short strings *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果创建的对象为单字节对象，将其放入字符缓冲池</span><br><span class="line">    if (size &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] &#x3D; op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由此可见，当 Python 程序
<strong>开始运行时</strong>，<strong>字符缓冲池是空的</strong>。随着
<strong>单字节 bytes
对象</strong>的创建，缓冲池中的对象慢慢多了起来。</p>
<p>字符对象
<strong>首次创建后便在缓冲池中缓存起来</strong>；后续再次使用时，
<strong>Python 直接从缓冲池中取</strong>，避免重复创建和销毁。与 小整数
一样，字符对象 <strong>只有为数不多的 256
个</strong>，但使用频率非常高。缓冲池技术作为一种
<strong>以空间换时间</strong> 的优化手段，只需
<strong>较小的内存为代价</strong>，便可明显提升执行效率。</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://www.imooc.com/read/76/article/1905" title="Python 源码深度剖析/09 bytes 对象，不可变的字节序列">Python
源码深度剖析/09 bytes 对象，不可变的字节序列</a></li>
<li><a href="https://github.com/zpoint/CPython-Internals/blob/master/BasicObject/bytes/bytes.md" title="bytes">bytes</a></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 6.python3中的字符串str/Unicode</title>
    <url>/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-6-%E5%AD%97%E7%AC%A6%E4%B8%B2str/</url>
    <content><![CDATA[<h2><span id="unicode-shi-shi-me">Unicode是什么</span><a href="#unicode-shi-shi-me" class="header-anchor">#</a></h2>
<p>计算机存储的基本单位是 <strong>八位字节</strong> ，由 8
个比特位组成，简称 字节 。由于英文只由 26
个字母加若干符号组成，因此英文字符可以直接用 字节 来保存。其他诸如
<strong>中日韩等语言</strong>，由于字符众多，则不得不用多个字节来编码。
<a id="more"></a>
随着计算机技术的传播，非拉丁文字符编码技术蓬勃发展，但存在两个比较大的局限性：</p>
<ul>
<li>不支持多语言 ，例如中文的编码方案不能表示日文；</li>
<li>没有统一标准 ，例如中文有 <strong>GB2312 ，GBK 、 GB18030</strong>
等多种编码标准；
由于编码方式不统一，开发人员经常需要在不同编码间来回转化，错误频出。为了彻底解决这些问题，
统一码联盟 提出了 <strong>Unicode</strong> 标准。Unicode
<strong>对世界上大部分文字系统进行整理、编码</strong>，让计算机可以用统一的方式处理文本。Unicode
目前已经收录了超过 <strong>13 万</strong>个字符，天然地支持多语言。</li>
</ul>
<h2><span id="python-zhong-de-zi-fu-chuan-unicode">Python中的字符串Unicode</span><a href="#python-zhong-de-zi-fu-chuan-unicode" class="header-anchor">#</a></h2>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th>version</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>python2.7</td>
<td>str等同于char指针, unicode默认用assic编码</td>
</tr>
<tr>
<td>python3+</td>
<td>str等同于unicode, 使用PyASCIIObject或PyCompactUnicodeObject实现</td>
</tr>
</tbody>
</table>
<p>在 Python 中处理文本数据是使用 str 对象，也称为 字符串。Python 在 3
之后，str 字符串是由 <strong>Unicode</strong>
码位构成的<strong>不可变序列</strong>，因而被源码称为 <strong>Unicode
对象</strong>。这么做好处是显然易见的，程序核心逻辑统一用 Unicode
，只需在输入、输入层进行编码、解码。</p>
<p>字符串字面值有多种不同的写法：</p>
<ul>
<li><p>单引号: '允许包含有 "双" 引号'</p></li>
<li><p>双引号: "允许包含有 '单' 引号"。</p></li>
<li><p>三重引号: '''三重单引号''', """三重双引号"""</p></li>
</ul>
<p>使用三重引号的字符串可以<strong>跨越多行</strong> ——
其中<strong>所有的空白字符都将包含在该字符串字面值</strong>中。</p>
<p>由于 Unicode 收录字符已经超过 13 万个，每个字符 <strong>至少需要 4
个字节</strong>来保存。英文字符用 ASCII 表示仅需 1 个字节，而用 Unicode
表示内存开销却增加 <strong>4</strong> 倍！</p>
<p>Python 作者们肯定不允许这样的事情发生( getsizeof 获取对象内存大小)：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line"># 英文字符还是1字节</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(&#39;ab&#39;) - sys.getsizeof(&#39;a&#39;)</span><br><span class="line">1</span><br><span class="line"># 中文字符需要2字节</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(&#39;中国&#39;) - sys.getsizeof(&#39;中&#39;)</span><br><span class="line">2</span><br><span class="line"># Emoji表情需要4字节</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(&#39;??&#39;) - sys.getsizeof(&#39;?&#39;)</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p>由此可见，Python 内部对 Unicode 进行优化：根据文本内容，选择
<strong>底层存储单元</strong>。与 str 对象实现相关源码如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Include&#x2F;unicodeobject.h</span><br><span class="line">Objects&#x2F;unicodectype.c</span><br></pre></td></tr></table></figure>
在 Include/unicodeobject.h 头文件中，我们发现 str
对象底层存储根据文本字符 Unicode 码位范围分成几类：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyUnicode_1BYTE_KIND ，所有字符码位均在 U+0000 到 U+00FF 之间；</span><br><span class="line">PyUnicode_2BYTE_KIND ，所有字符码位均在 U+0000 到 U+FFFF 之间，且至少一个大于 U+00FF；</span><br><span class="line">PyUnicode_4BYTE_KIND ，所有字符码位均在 U+0000 到 U+10FFFF 之间，且至少一个大于 U+FFFF；</span><br><span class="line">enum PyUnicode_Kind &#123;</span><br><span class="line">&#x2F;* String contains only wstr byte characters.  This is only possible</span><br><span class="line">   when the string was created with a legacy API and _PyUnicode_Ready()</span><br><span class="line">   has not been called yet.  *&#x2F;</span><br><span class="line">    PyUnicode_WCHAR_KIND &#x3D; 0,</span><br><span class="line">&#x2F;* Return values of the PyUnicode_KIND() macro: *&#x2F;</span><br><span class="line">    PyUnicode_1BYTE_KIND &#x3D; 1,</span><br><span class="line">    PyUnicode_2BYTE_KIND &#x3D; 2,</span><br><span class="line">    PyUnicode_4BYTE_KIND &#x3D; 4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这样一来，根据 <strong>文本码位范围</strong>，便可为字符选用
<strong>尽量小的</strong> 存储单元，以最大限度节约内存。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef uint32_t Py_UCS4;</span><br><span class="line">typedef uint16_t Py_UCS2;</span><br><span class="line">typedef uint8_t Py_UCS1;</span><br></pre></td></tr></table></figure></p>
<p>Unicode 内部存储结构因文本类型而异，因此类型 <strong>kind</strong>
必须作为 <strong>Unicode</strong> 对象公共字段保存。Python
内部定义了若干个 <strong>标志位</strong> ，作为 Unicode 公共字段，kind
便是其中之一：</p>
<ul>
<li>interned ，是否为 <strong>interned</strong> 机制维护， internel
机制在本节后半部分介绍；</li>
<li>kind ，类型，用于区分字符 <strong>底层存储单元大小</strong>；</li>
<li>compact
，内存分配方式，<strong>对象与文本缓冲区是否分离</strong>；</li>
<li>ascii ，文本是否均为 <strong>纯 ASCII</strong> ；</li>
</ul>
<p>Objects/unicodectype.c 源文件中的 PyUnicode_New 函数，根据文本字符数
size 以及最大字符 maxchar 初始化 Unicode 对象。该函数根据 maxchar 为
Unicode 对象选择最紧凑的字符存储单元以及底层结构体：</p>
<div class="line-block">  |maxchar &lt; 128| maxchar &lt; 256| maxchar
&lt; 65536|maxchar &lt; MAX_UNICODE</div>
<p>|-:-|-:-|-:-|-:-|-:-
kind|PyUnicode_1BYTE_KIND|PyUnicode_1BYTE_KIND|PyUnicode_2BYTE_KIND|PyUnicode_4BYTE_KIND
ascii |1 |0 |0 |0 字符存储单元大小 |1 |1 |2 |4 底层结构体 |PyASCIIObject
|PyCompactUnicodeObject |PyCompactUnicodeObject
|PyCompactUnicodeObject</p>
<h2><span id="pyasciiobject">PyASCIIObject</span><a href="#pyasciiobject" class="header-anchor">#</a></h2>
<p>如果 str 对象保存的文本均为 ASCII ，即
maxchar&lt;128maxchar&lt;128，则底层由 <strong>PyASCIIObject</strong>
结构存储：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* ASCII-only strings created through PyUnicode_New use the PyASCIIObject</span><br><span class="line">   structure. state.ascii and state.compact are set, and the data</span><br><span class="line">   immediately follow the structure. utf8_length and wstr_length can be found</span><br><span class="line">   in the length field; the utf8 pointer is equal to the data pointer. *&#x2F;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t length;          &#x2F;* Number of code points in the string 文本长度*&#x2F;</span><br><span class="line">    Py_hash_t hash;             &#x2F;* Hash value; -1 if not set  文本哈希值*&#x2F;</span><br><span class="line">    struct &#123;</span><br><span class="line">        unsigned int interned:2;</span><br><span class="line">        unsigned int kind:3;</span><br><span class="line">        unsigned int compact:1;</span><br><span class="line">        unsigned int ascii:1;</span><br><span class="line">        unsigned int ready:1;</span><br><span class="line">        unsigned int :24;</span><br><span class="line">    &#125; state;                      &#x2F;*Unicode 对象标志位，包括 internel 、 kind 、 ascii 、 compact 等*&#x2F;</span><br><span class="line">    wchar_t *wstr;              &#x2F;* wchar_t representation (null-terminated) *&#x2F;</span><br><span class="line">&#125; PyASCIIObject;</span><br></pre></td></tr></table></figure></p>
<p>ASCII 文本则紧接着位于 PyASCIIObject 结构体后面，以字符串对象 ‘abc’
以及空字符串对象 ‘’ 为例：</p>
<div style="width:80%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-6-%E5%AD%97%E7%AC%A6%E4%B8%B2str/PyASCIIObject_sample.jpg" class title="PyASCIIObject_sample图">
</div>
<h3><span id="state-zi-duan-hou-you-yi-ge-4-zi-jie-de-kong-dong">state 字段后有一个 4
字节的空洞?</span><a href="#state-zi-duan-hou-you-yi-ge-4-zi-jie-de-kong-dong" class="header-anchor">#</a></h3>
<p>这是结构体字段 <strong>内存对齐</strong> 造成的现象。在 64
位机器下，指针大小为 <strong>8</strong> 字节，为优化内存访问效率，wstr
必须 <strong>以 8 字节对齐</strong>；而 <strong>state 字段大小只是 4
字节</strong>，便留下 4 字节的空洞。PyASCIIObject 结构体大小在 64
位机器下为 48 字节，在 32 位机器下为 24 字节。</p>
<p>与 bytes 对象一样，Python 也在 ASCII 文本末尾，额外添加一个
<strong>\0</strong> 字符，以兼容 C 字符串。</p>
<p>如此一来，以 Unicode 表示的 <strong>ASCII</strong>
文本，额外内存开销仅为 <strong>PyASCIIObject</strong> 结构体加上末尾的
\0 字节而已。PyASCIIObject 结构体在 64 位机器下，<strong>大小为 48
字节</strong>。因此，长度为 n 的纯 ASCII 字符串对象，需要消耗 n+48+1，即
<strong>n+49</strong> 字节的内存空间。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sys.getsizeof(&#39;&#39;)</span><br><span class="line">49</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(&#39;abcdef&#39;)</span><br><span class="line">55</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(&#39;1&#39; * 10000)</span><br><span class="line">10049</span><br></pre></td></tr></table></figure></p>
<h2><span id="pycompactunicodeobject">PyCompactUnicodeObject</span><a href="#pycompactunicodeobject" class="header-anchor">#</a></h2>
<p>PyCompactUnicodeObject 在 PyASCIIObject 基础上，增加 3 个字段：</p>
<ul>
<li>utf8_length : 文本 UTF8 编码长度；</li>
<li>utf8 : 文本 UTF8
编码形式，<strong>缓存以避免重复编码运算</strong>；</li>
<li>wstr_length；</li>
</ul>
<p>在 64 位机器，PyCompactUnicodeObject 结构体大小为 <strong>72</strong>
字节；在 32 位机器则是 <strong>36</strong> 字节。</p>
PyCompactUnicodeObject结构如下图:
<div style="width:80%;margin:auto">

</div>
<p>由于 <strong>ASCII</strong> 本身是 <strong>合法的 UTF8</strong>
，无须保存 UTF8 编码形式，这也是 ASCII 文本底层由 PyASCIIObject
保存的原因。在 64 位机器，PyCompactUnicodeObject 结构体大小为 72
字节；在 32 位机器则是 36 字节。</p>
<h3><span id="kong-zi-fu-chuan">空字符串</span><a href="#kong-zi-fu-chuan" class="header-anchor">#</a></h3>
<div style="width:80%;margin:auto">

</div>
<h3><span id="interned-ji-zhi">interned机制</span><a href="#interned-ji-zhi" class="header-anchor">#</a></h3>
<p>如果 str 对象 <strong>interned</strong> 标识位为 1 ，Python
虚拟机将为其开启 interned 机制。那么，什么是 interned 机制？</p>
<p>先考虑以下场景，如果程序中有大量 User 对象，有什么可优化的地方？
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class User:</span><br><span class="line">...</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name &#x3D; name</span><br><span class="line">...         self.age &#x3D; age</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; user &#x3D; User(name&#x3D;&#39;tom&#39;, age&#x3D;20)</span><br><span class="line">&gt;&gt;&gt; user.__dict__</span><br><span class="line">&#123;&#39;name&#39;: &#39;tom&#39;, &#39;age&#39;: 20&#125;</span><br></pre></td></tr></table></figure>
由于 <strong>对象的属性由 dict</strong> 保存，这意味着每个 User
对象都需要保存 str 对象 name 。换句话讲，1 亿个 User 对象需要重复保存 1
亿个同样的 str 对象，这将浪费多少内存！</p>
<p>由于 <strong>str 是不可变对象</strong>，因此 Python
内部将有潜在重复可能的字符串都做成 <strong>单例模式</strong> ，这就是
interned 机制。Python 具体做法是 <strong>在内部维护一个全局 dict
对象</strong>，所有开启 <strong>interned 机制 str 对象</strong>
均保存在这里；后续需要用到相关对象的地方，则 <strong>优先到全局 dict
中取</strong>，避免重复创建。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *interned &#x3D; NULL;</span><br></pre></td></tr></table></figure></p>
<p>sample 1 :
如果删除字符串并初始化一个新的相同字符串，则它们的ID相同，即首次创建时，它会存储在Interned词典中
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; id(s)</span><br><span class="line">4314134768</span><br><span class="line">&gt;&gt;&gt; del s</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &quot;aaa&quot;</span><br><span class="line">&gt;&gt;&gt; id(s)</span><br><span class="line">4314134768</span><br><span class="line">&gt;&gt;&gt; y &#x3D; &quot;aaa&quot;</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">4314134768</span><br></pre></td></tr></table></figure></p>
<p>sample 2: 虽然 str 对象 ‘abc’
由不同的运算产生，但背后却是同一个对象：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#39;abc&#39;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; &#39;ab&#39; + &#39;c&#39;</span><br><span class="line">&gt;&gt;&gt; id(a), id(b), a is b</span><br><span class="line">(4424345224, 4424345224, True)</span><br></pre></td></tr></table></figure></p>
<h3><span id="kind">kind</span><a href="#kind" class="header-anchor">#</a></h3>
<p>在PyASCIIObject中总共有四个kind域的值，这意味着字符是如何在内部存储在unicode对象中的。</p>
<ul>
<li>PyUnicode_WCHAR_KIND</li>
</ul>
<p>我还没有找到一种方法来定义python层中
<strong>用PyUnicode_WCHAR_KIND表示的unicode对象</strong>，它可能在
<strong>c / c ++</strong>中使用</p>
<h4><span id="pyunicode-1byte-kind">PyUnicode_1BYTE_KIND</span><a href="#pyunicode-1byte-kind" class="header-anchor">#</a></h4>
<p>-- 8位/字符 -- ascii标志设置？ --- ascii标志设置为true：U + 0000-U +
007F --- ascii标志设置为false：U + 0080-U + 00FF中至少一个字符
<strong>utf8_length</strong>字段仍存储以null终止的c样式字符串，除了interned字段为0之外，只有特定范围内的字符才会存储在
<strong>Interned字典</strong>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 &#x3D; &quot;\u007F\u0000&quot;</span><br><span class="line">&gt;&gt;&gt; id(s1)</span><br><span class="line">4472458224</span><br><span class="line">&gt;&gt;&gt; s2 &#x3D; &quot;\u007F\u0000&quot;</span><br><span class="line">&gt;&gt;&gt; id(s2) # bacause &quot;interned&quot; field is 0, the unicode object will not be shared</span><br><span class="line">4472458608</span><br></pre></td></tr></table></figure>
<p>字符存储单元还是 1 字节，跟 ASCII 文本一样。 因此，Python®
对象需要占用 80 字节的内存空间72+1*7+1=72+8=8072+1∗7+1=72+8=80：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sys.getsizeof(&#39;Python®&#39;)</span><br><span class="line">80</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;\u0088\u0011\u00f1&quot;</span><br><span class="line"></span><br><span class="line">由于第一个字符为U + 0088，ascii标志变为0，并且PyUnicode_UTF8（unicode）不再返回utf8_length字段的地址，而是返回 **char * utf8**字段中的值，即0</span><br></pre></td></tr></table></figure>
<p>如果PyUnicode_UTF8（unicode）为零，则这三个字节位于何处？我们没有在PyUnicodeObject中使用数据字段，让我们找出源码进行print（不感兴趣的可以跳过）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">unicode_repr(PyObject *unicode)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">        &#x2F;*</span><br><span class="line">        &#x2F;&#x2F; there exists official marco to get the char in exact index,</span><br><span class="line">        &#x2F;&#x2F; I use my own to have a better understanding of how things work internally</span><br><span class="line">        Py_ssize_t isize &#x3D; PyUnicode_GET_LENGTH(unicode);</span><br><span class="line">        Py_ssize_t idata &#x3D; PyUnicode_DATA(unicode);</span><br><span class="line">        int ikind &#x3D; PyUnicode_KIND(unicode);</span><br><span class="line">        &#x2F;&#x2F; no mattner what ikind is, use Py_UCS4(4 bytes) to catch the result</span><br><span class="line">        Py_UCS4 ch &#x3D; PyUnicode_READ(ikind, idata, i);</span><br><span class="line">        *&#x2F;</span><br><span class="line"></span><br><span class="line">        switch (_PyUnicode_STATE(unicode).kind)</span><br><span class="line">        &#123;</span><br><span class="line">            case (PyUnicode_1BYTE_KIND):</span><br><span class="line">                printf(&quot;PyUnicode_1BYTE_KIND, &quot;);</span><br><span class="line">                if (PyUnicode_UTF8(unicode) &#x3D;&#x3D; 0)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    char *value &#x3D; &amp;(((PyUnicodeObject *)unicode)-&gt;data);</span><br><span class="line">                    printf(&quot;\nPyUnicodeObject-&gt;latin1: &quot;);</span><br><span class="line">                    for (size_t i &#x3D; 0; i &lt; _PyUnicode_LENGTH(unicode); ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;%#hhx &quot;, *(value + i));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    printf(&quot;\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case (PyUnicode_2BYTE_KIND):</span><br><span class="line">                printf(&quot;PyUnicode_2BYTE_KIND, &quot;);</span><br><span class="line">                break;</span><br><span class="line">            case (PyUnicode_4BYTE_KIND):</span><br><span class="line">                printf(&quot;PyUnicode_4BYTE_KIND, &quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                printf(&quot;unknown kind: %d, &quot;, _PyUnicode_STATE(unicode).kind);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
重新编译上面的代码后，我们可以在repr（）函数中跟踪latin1字段
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; repr(s)</span><br><span class="line">PyUnicode_1BYTE_KIND,</span><br><span class="line">PyUnicodeObject-&gt;latin1: 0x88 0x11 0xf1</span><br></pre></td></tr></table></figure>
<div style="width:80%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-6-%E5%AD%97%E7%AC%A6%E4%B8%B2str/1byte_kind.png" class title="1byte_kind图">
</div>
<h4><span id="pyunicode-2byte-kind">PyUnicode_2BYTE_KIND</span><a href="#pyunicode-2byte-kind" class="header-anchor">#</a></h4>
<ul>
<li>16位/字符</li>
<li>所有字符都在U + 0000-U + FFFF范围内</li>
<li>至少一个字符在U + 0100-U + FFFF范围内</li>
</ul>
<p>我们可以使用相同的代码来跟踪存储在数据字段中的字节，现在字段名称为ucs2（ucs2或latin1具有不同的名称，但是地址相同，它们位于相同的c并集结构中）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; s &#x3D; &quot;\u0011\u0111\u1111&quot;</span><br><span class="line">&gt;&gt;&gt; repr(s)</span><br><span class="line">kind: PyUnicode_2BYTE_KIND,  PyUnicodeObject-&gt;ucs2: 0x11 0x111 0x1111</span><br></pre></td></tr></table></figure></p>
现在，kind字段是PyUnicode_2BYTE_KIND，需要
<strong>2个字节</strong>来存储每个字符
<div style="width:80%;margin:auto">

</div>
<h4><span id="pyunicode-4byte-kind">PyUnicode_4BYTE_KIND</span><a href="#pyunicode-4byte-kind" class="header-anchor">#</a></h4>
<ul>
<li>32位/字符</li>
<li>至少一个字符在U+10000-U+10FFFF范围内
现在，种类字段变为PyUnicode_4BYTE_KIND
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; &quot;\u00ff\U0010FFFF\U00100111\U0010FFF1&quot;</span><br><span class="line">&gt;&gt;&gt; repr(s)</span><br><span class="line">kind: PyUnicode_4BYTE_KIND, PyUnicodeObject-&gt;ucs4: 00xff 0x10ffff 0x100111 0x10fff1</span><br></pre></td></tr></table></figure>
<div style="width:80%;margin:auto">

</div></li>
</ul>
<h4><span id="unicode-nei-cun-shi-yong-qing-kuang-zhai-yao">Unicode内存使用情况摘要</span><a href="#unicode-nei-cun-shi-yong-qing-kuang-zhai-yao" class="header-anchor">#</a></h4>
<p>我们现在知道存在
<strong>三种存储机制</strong>，CPython存储一个Unicode对象将消耗多少字节
<strong>取决于字符的最大范围</strong>。 unicode对象内的所有字符必须
<strong>具有相同的大小</strong>，如果CPython使用可变大小的表示形式（例如utf-8），则不可能在O（1）时间内进行索引操作</p>
<div style="width:80%;margin:auto">
<img src="/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-6-%E5%AD%97%E7%AC%A6%E4%B8%B2str/kind_overview.png" class title="kind_overview图">
</div>
<h3><span id="compact">compact</span><a href="#compact" class="header-anchor">#</a></h3>
<p>如果compact为1，则意味着无论哪种字段，所有字符都存储在
<strong>PyUnicodeObject</strong>中(上面的示例都将compact设置为1)。否则，数据块将不会直接存储在PyUnicodeObject对象内，该数据块将是
<strong>新分配的位置</strong>。compact=0和compact=1之间的差异与Redis字符串编码raw和embstr之间的差异相同。</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://github.com/zpoint/CPython-Internals/blob/master/BasicObject/str/str.md" title="str">str</a></li>
<li><a href="https://www.imooc.com/read/76/article/1906" title="Python 源码深度剖析/10 str 对象，统一的 Unicode 字符串">Python
源码深度剖析/10 str 对象，统一的 Unicode 字符串</a></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 7.可变容器list</title>
    <url>/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/</url>
    <content><![CDATA[<h1><span id="nei-bu-jie-gou">内部结构</span><a href="#nei-bu-jie-gou" class="header-anchor">#</a></h1>
<div style="width:95%;margin:auto">
<img src="/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/memory_layout.png" class title="list_memory_layout图">
</div>
<p>list 对象是一种 <strong>变长对象</strong>
，因此包含变长对象公共头部。 除了公共头部， list
内部维护了一个动态数组，而
<strong>数组则依次保存元素对象的指针</strong>：</p>
<ul>
<li>**ob_item ，指向动态数组的指针，动态数组保存元素对象的指针；</li>
<li>allocated ，动态数组 <strong>长度</strong>，即列表
<strong>容量</strong>；</li>
<li>ob_size ，动态数组 <strong>当前保存元素个数</strong>，即列表
<strong>长度</strong> 。</li>
</ul>
<div style="width:95%;margin:auto">
<img src="/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/pylistObject.jpg" class title="pylistObject图">
</div>
<h1><span id="dui-xiang-cao-zuo">对象操作</span><a href="#dui-xiang-cao-zuo" class="header-anchor">#</a></h1>
<h2><span id="append">append</span><a href="#append" class="header-anchor">#</a></h2>
<p>python中的list的实现非常像 <strong>C++ 中的Vector</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; list（） # 初始化一个空列表</span><br></pre></td></tr></table></figure>
字段 ob_size存储实际大小，其类型为Py_ssize_t，通常为64位，1 &lt;&lt;
64可以表示的数非常大，通常在ob_size字段 <strong>溢出之前会耗尽
RAM</strong></p>
<div style="width:100%;margin:auto">
<img src="/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/list_empty.png" class title="list_empty图">
</div>
<p>如果我们append('a') 1个元素：</p>
<div style="width:100%;margin:auto">
<img src="/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/append_a.png" class title="append_a图">
</div>
<p><strong>ob_size</strong> 变为 1, <strong>ob_item</strong> 指向一个
<strong>大小为4的新内存块</strong></p>
<p>相继append三个元素：</p>
<div style="width:100%;margin:auto">
<img src="/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/append_d.png" class title="append_d图">
</div>
<p><strong>ob_size</strong> 变为 4, <strong>内存块满了</strong></p>
<p>大多数情况下， append 方法性能都足够好，<strong>时间复杂度是
O(1)</strong>。</p>
<h2><span id="dong-tai-kuo-rong">动态扩容</span><a href="#dong-tai-kuo-rong" class="header-anchor">#</a></h2>
继续append一个元素：
<div style="width:100%;margin:auto">
<img src="/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/append_e.png" class title="append_e图">
</div>
<p>这是resize相关代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* cpython&#x2F;Objects&#x2F;listobject.c *&#x2F;</span><br><span class="line">&#x2F;* The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ... *&#x2F;</span><br><span class="line">&#x2F;* currently: new_allocated &#x3D; 5 + (5 &gt;&gt; 3) + 3 &#x3D; 8 *&#x2F;</span><br><span class="line">new_allocated &#x3D; (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);  # 扩容时，预留一定的余量，(newsize &gt;&gt; 3)表明余量一般是 1&#x2F;8 左右</span><br></pre></td></tr></table></figure></p>
<p>如果 list 对象内部数组已用满，再添加元素时则需要进行扩容。 append
等方法在操作时都会对内部数组进行检查，如需扩容则调用 list_resize
函数。在 list_resize 函数， <strong>Python
重新分配一个长度更大的数组并替换旧数组</strong>。</p>
<p>由于内部数组扩容时，需要将列表元素
<strong>从旧数组拷贝到新数组</strong>，时间复杂度为
<strong>O(n)</strong> ，开销较大。为此， Python
在为内部数组扩容时，会预留一定余量，一般是 <strong>1/8 左右</strong>
。</p>
<h2><span id="pop">pop</span><a href="#pop" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; l.pop()</span><br><span class="line">&#39;e&#39;</span><br></pre></td></tr></table></figure>
<div style="width:100%;margin:auto">
<img src="/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/pop_e.png" class title="pop_e图">
</div>
<p>我们可以看到这里只是简单将 元素e 弹出，内存布局并未发生变化。</p>
<h2><span id="dong-tai-jian-rong">动态减容</span><a href="#dong-tai-jian-rong" class="header-anchor">#</a></h2>
实际上，每次pop，都会调用 <strong>resize</strong> 函数。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* cpython&#x2F;Objects&#x2F;listobject.c *&#x2F;</span><br><span class="line">&#x2F;* allocated: 8, newsize: 3, 8 &gt;&#x3D; 3 &amp;&amp; (3 &gt;&#x3D; 4?), no *&#x2F;</span><br><span class="line">if (allocated &gt;&#x3D; newsize &amp;&amp; newsize &gt;&#x3D; (allocated &gt;&gt; 1)) &#123;</span><br><span class="line">    &#x2F;* Do not realloc if the newsize deos not fall</span><br><span class="line">       lower than half the allocated size</span><br><span class="line">        不分配内存，仅改变ob_size的值    *&#x2F;</span><br><span class="line">    assert(self-&gt;ob_item !&#x3D; NULL || newsize &#x3D;&#x3D; 0);</span><br><span class="line">    &#x2F;* only change the ob_size field *&#x2F;</span><br><span class="line">    Py_SIZE(self) &#x3D; newsize;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* newsize小于allocated的一半时，会重新分配内存 *&#x2F;</span><br><span class="line">&#x2F;* 3 + (3 &gt;&gt; 3) + 3 &#x3D; 6 *&#x2F;</span><br><span class="line">new_allocated &#x3D; (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);</span><br></pre></td></tr></table></figure>
如果理解了pop 每次都会调用 resize 函数，下面情形就很容易理解了
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; l.pop()</span><br><span class="line">&#39;d&#39;</span><br></pre></td></tr></table></figure>
<div style="width:100%;margin:auto">
<img src="/2020/12/14/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8list/pop_d.png" class title="pop_d图">
</div>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://github.com/zpoint/CPython-Internals/blob/master/BasicObject/list/list.md" title="list">list</a></li>
<li><a href="https://www.imooc.com/read/76/article/1907" title="Python 源码深度剖析/11 list 对象，容量自适应的数组式容器">Python
源码深度剖析/11 list 对象，容量自适应的数组式容器</a></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 8.dict,关联式容器</title>
    <url>/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2><span id="nei-bu-jie-gou">内部结构</span><a href="#nei-bu-jie-gou" class="header-anchor">#</a></h2>
<p>C++ 标准模板库中的 <strong>map</strong> 是一种关联式容器，内部基于
<strong>红黑树</strong> 实现。红黑树是一种 <strong>平衡
二叉树，插入、删除、查找</strong> 等关键操作的时间复杂度均为
<strong>O(logn)</strong>。</p>
<p>Python 虚拟机的运行依赖 dict 对象，包括 <strong>名字空间</strong>
以及 <strong>对象属性空间</strong> 等底层都由 dict 实现的。因此Python
中的 dict 对象基于查找效率更高的 <strong>hash table</strong>
实现的。</p>
<h3><span id="pydictobject">PyDictObject</span><a href="#pydictobject" class="header-anchor">#</a></h3>
<p>首先来看看dict的结构，PyDictObject 在头文件 Include/dictobject.h
中定义：</p>
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/PyDictObject.png" class title="PyDictObject图">
</div>
<p>dict 对象 <strong>理论上应该是一种变长对象</strong>，但从
<strong>PyObject_HEAD</strong> 可以看出，它是基于
<strong>不可变长对象</strong>实现。 除了PyObject_HEAD外， PyDictObject
还包括以下几个字段：</p>
<ul>
<li>Py_ssize_t ma_used ，对象当前所保存的 <strong>键值对个数</strong>
；</li>
<li>uint64_t ma_version_tag ，对象当前 版本号 ，每次
<strong>修改时更新</strong>；</li>
<li>PyDictKeysObject *ma_keys ，指向按键对象映射的
<strong>哈希表</strong> 结构；</li>
<li>PyObject ** ma_values ， split table模式下指向由所有 <strong>值对象
组成的数组</strong>。</li>
</ul>
<h4><span id="dictkeysobject">_dictkeysobject</span><a href="#dictkeysobject" class="header-anchor">#</a></h4>
<p>然后我们再看看 PyDictKeysObject 的源码，在Objects/dict-common.h
头文件中的 **_dictkeysobject**:</p>
<ul>
<li>Py_ssize_t dk_refcnt ，引用计数，跟 映射视图
的实现有关，有点类似对象引用计数；</li>
<li>Py_ssize_t dk_size ，<strong>哈希表大小</strong>，必须是 <span class="math inline">\(2^n\)</span>，这样可将模运算优化成
<strong>按位与</strong> 运算；</li>
<li>dict_lookup_func dk_lookup ， <strong>哈希查找函数</strong>
指针，可根据 dict 当前状态选用最优函数版本；</li>
<li>Py_ssize_t dk_usable ，键值对数组 <strong>可用个数</strong> ；</li>
<li>Py_ssize_t dk_nentries ，键值对数组 <strong>已用个数</strong>
；</li>
<li>char dk_indices[] ，哈希表 <strong>起始地址</strong>
，哈希表后紧接着 <strong>键值对数组</strong> dk_entries。 char is
required to avoid strict aliasing.</li>
</ul>
<h4><span id="pydictkeyentry">PyDictKeyEntry</span><a href="#pydictkeyentry" class="header-anchor">#</a></h4>
<p>键值对结构体 PyDictKeyEntry
就非常直白了，除了保存键对象和值对象的指针外，缓存着键对象的哈希值：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    &#x2F;* Cached hash code of me_key. *&#x2F;</span><br><span class="line">    Py_hash_t me_hash;   &#x2F;* 键对象的 哈希值 ，避免重复调用 __hash__ 计算哈希值*&#x2F;</span><br><span class="line">    PyObject *me_key;    &#x2F;* 键对象指针*&#x2F;</span><br><span class="line">    PyObject *me_value; &#x2F;* 值对象指针 This field is only meaningful for combined tables *&#x2F;</span><br><span class="line">&#125; PyDictKeyEntry;</span><br></pre></td></tr></table></figure>
#### indices and entries dk_indices 是PyDictKeyEntry的数组，它的大小是
USABLE_FRACTION(dk_size)。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define USABLE_FRACTION(n) (((n) &lt;&lt; 1)&#x2F;3)  &#x2F;*line 413 in bjects&#x2F;dictobjetc.c*&#x2F;</span><br></pre></td></tr></table></figure></p>
DK_ENTRIES(dk)可用于获取指向entries的指针。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyDictKeyEntry *ep0 &#x3D; DK_ENTRIES(mp-&gt;ma_keys);    &#x2F;*PyDictObject *mp*&#x2F;</span><br></pre></td></tr></table></figure>
在 <strong>Objects/dictobjetc.c</strong>中，我们可以看到关于
<strong>DK_ENTRIES</strong> 的宏定义
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*line 312 in bjects&#x2F;dictobjetc.c*&#x2F;</span><br><span class="line"></span><br><span class="line">#define DK_ENTRIES(dk) \</span><br><span class="line">    ((PyDictKeyEntry*)(&amp;((int8_t*)((dk)-&gt;dk_indices))[DK_SIZE(dk) * DK_IXSIZE(dk)]))</span><br></pre></td></tr></table></figure>
重写DK_ENTRIES宏:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; assume int8_t can fit into the indices array</span><br><span class="line">size_t indices_offset &#x3D; DK_SIZE(dk) * DK_IXSIZE(dk);</span><br><span class="line">int8_t *pointer_to_indices &#x3D; (int8_t *)(dk-&gt;dk_indices);</span><br><span class="line">int8_t *pointer_to_entries &#x3D; pointer_to_indices + indices_offset;</span><br><span class="line">PyDictKeyEntry *entries &#x3D; (PyDictKeyEntry *) pointer_to_entries;</span><br></pre></td></tr></table></figure>
因此，PyDictKeysObject结构就很清晰了:
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/dictkeys_basic.png" class title="dictkeys_basic图">
</div>
<h2><span id="rong-liang-ce-lue">容量策略</span><a href="#rong-liang-ce-lue" class="header-anchor">#</a></h2>
<h3><span id="split-table-he-combined-table">split table和combined table</span><a href="#split-table-he-combined-table" class="header-anchor">#</a></h3>
在介绍PyDictObjet的ma_values时，我们曾提到 split
table模式下才使用。那么，什么是plit table和combined table呢？ #####
两者区别：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">The DictObject can be in one of two forms.</span><br><span class="line"></span><br><span class="line">Either:</span><br><span class="line">  A combined table:</span><br><span class="line">    ma_values &#x3D;&#x3D; NULL, dk_refcnt &#x3D;&#x3D; 1.   </span><br><span class="line">    Values are stored in the me_value field of the PyDictKeysObject.</span><br><span class="line">Or:</span><br><span class="line">  A split table:</span><br><span class="line">    ma_values !&#x3D; NULL, dk_refcnt &gt;&#x3D; 1</span><br><span class="line">    Values are stored in the ma_values array.</span><br><span class="line">    Only string (unicode) keys are allowed.</span><br><span class="line">    All dicts sharing same key must have same insertion order.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
##### 什么情况下，不同的dict对象共享相同的键但值不同 只包含
<strong>unicode键而不包含伪键（没有删除的对象）</strong>，并保持
<strong>相同的插入顺序</strong>。 如果
<strong>同一类有多个实例</strong>，split table实现
<strong>可以节省大量内存</strong>。有关更多详细信息，请参阅 <a href="https://www.python.org/dev/peps/pep-0412/">PEP 412</a>
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/key_shares.png" class title="key_shares图">
</div>
<h3><span id="yu-fen-pei-ji-zhi">预分配机制</span><a href="#yu-fen-pei-ji-zhi" class="header-anchor">#</a></h3>
<p>dict 对象也有一种类似 list 对象的 预分配机制 。那么， dict
对象容量管理策略是怎样的呢？</p>
<p>由 Objects/dictobject.c 源文件中的 PyDict_MINSIZE 宏定义，我们知道
<strong>dict 内部哈希表最小长度为 8</strong> ：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PyDict_MINSIZE 8</span><br></pre></td></tr></table></figure>
哈希表越密集，哈希冲突则越频繁，性能也就越差。因此，哈希表必须是一种
稀疏 的表结构，越稀疏则性能越好。由于 内存开销
的制约，哈希表不可能无限度稀疏，需要在时间和空间上进行权衡。实践经验表明，<strong>1/2至2/3</strong>满的哈希表，较好地平衡了
<strong>内存开销</strong> 与 <strong>搜索效率</strong> 。</p>
<p>为保证哈希表的稀疏程度，进而控制哈希冲突频率， Python 通过
USABLE_FRACTION
宏将哈希表内元素控制在<strong>2/3</strong>以内。USABLE_FRACTION
宏根据哈希表规模 n ，计算哈希表 <strong>可存储元素个数</strong>，也就是
<strong>键值对数组</strong> 的长度。以长度为 8
的哈希表为例，最多可以保持 5 个键值对，超出则需要扩容。USABLE_FRACTION
在<strong>indices and entries</strong>小节已经展示过了。</p>
<p>哈希表规模一定是 <span class="math inline">\(2^n\)</span> (熟悉C++
unordered_map的都知道，哈希扩容时只是 <strong>近似翻倍的质数</strong>)
，也就是说 Python 采用 <strong>翻倍扩容</strong> 策略。</p>
<h5><span id="wei-shi-me-python3-7-zhong-kong-dict-zhan-yong-liao-240-zi-jie">为什么python3.7中空dict占用了240字节？</span><a href="#wei-shi-me-python3-7-zhong-kong-dict-zhan-yong-liao-240-zi-jie" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 3.7.6 (default, Jan  8 2020, 20:23:39) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; empty_dict &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(empty_dict)</span><br><span class="line">240</span><br></pre></td></tr></table></figure>
<p>从以上分析，可以看出 Python 为空 dict 对象分配了一个 <strong>长度为 8
的哈希表</strong>，因而也要占用相当多的内存，主要有以下几个部分组成：</p>
<ul>
<li><strong>可收集对象链表节点</strong>，共 24 字节，在此不再展开，
垃圾回收机制 讲解中有详细介绍；</li>
<li>PyDictObject 结构体，6 个字段，共 <strong>48</strong> 字节；</li>
<li>PyDictKeysObject 结构体，除两个数组外有 5 个字段，共 40 字节；</li>
<li>哈希索引数组，<strong>长度为 8</strong> ，每个槽位 1 字节，共 8
字节；</li>
<li>键值对数组，长度为 5(用USABLE_FRACTION算出来的，限制在2/3之内)
，每个 <strong>PyDictKeyEntry 结构体 24 字节</strong>，共
<strong>120</strong> 字节。</li>
</ul>
<h3><span id="nei-cun-you-hua">内存优化</span><a href="#nei-cun-you-hua" class="header-anchor">#</a></h3>
<p>python2.7空dict占用272字节，而python3.7只占用240！！！
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 2.7 (r27:82525, Jul  4 2010, 07:43:08) [MSC v.1500 64 bit (AMD64)] on win32</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; empty_dict &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(empty_dict)</span><br><span class="line">272</span><br></pre></td></tr></table></figure></p>
<h5><span id="python3-6-zhi-qian">python3.6之前</span><a href="#python3-6-zhi-qian" class="header-anchor">#</a></h5>
如果有许多大的稀疏哈希表，则会浪费大量内存。
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/before_py36.png" class title="before_py36图">
</div>
<h5><span id="python3-6-zhi-hou">python3.6之后</span><a href="#python3-6-zhi-hou" class="header-anchor">#</a></h5>
为了以更紧凑的方式表示哈希表，可以在哈希表中 <strong>拆分 indices 和real
key-value</strong>。
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/after_py36.png" class title="after_py36图">
</div>
<p>indices 指向一个
<strong>索引数组</strong>，索引项指向原始内容存储的位置。可以将索引视为更简单的版本哈希表，将entries视为数组，数组将每个
哈希值、key和value(PyDictKeyEntry)存储为一个元素。</p>
每当 <strong>搜索或插入</strong> 一个元素时，根据hash value 和
indices的大小，就可以在indices数组中得到一个索引，并根据新得到的索引从entries中得到结果。
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/after_py36_search.png" class title="after_py36_search图">
</div>
<p>为优化内存使用， Python 将 dict 哈希表分为
<strong>哈希索引(indices)</strong> 和 <strong>键值对(entries)</strong>
两个数组来实现。例如，在64字大小的操作系统中，每个指针需要8个字节，原来需要
<span class="math inline">\(8 * 3 * 8 = 192\)</span> ，而优化后只需 $8 *
3 * 3 + 1 * 8 = 80 $ ，节省了大约58%的内存使用。</p>
<h5><span id="wei-shi-me-bian-li-zi-dian-python3-6-zhi-qian-shi-wu-xu-de-python3-6-zhi-hou-you-xu">为什么遍历字典python3.6之前是无序的，python3.6之后有序？</span><a href="#wei-shi-me-bian-li-zi-dian-python3-6-zhi-qian-shi-wu-xu-de-python3-6-zhi-hou-you-xu" class="header-anchor">#</a></h5>
<p>因为entries <strong>按插入顺序存储元素</strong>，所以可以
<strong>按插入项的相同顺序遍历哈希表</strong>。在旧版本的实现中，按<strong>hash
key</strong>的顺序存储元素，<strong>遍历哈希表时会出现无序</strong>。这就是为什么dict在python3.6之前是无序的，而在python3.6之后是有序的</p>
<h4><span id="you-hua-ji-suan">优化计算</span><a href="#you-hua-ji-suan" class="header-anchor">#</a></h4>
<p>由于哈希表必须保持 稀疏 ，最多只有 <strong>2/3</strong>
满，这意味着要浪费至少 <strong><span class="math inline">\(\frac{1}{3}\)</span></strong>
的内存空间。更雪上加霜的是，一个键值对条目 PyDictKeyEntry 大小达 24
字节，试想一个规模为 65536 的哈希表，将浪费高达 512KB 的内存空间：</p>
<p><span class="math display">\[65536 * \frac{1}{3} * 24 =
524288\]</span></p>
<p>为了尽量节省内存， Python 将 <strong>键值对数组</strong>压缩到原来的
<span class="math inline">\(\frac{2}{3}\)</span>，只负责存储，索引由另一个数组负责。由于索引数组只需要保存
键值对数组 的下标，而整数占用的内存空间只是若干字节，因此可以
<strong>节约大量内存</strong>。</p>
<h5><span id="suo-yin-shu-zu-mei-ge-yuan-su-de-da-xiao">索引数组每个元素的大小</span><a href="#suo-yin-shu-zu-mei-ge-yuan-su-de-da-xiao" class="header-anchor">#</a></h5>
索引数组 可根据哈希表规模，选择
<strong>尽量小的整数类型</strong>。对于规模 <strong>不超过 256</strong>
的哈希表，选择 <strong>8</strong> 位整数即可；对于长度 <strong>不超过
6553</strong>6 的哈希表， <strong>16</strong> 位整数足矣；以此类推。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DK_SIZE(dk) ((dk)-&gt;dk_size)</span><br><span class="line">#if SIZEOF_VOID_P &gt; 4</span><br><span class="line">#define DK_IXSIZE(dk)                          \</span><br><span class="line">    (DK_SIZE(dk) &lt;&#x3D; 0xff ?                     \</span><br><span class="line">        1 : DK_SIZE(dk) &lt;&#x3D; 0xffff ?            \</span><br><span class="line">            2 : DK_SIZE(dk) &lt;&#x3D; 0xffffffff ?    \</span><br><span class="line">                4 : sizeof(int64_t))</span><br><span class="line">#else</span><br><span class="line">#define DK_IXSIZE(dk)                          \</span><br><span class="line">    (DK_SIZE(dk) &lt;&#x3D; 0xff ?                     \</span><br><span class="line">        1 : DK_SIZE(dk) &lt;&#x3D; 0xffff ?            \</span><br><span class="line">            2 : sizeof(int32_t))</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/indices.png" class title="indices图">
</div>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th>哈希表规模</th>
<th>条目表规模</th>
<th>旧方案</th>
<th>新方案</th>
<th>节约内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>8 * 2 / 3 = 5</td>
<td>24 * 8 = 192</td>
<td>1 * 8 + 24 * 5 = 128</td>
<td>64</td>
</tr>
<tr>
<td>256</td>
<td>256 * 2 / 3 = 170</td>
<td>24 * 256 = 6144</td>
<td>1 * 256 + 24 * 170 = 4336</td>
<td>1808</td>
</tr>
<tr>
<td>65536</td>
<td>65536 * 2 / 3 = 43690</td>
<td>24 * 65536 = 1572864</td>
<td>2 * 65536 + 24 * 43690 = 1179632</td>
<td>393232</td>
</tr>
</tbody>
</table>
<h3><span id="free-list">free list</span><a href="#free-list" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef PyDict_MAXFREELIST</span><br><span class="line">#define PyDict_MAXFREELIST 80</span><br><span class="line">#endif</span><br><span class="line">static PyDictObject *free_list[PyDict_MAXFREELIST];</span><br></pre></td></tr></table></figure>
<p>CPython还使用 <strong>free list
重用删除的哈希表</strong>，<strong>避免内存碎片</strong>，提高性能</p>
<p><strong>每个进程全局变量</strong>都有个 <strong>free
list</strong></p>
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/free_list0.png" class title="free_list0图">
</div>
if we create a new dict object, the memory request is delegate to
CPython's memory management system
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; dict()</span><br></pre></td></tr></table></figure>
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/free_list1.png" class title="free_list1图">
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del a</span><br></pre></td></tr></table></figure>
<p>如果free list未满, dict类型的析构函数将当前dict存储到free list。</p>
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/free_list2.png" class title="free_list2图">
</div>
下次创建新的dict对象时，将检查 <strong>free list</strong>， 如果有
<strong>可用的对象</strong>则从 <strong>free
list</strong>分配；如果没有，则从
<strong>CPython的内存管理</strong>系统分配。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; dict()</span><br></pre></td></tr></table></figure>
<div style="width:100%;margin:auto">
<img src="/2021/01/03/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-dict%E5%93%88%E5%B8%8C%E8%A1%A8/free_list3.png" class title="free_list3图">
</div>
<h2><span id="ha-xi">哈希</span><a href="#ha-xi" class="header-anchor">#</a></h2>
<h4><span id="ke-ha-xi-hashable-dui-xiang">可哈希 ( hashable )对象</span><a href="#ke-ha-xi-hashable-dui-xiang" class="header-anchor">#</a></h4>
<p>根据哈希表性质， <strong>key对象</strong>
必须满足以下两个条件，否则哈希表便不能正常工作：</p>
<ul>
<li><strong>哈希值</strong>在对象整个生命周期内
<strong>不能改变</strong>； ( list 、dict 等
<strong>可变对象均不能</strong>作为哈希key)</li>
<li><strong>可比较</strong>，且比较相等的对象哈希值必须相同；
满足这两个条件的对象便是 可哈希 ( hashable )对象，只有
<strong>可哈希对象才可作为哈希表的键</strong>。因此，诸如 dict
、set等底层由哈希表实现的容器对象，其键对象必须是可哈希对象。</li>
</ul>
<p>而用户自定义的对象默认便是可哈希对象，对象哈希值由对象地址计算而来，且任意两个不同对象均不相等：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     pass</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; a &#x3D; A()</span><br><span class="line">&gt;&gt;&gt; b &#x3D; A()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; hash(a), hash(b)</span><br><span class="line">(2852108, 2852116)</span><br><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
#### 哈希函数 哈希值 计算作为对象行为中的一种，秘密也隐藏在类型对象中——
<strong>tp_hash 函数指针</strong>。而内置函数 <strong>hash</strong>
则依赖类型对象中的 <strong>tp_hash
函数</strong>，完成哈希值计算并返回。</p>
<p>以 str 对象为例，其哈希函数位于
<strong>Objects/unicodeobject.c</strong> 源文件，unicode_hash 是也：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyUnicode_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;str&quot;,              &#x2F;* tp_name *&#x2F;</span><br><span class="line">    sizeof(PyUnicodeObject),        &#x2F;* tp_size *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    (hashfunc) unicode_hash,        &#x2F;* tp_hash*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    unicode_new,            &#x2F;* tp_new *&#x2F;</span><br><span class="line">    PyObject_Del,           &#x2F;* tp_free *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
对于用户自定义的对象，可以实现 <strong>hash
魔术方法</strong>，<strong>重写默认哈希值计算方法</strong>。举个例子，假设标签类
Tag 的实例对象由 <strong>value 字段唯一标识</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Tag:</span><br><span class="line">    def __init__(self, value, title):</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line">        self.title &#x3D; title</span><br><span class="line"></span><br><span class="line">    def __hash__(self):</span><br><span class="line">     &quot;&quot;&quot;value 字段唯一标识,根据 value 字段实现 哈希函数&quot;&quot;&quot;</span><br><span class="line">        return hash(self.value)</span><br><span class="line"></span><br><span class="line">    def __eq__(self, other):</span><br><span class="line">      &quot;&quot;&quot;根据 value 字段实现 相等性 判断&quot;&quot;&quot;</span><br><span class="line">        return self.value &#x3D;&#x3D; other.value</span><br></pre></td></tr></table></figure>
哈希值 <strong>使用频率</strong>
较高，而且在对象生命周期内均不变。因此，可以在对象内部
<strong>对哈希值进行缓存</strong>，避免重复计算。以 str
对象为例，内部结构中的 <strong>hash
字段便是用于保存哈希值</strong>。</p>
<h4><span id="ha-xi-chong-tu">哈希冲突</span><a href="#ha-xi-chong-tu" class="header-anchor">#</a></h4>
<p>解决哈希冲突的常用方法有两种：</p>
<ul>
<li>分离链接法 ( separate chaining ) ；</li>
<li>开放地址法 ( open addressing )；</li>
</ul>
<h5><span id="fen-chi-lian-jie-fa">分离链接法</span><a href="#fen-chi-lian-jie-fa" class="header-anchor">#</a></h5>
<h5><span id="kai-fang-di-zhi-fa">开放地址法</span><a href="#kai-fang-di-zhi-fa" class="header-anchor">#</a></h5>
<ul>
<li>线性探测 ，顾名思义， <span class="math inline">\(d_i\)</span>是一个线性函数，例如 <span class="math inline">\(d_i = 2 * i\)</span></li>
<li>平方探测 ，顾名思义， <span class="math inline">\(d_i\)</span>是一个平方函数，例如 <span class="math inline">\(d_i = i^2\)</span> 线性探测 和 平方探测
很简单，<strong>平方探测似乎更胜一筹</strong>。如果哈希表存在局部热点，探测很难快速跳过热点区域，而
平方探测
则好很多。然而，这两种方法都不够好——因为固定的探测序列加大了冲突的概率。</li>
</ul>
<p>Python 探测方法在 lookdict 函数中实现，位于 Objects/dictobject.c
源文件内。关键代码如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Py_ssize_t _Py_HOT_FUNCTION</span><br><span class="line">lookdict(PyDictObject *mp, PyObject *key,</span><br><span class="line">         Py_hash_t hash, PyObject **value_addr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t i, mask, perturb;</span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    PyDictKeyEntry *ep0;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    dk &#x3D; mp-&gt;ma_keys;</span><br><span class="line">    ep0 &#x3D; DK_ENTRIES(dk);</span><br><span class="line">    mask &#x3D; DK_MASK(dk);</span><br><span class="line">    perturb &#x3D; hash;</span><br><span class="line">    i &#x3D; (size_t)hash &amp; mask;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Py_ssize_t ix &#x3D; dk_get_index(dk, i);</span><br><span class="line">        &#x2F;&#x2F; 省略键比较部分代码</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 计算下个槽位</span><br><span class="line">        &#x2F;&#x2F; 由于参考了对象哈希值，探测序列因哈希值而异</span><br><span class="line">        perturb &gt;&gt;&#x3D; PERTURB_SHIFT;</span><br><span class="line">        i &#x3D; (i*5 + perturb + 1) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_UNREACHABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="ha-xi-gong-ji">哈希攻击</span><a href="#ha-xi-gong-ji" class="header-anchor">#</a></h4>
<p>Python 在 3.3 以前， <strong>哈希算法</strong>
只根据对象本身计算哈希值。因此，<strong>只要 Python
解释器相同，对象哈希值也肯定相同</strong>。我们执行 Python 2
解释器启动一个交互式终端，并计算字符串 fasion 的哈希值：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.getpid()</span><br><span class="line">2878</span><br><span class="line">&gt;&gt;&gt; hash(&#39;fasion&#39;)</span><br><span class="line">-1023772170</span><br></pre></td></tr></table></figure>
我们再次执行 Python 2 解释器启动另一个交互式终端，发现字符串
<strong>fasion 的哈希值</strong>保存不变：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.getpid()</span><br><span class="line">2915</span><br><span class="line">&gt;&gt;&gt; hash(&#39;fasion&#39;)</span><br><span class="line">-1023772170</span><br></pre></td></tr></table></figure>
如果一些别有用心的人 <strong>构造出大量哈希值相同的 key</strong>
，并提交给服务器，会发生什么事情呢？例如，向一台 Python 2 Web 服务器
post 一个 json 数据，数据包含大量的 key ，<strong>所有 key
的哈希值相同</strong>。这意味着
<strong>哈希表将频繁发生哈希冲突</strong>，性能由 <span class="math inline">\(O(1)\)</span> 急剧下降为 <span class="math inline">\(O(N)\)</span>，被活生生打垮！这就是
<strong>哈希攻击</strong> 。</p>
<p>问题很严重，好在应对方法却很简单:<strong>为对象加把
盐(salt)</strong>。具体做法如下： 1. Python 解释器进程启动后，产生一个
<strong>随机数作为 盐</strong> ； 2. 哈希函数同时参考
<strong>对象本身</strong> 以及 <strong>随机数</strong> 计算哈希值；
这样一来，攻击者无法获悉解释器内部的随机数，也就无法构造出哈希值相同的对象了！Python
自 3.3 以后，哈希函数均采用 <strong>加盐模式</strong>，杜绝了
<strong>哈希攻击</strong> 的可能性。Python 哈希算法在 Python/pyhash.c
源文件中实现，有兴趣的童鞋可以学习一下，这里就不再展开了。</p>
<p>执行 Python 3.7 解释器，启动一个交互式终端，并计算字符串 fasion
的哈希值：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hash(&#39;fasion&#39;)</span><br><span class="line">6950491525924312838</span><br></pre></td></tr></table></figure>
再次执行 Python 3.7 解释器，启动另一个交互式终端，发现字符串 fasion
的哈希值已经变了：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hash(&#39;fasion&#39;)</span><br><span class="line">-7162025883309105262</span><br></pre></td></tr></table></figure>
## reference 1. <a href="https://github.com/zpoint/CPython-Internals/blob/master/BasicObject/dict/dict.md" title="dict">dict</a> 2. <a href="https://www.imooc.com/read/76/article/1909" title="Python 源码深度剖析/13 dict 对象，高效的关联式容器">Python
源码深度剖析/13 dict 对象，高效的关联式容器</a> 2. <a href="https://www.imooc.com/read/76/article/1910" title="Python 源码深度剖析/14 dict 哈希表高级知识精讲">Python
源码深度剖析/14 dict 哈希表高级知识精讲</a></p>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] PyAPI_xxx解析: GCC __attribute__语法</title>
    <url>/2021/07/27/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-PyAPI-FUNC%E5%88%86%E6%9E%90-GCC-attribute-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2><span id="pyapi-xxx">PyAPI_xxx</span><a href="#pyapi-xxx" class="header-anchor">#</a></h2>
<p>在cpython源码中, 可以看到很多地方使用了<strong>PyAPI_DATA,
PyAPI_FUNC, PyMODINIT_FUNC</strong>, 我们一起来看看这些都是什么。
<a id="more"></a>
在<strong>pyport.h</strong>中，我们可以看到对它们的定义（摘选部分）</p>
<p>以下代码中会用到的一些宏标识符，先进行一下说明： - Py_ENABLE_SHARED
值为1 ，windows平台下，Python核默认在DLL中，允许外部链接性 -
HAVE_DECLSPEC_DLL
所有windows编译器和cygwin均会定义，用于支持__declspec(). - Py_BUILD_CORE
构建Python内核。提供对Python内部构件的访问权，但不应被第三方模块使用。 -
Py_BUILD_CORE_MODULE 构建一个Python
stdlib模块作为一个动态库，Windows上导出“PyInit_xxx”符号。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* only get special linkage if built as shared or platform is Cygwin *&#x2F;</span><br><span class="line">#if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)</span><br><span class="line">#       if defined(HAVE_DECLSPEC_DLL)</span><br><span class="line">#               if defined(Py_BUILD_CORE) &amp;&amp; !defined(Py_BUILD_CORE_MODULE)</span><br><span class="line">                    &#x2F;&#x2F;被预定义了的</span><br><span class="line">#                   ...</span><br><span class="line">#               else &#x2F;* Py_BUILD_CORE *&#x2F;</span><br><span class="line">        &#x2F;* Building an extension module(扩展模块), or an embedded situation *&#x2F;</span><br><span class="line">        &#x2F;* public Python functions and data are imported *&#x2F;</span><br><span class="line">#                       if !defined(__CYGWIN__)</span><br><span class="line">#                               define PyAPI_FUNC(RTYPE) Py_IMPORTED_SYMBOL RTYPE</span><br><span class="line">#                       endif &#x2F;* !__CYGWIN__ *&#x2F;</span><br><span class="line">#                       define PyAPI_DATA(RTYPE) extern Py_IMPORTED_SYMBOL RTYPE</span><br><span class="line">        &#x2F;* module init functions outside the core must be exported *&#x2F;</span><br><span class="line">#                       if defined(__cplusplus)</span><br><span class="line">#                               define PyMODINIT_FUNC extern &quot;C&quot; Py_EXPORTED_SYMBOL PyObject*</span><br><span class="line">#                       else &#x2F;* __cplusplus *&#x2F;</span><br><span class="line">#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*</span><br><span class="line">#                       endif &#x2F;* __cplusplus *&#x2F;</span><br><span class="line">#               endif &#x2F;* Py_BUILD_CORE *&#x2F;</span><br><span class="line">#       endif &#x2F;* HAVE_DECLSPEC_DLL *&#x2F;</span><br><span class="line">#endif &#x2F;* Py_ENABLE_SHARED *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* If no external linkage macros defined by now, create defaults(如 GCC, Unix) *&#x2F;</span><br><span class="line">#ifndef PyAPI_FUNC</span><br><span class="line">#       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE</span><br><span class="line">#endif</span><br><span class="line">#ifndef PyAPI_DATA</span><br><span class="line">#       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE</span><br><span class="line">#endif</span><br><span class="line">#ifndef PyMODINIT_FUNC</span><br><span class="line">#       if defined(__cplusplus)</span><br><span class="line">#               define PyMODINIT_FUNC extern &quot;C&quot; Py_EXPORTED_SYMBOL PyObject*</span><br><span class="line">#       else &#x2F;* __cplusplus *&#x2F;</span><br><span class="line">#               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*</span><br><span class="line">#       endif &#x2F;* __cplusplus *&#x2F;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
我们可以看到基本采用了<strong>Py_EXPORTED_SYMBOL</strong>,
只有<strong>shared模式或Cygwin平台</strong>下的<strong>扩展模块</strong>才采用了<strong>Py_IMPORTED_SYMBOL</strong>。</p>
<h2><span id="py-xxx-symbol">Py_xxx_SYMBOL</span><a href="#py-xxx-symbol" class="header-anchor">#</a></h2>
<p>我们在export.h下可以看到Py_EXPORTED_SYMBOL、Py_IMPORTED_SYMBOL的定义。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;跨平台通用性</span><br><span class="line">#if defined(_WIN32) || defined(__CYGWIN__)</span><br><span class="line">    &#x2F;* 对于win32和Cygwin，使用__declspec()指定属性 *&#x2F;</span><br><span class="line">    #define Py_IMPORTED_SYMBOL __declspec(dllimport) &#x2F;&#x2F;从dll导入。其它模块可见</span><br><span class="line">    #define Py_EXPORTED_SYMBOL __declspec(dllexport) &#x2F;&#x2F;导出到dll。其它模块可见</span><br><span class="line">    #define Py_LOCAL_SYMBOL</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">    &#x2F;&#x2F;__has_attribute参数为属性名，可以评估当前编译目标是否支持该属性，支持为1，不支持为0</span><br><span class="line">    #ifndef __has_attribute</span><br><span class="line">      #define __has_attribute(x) 0  &#x2F;&#x2F; Compatibility with non-clang compilers.</span><br><span class="line">    #endif</span><br><span class="line">    #if (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;&#x3D; 4)) ||\   &#x2F;&#x2F;如果 gcc版本&gt;&#x3D;4 或 clang判定编译目标支持visibility属性，则添加属性</span><br><span class="line">        (defined(__clang__) &amp;&amp; __has_attribute(visibility))</span><br><span class="line">        #define Py_IMPORTED_SYMBOL __attribute__ ((visibility (&quot;default&quot;))) &#x2F;&#x2F;具有外部链接性 (external linkage)，可以被外部其它模块引用，并且有可能被重写</span><br><span class="line">        #define Py_EXPORTED_SYMBOL __attribute__ ((visibility (&quot;default&quot;)))</span><br><span class="line">        #define Py_LOCAL_SYMBOL  __attribute__ ((visibility (&quot;hidden&quot;))) &#x2F;&#x2F;只能在同一共享对象（可简单理解为库文件）中被引用</span><br><span class="line">    #else</span><br><span class="line">        #define Py_IMPORTED_SYMBOL</span><br><span class="line">        #define Py_EXPORTED_SYMBOL</span><br><span class="line">        #define Py_LOCAL_SYMBOL</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
gcc下采用**关键字__attribute__<strong>可以为</strong>函数，结构体，类，枚举,
变量，标签<strong>等</strong>添加属性<strong>；在winfows下</strong>关键字__declspec**可以实现同样的特性。</p>
<ul>
<li>Py_IMPORTED_SYMBOL:用于在Windows编译器或cygwin中，构建非核心模块时定义宏
PyAPI_FUNC，PyAPI_DATA，意义是直接导入核心模块，<strong>不编译</strong>,
防止编译器再次编译。</li>
<li>Py_EXPORTED_SYMBOL: default，指定函数, class, struct
等为公开可重写的。<strong>编译导出到动态库(DLL或so)</strong></li>
<li>Py_LOCAL_SYMBOL: hidden，指定函数, class, struct
等<strong>只能在同一共享对象中被引用</strong></li>
</ul>
<h3><span id="visibility-shu-xing">visibility 属性</span><a href="#visibility-shu-xing" class="header-anchor">#</a></h3>
<p>visibility 属性用于<strong>指定可见性</strong>，可以用于
<strong>函数, class, struct, union, enum</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __attribute__ ((visibility (&quot;protected&quot;))) f () &#123; &#x2F;* Do something. *&#x2F;; &#125;</span><br><span class="line">int i __attribute__ ((visibility (&quot;hidden&quot;)));</span><br></pre></td></tr></table></figure>
属性值： - default：具有外部链接性 (external
linkage)，可以被外部其它模块引用，并且有可能被重写。 不编译，直接导入 -
hidden：只能在同一共享对象（可简单理解为库文件）中被引用 -
internal：无法被其它模块直接引用，但是可以通过指针间接引用 -
protected：可以被引用，但无法被重写</p>
<h2><span id="pyapi-func">PyAPI_FUNC</span><a href="#pyapi-func" class="header-anchor">#</a></h2>
<p>在gcc下, 以genobject.h中的PyGen_New为例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyAPI_FUNC(PyObject *) PyGen_New(PyFrameObject *);</span><br></pre></td></tr></table></figure>
根据define的使用方法替换一下，此处就相当于
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Py_EXPORTED_SYMBOL PyObject * PyGen_New(PyFrameObject *)</span><br></pre></td></tr></table></figure>
继续替换
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute__ ((visibility (&quot;default&quot;))) PyObject * PyGen_New(PyFrameObject *)</span><br></pre></td></tr></table></figure>
这里其实是定义了一个<strong>公开</strong>的可以<strong>被其它模块调用或重写</strong>的函数PyObject
* PyGen_New(PyFrameObject *)</p>
<h3><span id="jie-lun">结论</span><a href="#jie-lun" class="header-anchor">#</a></h3>
<p><strong>PyAPI_FUNC</strong>
指定函数<strong>可以被各个模块访问</strong>。</p>
<h2><span id="pyapi-data">PyAPI_DATA</span><a href="#pyapi-data" class="header-anchor">#</a></h2>
<p>以boolobject.h中的PyBool_Type为例
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyAPI_DATA(PyTypeObject) PyDictRevIterKey_Type;</span><br></pre></td></tr></table></figure>
替换
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Py_EXPORTED_SYMBOL PyTypeObject PyDictRevIterKey_Type;</span><br></pre></td></tr></table></figure>
继续替换
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute__ ((visibility (&quot;default&quot;))) PyTypeObject PyDictRevIterKey_Type;</span><br></pre></td></tr></table></figure>
结果是声明了一个可以被其它模块访问的<strong>PyTypeObject结构体</strong>变量。</p>
<h3><span id="jie-lun">结论</span><a href="#jie-lun" class="header-anchor">#</a></h3>
<p>PyAPI_DATA<strong>指定变量</strong>可以<strong>被其它模块访问</strong>。</p>
<h2><span id="pymodinit-func">PyMODINIT_FUNC</span><a href="#pymodinit-func" class="header-anchor">#</a></h2>
<p>以<strong>binassi.h</strong>的中的模块初始化函数为例
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyMODINIT_FUNC</span><br><span class="line">PyInit_binascii(void)</span><br><span class="line">&#123;</span><br><span class="line">    return PyModuleDef_Init(&amp;binasciimodule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
替换
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Py_EXPORTED_SYMBOL PyObject* PyInit_binascii(void)</span><br><span class="line">&#123;</span><br><span class="line">    return PyModuleDef_Init(&amp;binasciimodule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
继续替换
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute__ ((visibility (&quot;default&quot;))) PyObject* PyInit_binascii(void)</span><br><span class="line">&#123;</span><br><span class="line">    return PyModuleDef_Init(&amp;binasciimodule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
到这里可以看出来，<strong>PyInit_binascii()函数</strong>调用了<strong>PyModuleDef_Init()方法</strong>对<strong>binasciimodule</strong>进行了<strong>初始化</strong>，然后<strong>返回一个PyObject结构体的指针</strong>变量</p>
<h3><span id="jie-lun">结论</span><a href="#jie-lun" class="header-anchor">#</a></h3>
<p>PyMODINIT_FUNC指定模块初始化函数可以&amp;&amp;被其它模块访问&amp;&amp;，并<strong>返回PyObject结构体的指针变量</strong></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<p>1.<a href="https://blog.51cto.com/u_15127642/2875208">GCC
__attribute__语法：visibility属性在cpython中的应用（PyAPI_FUNC,
PyAPI_DATA, PyMODINIT_FUNC）</a></p>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 9.执行过程和字节码</title>
    <url>/2021/02/23/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-9-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<p>.py文件是如何转换为机器指令被CPU执行呢？.pyc文件作用是什么？</p>
<h2><span id="zhi-xing-yuan-li">执行原理</span><a href="#zhi-xing-yuan-li" class="header-anchor">#</a></h2>
<p>C/C++之类的编译性语言编写的程序，是需要从源文件转换成计算机使用的机器语言，经过
<strong>链接器链接之后形成了二进制的可执行文件</strong>。运行该程序的时候，就可以把
<strong>二进制程序从硬盘载入到内存</strong>中并运行。</p>
<p>但是对于Python而言，python源码
<strong>不需要编译成二进制代码</strong>，它可以<strong>直接从源代码运行程序</strong>。</p>
<p>从程序执行时的基本表示是 <strong>实际计算机上的机器语言</strong> 还是
<strong>虚拟机的机器语言</strong>维度，可以将程序设计语言划分为两大类：<strong>编译型语言和解释型语言</strong>。</p>
<ul>
<li><p>编译实现的语言，如：C、C++、Fortran、Pascal、Ada。由编译型语言编写的源程序需要经过
<strong>编译,汇编和链接</strong>才能输出目标代码，然后
<strong>由机器执行目标代码</strong>。目标代码是由
<strong>机器指令</strong>组成，不能独立运行，因为源程序中可能使用了一些汇编程序不能解释引用的库函数，而库函数又不在源程序中，此时还需要链接程序完成外部引用和目标模板调用的链接任务，最后才能输出可执行代码。</p></li>
<li><p>解释型语言，解释器 <strong>不产生目标机器代码</strong>，而是
<strong>产生中间代码</strong>，这种中间代码与机器代码不同，中间代码的解释是
<strong>由软件支持的</strong>，<strong>不能直接使用在硬件上</strong>。该软件解释器通常会
<strong>导致执行效率较低</strong>，用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。和编译的程序不同的是,
解释程序的任务是
<strong>逐一将源代码的语句解释成可执行的机器指令</strong>，不需要将源程序翻译成目标代码再执行。对于解释型语言，需要一个<strong>专门的解释器</strong>
来执行该程序，每条语句只有在执行是才能被翻译，这种解释型语言每执行一次就翻译一次，因而<strong>效率低下</strong>。</p></li>
<li><p>Java解释器，java很特殊，java是需要编译的，但是没有直接编译成机器语言，而是编译成字节码，然后在Java虚拟机上用解释的方式执行字节码。Python也使用了类似的方式，先将python编译成
<strong>python字节码</strong>，然后由一个专门的python字节码解释器负责解释执行字节码。</p></li>
<li><p>python是一门解释语言，但是出于效率的考虑，提供了一种<strong>编译的方法</strong>。编译之后就得到<strong>pyc</strong>文件，存储了<strong>字节码</strong>。python这点和java很类似，但是java与python不同的是，python是一个解释型的语言，所以编译字节码<strong>不是一个强制的操作</strong>，事实上，编译是一个自动的过程，一般不会在意它的存在。编译成字节码可以<strong>节省加载模块的时间，提高效率</strong>。除了效率之外，字节码的形式也<strong>增加了反向工程的难度，可以保护源代码</strong>。这个只是一定程度上的保护，反编译还是可以的。</p></li>
</ul>
<h2><span id="zhi-xing-guo-cheng">执行过程</span><a href="#zhi-xing-guo-cheng" class="header-anchor">#</a></h2>
<p>Python 更像 Shell
脚本这样的解释性语言,实际上执行原理本质同Java一样，都可以归纳为
<strong>虚拟机</strong> 和 <strong>字节码</strong></p>
<div style="width:100%;margin:auto">
<img src="/2021/02/23/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-9-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81/python_process.jpg" class title="python_process图">
</div>
<p>虽然 python 命令也叫做 <strong>Python 解释器 ( Interpreter
)</strong>，但跟其他脚本语言解释器<strong>有本质区别</strong>。实际上，
Python 解释器包含 <strong>编译器</strong> 以及 <strong>虚拟机</strong>
两部分。当 Python 解释器启动后，主要执行以下两个步骤：</p>
<ol type="1">
<li>编译器 将 .py 文件中的 Python 源码 <strong>编译成
字节码</strong></li>
<li>虚拟机 <strong>逐行执行</strong>编译器生成的 字节码</li>
</ol>
<p>因此， <strong>.py</strong> 文件中的 Python 语句
<strong>并没有直接转换成机器指令</strong>，而是转换成 Python 字节码
。</p>
<h2><span id="zi-jie-ma">字节码</span><a href="#zi-jie-ma" class="header-anchor">#</a></h2>
<p>Python中有一个内置函数 <strong>compile()</strong>，可以将源文件
<strong>编译成codeobject</strong>，首先看这个函数的说明：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object</span><br></pre></td></tr></table></figure>
- source ，源文件的内容字符串 - filename ，源文件名称 - mode 编译模式
：<strong>exec</strong>-编译module，<strong>single</strong>-编译一个声明，<strong>eval</strong>-编译一个表达式</p>
<h3><span id="pycodeobject">PyCodeObject</span><a href="#pycodeobject" class="header-anchor">#</a></h3>
<p>定义 test.py文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PI &#x3D; 3.14</span><br><span class="line"></span><br><span class="line">def circle_area(r):</span><br><span class="line">    return PI * r ** 2</span><br><span class="line"></span><br><span class="line">class Dog(object):</span><br><span class="line">  </span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">  </span><br><span class="line">    def yelp(self):</span><br><span class="line">        print(&#39;woof, i am&#39;, self.name)</span><br></pre></td></tr></table></figure>
调用 compile 函数编译源码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; result &#x3D; compile(open(&#39;C:\\Users\\liuwen03\\Desktop\\test.py&#39;).read(), &#39;test.py&#39;, &#39;exec&#39;)</span><br><span class="line">&gt;&gt;&gt; result</span><br><span class="line">&lt;code object &lt;module&gt; at 00000000036E27B0, file &quot;test.py&quot;, line 1&gt;</span><br><span class="line">&gt;&gt;&gt; result.__class__</span><br><span class="line">&lt;type &#39;code&#39;&gt;</span><br></pre></td></tr></table></figure>
看上去我们得到了一个 <strong>code对象</strong> 。 在 Include/code.h
中，可以找到代表代码对象的 C 结构体 <strong>PyCodeObject</strong> 。
PyCodeObject 定义如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Bytecode object *&#x2F;</span><br><span class="line">struct PyCodeObject &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int co_argcount;            &#x2F;* #arguments, except *args 参数数量*&#x2F;</span><br><span class="line">    int co_posonlyargcount;     &#x2F;* #positional only arguments *&#x2F;</span><br><span class="line">    int co_kwonlyargcount;      &#x2F;* #keyword only arguments 关键字参数个数*&#x2F;</span><br><span class="line">    int co_nlocals;             &#x2F;* #local variables 局部变量个数*&#x2F;</span><br><span class="line">    int co_stacksize;           &#x2F;* #entries needed for evaluation stack   执行代码所需栈数量*&#x2F;</span><br><span class="line">    int co_flags;               &#x2F;* CO_..., see below 标识*&#x2F;</span><br><span class="line">    int co_firstlineno;         &#x2F;* first source line number 代码块首行行号*&#x2F;</span><br><span class="line">    PyObject *co_code;          &#x2F;* instruction opcodes 指令操作码，也就是字节码*&#x2F;</span><br><span class="line">    PyObject *co_consts;        &#x2F;* list (constants used) 常量列表*&#x2F;</span><br><span class="line">    PyObject *co_names;         &#x2F;* list of strings (names used)    全局变量名列表*&#x2F;</span><br><span class="line">    PyObject *co_varnames;      &#x2F;* tuple of strings (local variable names) 局部变量名列表*&#x2F;</span><br><span class="line">    PyObject *co_freevars;      &#x2F;* tuple of strings (free variable names) 闭包名字列表*&#x2F;</span><br><span class="line">    PyObject *co_cellvars;      &#x2F;* tuple of strings (cell variable names) 被嵌套函数使用的名字列表*&#x2F;</span><br><span class="line">    &#x2F;* The rest aren&#39;t used in either hash or comparisons, except for co_name,</span><br><span class="line">       used in both. This is done to preserve the name and line number</span><br><span class="line">       for tracebacks and debuggers; otherwise, constant de-duplication</span><br><span class="line">       would collapse identical functions&#x2F;lambdas defined on different lines.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    Py_ssize_t *co_cell2arg;    &#x2F;* Maps cell vars which are arguments. *&#x2F;</span><br><span class="line">    PyObject *co_filename;      &#x2F;* unicode (where it was loaded from)  文件名*&#x2F;</span><br><span class="line">    PyObject *co_name;          &#x2F;* unicode (name, for reference) 函数名*&#x2F;</span><br><span class="line">    PyObject *co_linetable;     &#x2F;* string (encoding addr&lt;-&gt;lineno mapping) See</span><br><span class="line">                                   Objects&#x2F;lnotab_notes.txt for details. *&#x2F;</span><br><span class="line">    void *co_zombieframe;       &#x2F;* for optimization only (see frameobject.c) *&#x2F;</span><br><span class="line">    PyObject *co_weakreflist;   &#x2F;* to support weakrefs to code objects *&#x2F;</span><br><span class="line">    &#x2F;* Scratch space for extra data relating to the code object.</span><br><span class="line">       Type is a void* to keep the format private in codeobject.c to force</span><br><span class="line">       people to go through the proper APIs. *&#x2F;</span><br><span class="line">    void *co_extra;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Per opcodes just-in-time cache</span><br><span class="line">     *</span><br><span class="line">     * To reduce cache size, we use indirect mapping from opcode index to</span><br><span class="line">     * cache object:</span><br><span class="line">     *   cache &#x3D; co_opcache[co_opcache_map[next_instr - first_instr] - 1]</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; co_opcache_map is indexed by (next_instr - first_instr).</span><br><span class="line">    &#x2F;&#x2F;  * 0 means there is no cache for this opcode.</span><br><span class="line">    &#x2F;&#x2F;  * n &gt; 0 means there is cache in co_opcache[n-1].</span><br><span class="line">    unsigned char *co_opcache_map;</span><br><span class="line">    _PyOpcache *co_opcache;</span><br><span class="line">    int co_opcache_flag;  &#x2F;&#x2F; used to determine when create a cache.</span><br><span class="line">    unsigned char co_opcache_size;  &#x2F;&#x2F; length of co_opcache.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
从源码可以看出, 代码对象 <strong>PyCodeObject</strong>
用于<strong>存储编译结果</strong>，包括 <strong>字节码</strong>
以及代码涉及的 <strong>常量</strong> <strong>名字</strong> 等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; result.co_code</span><br><span class="line">&#39;d\x00\x00Z\x00\x00d\x01\x00\x84\x00\x00Z\x01\x00d\x02\x00e\x02\x00f\x01\x00d\x03\x00\x84\x00\x00\x83\x00\x00YZ\x03\x00d\x04\x00S&#39;</span><br></pre></td></tr></table></figure>
<p>字节码现在看上去如同天书一般。看看代码对象涉及的所有名字 和
常量列表：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; result.co_names</span><br><span class="line">(&#39;PI&#39;, &#39;circle_area&#39;, &#39;object&#39;, &#39;Dog&#39;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; result.co_consts</span><br><span class="line">(3.14, &lt;code object circle_area at 00000000036DBEB0, file &quot;test.py&quot;, line 3&gt;, &#39;Dog&#39;, &lt;code object Dog at 00000000036E2A30, file &quot;test.py&quot;, line 6&gt;, None)</span><br></pre></td></tr></table></figure></p>
<p>常量列表里 <strong>还有两个代码对象</strong>！其中一个是
<strong>circle_area 函数体</strong>，另一个是 <strong>Dog
类定义体</strong>。回忆一下 <strong>Python 作用域</strong> 的划分方式：
<strong>每个作用域</strong>对应着一个<strong>代码对象</strong>
！若假设成立， <strong>Dog
代码对象</strong>的常量列表应该<strong>还藏着两个代码对象</strong>，分别代表
<em>init</em> 方法和 yelp 方法的函数体：</p>
<div style="width:100%;margin:auto">
<img src="/2021/02/23/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-9-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81/pycodeobject.jpg" class title="pycodeobject图">
</div>
<p>事实确实如此：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dog_code &#x3D; result.co_consts[3]</span><br><span class="line">&gt;&gt;&gt; dog_code.co_consts</span><br><span class="line">(&lt;code object __init__ at 00000000036D48B0, file &quot;test.py&quot;, line 8&gt;, &lt;code object yelp at 00000000036D49B0, file &quot;test.py&quot;, line 11&gt;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
因此，我们得到以下结论： Python
源码编译后，<strong>每个作用域</strong>都对应着<strong>一个代码对象</strong>，<strong>子作用域</strong>代码对象位于<strong>父作用域代码对象</strong>的<strong>常量列表</strong>里，层级一一对应。</p>
<h3><span id="fan-bian-yi">反编译</span><a href="#fan-bian-yi" class="header-anchor">#</a></h3>
<p>从上面我们可以看到，字节码是一堆长得跟天书一样的<strong>不可读的字节序列</strong>，跟<strong>二进制机器码</strong>一样。
用<strong>dis</strong>反编译字节码，让它变得可读
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(result.co_code)</span><br><span class="line">          0 LOAD_CONST          0 (0)</span><br><span class="line">          3 STORE_NAME          0 (0)</span><br><span class="line">          6 LOAD_CONST          1 (1)</span><br><span class="line">          9 MAKE_FUNCTION       0</span><br><span class="line">         12 STORE_NAME          1 (1)</span><br><span class="line">         15 LOAD_CONST          2 (2)</span><br><span class="line">         18 LOAD_NAME           2 (2)</span><br><span class="line">         21 BUILD_TUPLE         1</span><br><span class="line">         24 LOAD_CONST          3 (3)</span><br><span class="line">         27 MAKE_FUNCTION       0</span><br><span class="line">         30 CALL_FUNCTION       0</span><br><span class="line">         33 BUILD_CLASS</span><br><span class="line">         34 STORE_NAME          3 (3)</span><br><span class="line">         37 LOAD_CONST          4 (4)</span><br><span class="line">         40 RETURN_VALUE</span><br></pre></td></tr></table></figure>
第一列是<strong>字节码偏移量</strong> ，第二列是 <strong>指令</strong>
，第三列是 <strong>操作数</strong> 。</p>
<p>以第一条字节码为例， LOAD_CONST
指令将常量加载进栈，常量下标由操作数给出。而下标为 0 的常量是：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; result.co_consts[0]</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>
因此，第一条字节码就是将常量 3.14 加载到栈。</p>
<p>由于代码对象 保存了
<strong>常量、名字</strong>等上下文信息，因此直接对代码对象进行反编译可以得到更为清晰的结果：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dis.dis(result)</span><br><span class="line">  1           0 LOAD_CONST               0 (3.14)</span><br><span class="line">              3 STORE_NAME               0 (PI)</span><br><span class="line"></span><br><span class="line">  3           6 LOAD_CONST               1 (&lt;code object circle_area at 00000000036DBEB0, file &quot;test.py&quot;, line 3&gt;)</span><br><span class="line">              9 MAKE_FUNCTION            0</span><br><span class="line">             12 STORE_NAME               1 (circle_area)</span><br><span class="line"></span><br><span class="line">  6          15 LOAD_CONST               2 (&#39;Dog&#39;)</span><br><span class="line">             18 LOAD_NAME                2 (object)</span><br><span class="line">             21 BUILD_TUPLE              1</span><br><span class="line">             24 LOAD_CONST               3 (&lt;code object Dog at 00000000036E2A30, file &quot;test.py&quot;, line 6&gt;)</span><br><span class="line">             27 MAKE_FUNCTION            0</span><br><span class="line">             30 CALL_FUNCTION            0</span><br><span class="line">             33 BUILD_CLASS</span><br><span class="line">             34 STORE_NAME               3 (Dog)</span><br><span class="line">             37 LOAD_CONST               4 (None)</span><br></pre></td></tr></table></figure>
注意到，操作数 指定的 常量或名字的
<strong>实际值</strong>在旁边的<strong>括号内列出</strong>。另外，字节码<strong>以语句为单位进行分组</strong>，中间以<strong>空行隔开</strong>，<strong>语句行号</strong>在字节码前面给出。
PI = 3.14 这个语句编译成以下两条字节码：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           0 LOAD_CONST               0 (3.14)</span><br><span class="line">            3 STORE_NAME               0 (PI)</span><br></pre></td></tr></table></figure></p>
<h2><span id="pyc">pyc</span><a href="#pyc" class="header-anchor">#</a></h2>
<p>如果将 test 作为模块导入， Python 将在 test.py 文件所在目录下生成
.pyc 文件：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import test pyc 文件保存 <strong>经过序列化处理的代码对象
PyCodeObject</strong> 。这样一来， Python 后续导入 test
模块时，<strong>直接读取 pyc 文件并反序列化即可得到代码对象</strong>
，避免了重复编译导致的开销。只有 test.py <strong>有新修改(时间戳比 pyc
文件新)</strong>， Python 才会重新编译。</p>
</blockquote>
</blockquote>
</blockquote>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://blog.csdn.net/helloxiaozhe/article/details/78104975">python编译过程和执行原理</a></li>
<li><a href="https://www.imooc.com/read/76/article/1915">Python
源码深度剖析/18 Python 程执行过程与字节码</a></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] import模块</title>
    <url>/2020/12/16/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-import%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2><span id="import-mo-kuai">import模块</span><a href="#import-mo-kuai" class="header-anchor">#</a></h2>
<h3><span id="import-xxx">import xxx</span><a href="#import-xxx" class="header-anchor">#</a></h3>
<p>定义test.py
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import _locale</span><br></pre></td></tr></table></figure></p>
<p>用dis模块编译一下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\liuw\Desktop&gt; python.exe -m dis .\test.py</span><br><span class="line">  1           0 LOAD_CONST               0 (0)</span><br><span class="line">              2 LOAD_CONST               1 (None)</span><br><span class="line">              4 IMPORT_NAME              0 (_locale)</span><br><span class="line">              6 STORE_NAME               0 (_locale)</span><br><span class="line">              8 LOAD_CONST               1 (None)</span><br><span class="line">             10 RETURN_VALUE</span><br></pre></td></tr></table></figure></p>
<p>想象一下，当前
<strong>有两个或多个线程</strong>正在导入相同的random模块，<strong>CPython如何处理</strong>这种情况？</p>
<ol type="1">
<li>操作码IMPORT_NAME将检查导入的名称是否在sys.module中，如果是，则返回
<strong>sys.module</strong>中的内容</li>
<li>尝试获取锁 **_imp**</li>
<li>使用模块名称获取_module_locks中的锁对象，如有必要，在position
1中创建</li>
<li>尝试在第3步（position 2）中获取锁定对象</li>
<li>释放锁 **_imp**（position 3）</li>
<li>检查要导入的名称是否在sys.module中，如果是，则释放_module_locks中的锁对象并返回sys.module中的内容（position
4）</li>
<li>对于 <strong>sys.meta_path</strong>中的
<strong>finder</strong>，如果finder可以加载模块名称，请释放_module_locks中的锁对象并返回已加载的内容</li>
<li>raise an error 在position
1，只有拥有_imp的线程才能<strong>修改_module_locks</strong>，当前线程将检查要导入的模块名称是否在_module_locks中，如果不是，则在_module_locks中插入新的锁定对象</li>
</ol>
在position
3，释放_imp锁，如果有其他线程导入其他模块，则它可以获得_imp锁并继续执行该过程，如果有其他线程导入同一模块，即使它成功获取了_imp，也将失败在获取_module_locks中的锁时，因为先前的线程持有该锁
<div style="width:95%;margin:auto">
<img src="/2020/12/16/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-import%E6%A8%A1%E5%9D%97/import_procedure1.png" class title="import_procedure1图">
</div>
<p>在position 4，当前线程再次检查
<strong>sys.modules</strong>中的缓存</p>
在position 5，它将在每个 <strong>finder</strong>调用之前获取
**_imp**锁。在函数调用之后查找并释放它
<div style="width:95%;margin:auto">
<img src="/2020/12/16/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-import%E6%A8%A1%E5%9D%97/import_procedure2.png" class title="import_procedure2图">
</div>
<h3><span id="import-xxx-as-x">import xxx as x</span><a href="#import-xxx-as-x" class="header-anchor">#</a></h3>
定义test.py
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import demo as d</span><br></pre></td></tr></table></figure>
用dis模块编译一下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\liuw\Desktop&gt; python.exe -m dis .\test.py</span><br><span class="line">  1           0 LOAD_CONST               0 (0)</span><br><span class="line">              2 LOAD_CONST               1 (None)</span><br><span class="line">              4 IMPORT_NAME              0 (demo)</span><br><span class="line">              6 STORE_NAME               1 (d)</span><br><span class="line">              8 LOAD_CONST               1 (None)</span><br><span class="line">             10 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<div style="width:95%;margin:auto">
<img src="/2020/12/16/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-import%E6%A8%A1%E5%9D%97/import_as.jpg" class title="import_as图">
</div>
<p>可以看出，这里仅仅是 将模块的名字变为 <strong>d</strong>
了.因此，这个 import 语句变体其实等价于：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import demo</span><br><span class="line">d &#x3D; demo</span><br><span class="line">del demo</span><br></pre></td></tr></table></figure></p>
<h3><span id="from-import">from import</span><a href="#from-import" class="header-anchor">#</a></h3>
<p>定义test.py
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from demo import value</span><br></pre></td></tr></table></figure>
同样用 dis 对语句进行反编译，我们得到以下字节码：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\liuw\Desktop&gt; python.exe -m dis .\test.py</span><br><span class="line">  1           0 LOAD_CONST               0 (0)</span><br><span class="line">              2 LOAD_CONST               1 ((&#39;value&#39;,))</span><br><span class="line">              4 IMPORT_NAME              0 (demo)</span><br><span class="line">              6 IMPORT_FROM              1 (value)   # 从栈顶模块中取出指定名字，并保存于栈顶</span><br><span class="line">              8 STORE_NAME               1 (value)</span><br><span class="line">             10 POP_TOP</span><br><span class="line">             12 LOAD_CONST               2 (None)</span><br><span class="line">             14 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<strong>IMPORT_FROM</strong> 指令:
从栈顶模块中取出指定名字，并保存于栈顶。</p>
<div style="width:95%;margin:auto">
<img src="/2020/12/16/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-import%E6%A8%A1%E5%9D%97/import_from.jpg" class title="import_from图">
</div>
<p>注意到，value 以 元组 的形式保存于栈顶，IMPORT_NAME 指令如果发现
value 为 demo 模块的子模块，将同时加载 value 子模块。此外，IMPORT_FROM
与 STORE_NAME 这两个指令相互配合，从模块中取出给定名字并保存。</p>
<p>仅仅加载了模块下的一部分</p>
<h3><span id="from-import-as">from import as</span><a href="#from-import-as" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;from demo import func as f</span><br><span class="line">C:\Users\liuw\Desktop&gt; python.exe -m dis .\test.py</span><br><span class="line">  1           0 LOAD_CONST               0 (0)</span><br><span class="line">              2 LOAD_CONST               1 ((&#39;func&#39;,))</span><br><span class="line">              4 IMPORT_NAME              0 (demo)</span><br><span class="line">              6 IMPORT_FROM              1 (func)</span><br><span class="line">              8 STORE_NAME               2 (f)   # 存储名字的时候存储的是 f</span><br><span class="line">             10 POP_TOP</span><br><span class="line">             12 LOAD_CONST               2 (None)</span><br><span class="line">             14 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/module.md" title="module">module-github</a></li>
<li><a href="https://www.imooc.com/read/76/article/1918" title="Python 源码深度剖析/22 模块动态加载， import 背后哪些事儿">Python
源码深度剖析/22 模块动态加载， import 背后哪些事儿</a></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] python2.7中的str 和 unicode</title>
    <url>/2021/11/02/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-python2-7%E4%B8%AD%E7%9A%84str-%E5%92%8C-unicode/</url>
    <content><![CDATA[<p>在<a href="http://liuw.tech/2020/12/06/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-6-%E5%AD%97%E7%AC%A6%E4%B8%B2str/">python3中的字符串str/Unicode</a>一文中,
我们可以看到python3+中 str和Unicode是同一个东西；而在python2+中,
他们却不一样。本文以<a href="https://github.com/python/cpython/tree/2.7">python2.7源码</a>为基础进行简单介绍。
<a id="more"></a></p>
<h2><span id="1-str">1. str</span><a href="#1-str" class="header-anchor">#</a></h2>
<h4><span id="1-1-pystringobject-dui-xiang">1.1 PyStringObject对象</span><a href="#1-1-pystringobject-dui-xiang" class="header-anchor">#</a></h4>
<p>在 stringobject.h 中的 35~49行可以看到PyStringObject定义
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    long ob_shash;</span><br><span class="line">    int ob_sstate;</span><br><span class="line">    char ob_sval[1];</span><br><span class="line"></span><br><span class="line">    &#x2F;* Invariants:</span><br><span class="line">     *     ob_sval contains space for &#39;ob_size+1&#39; elements. 最后一位为&#39;\0&#39;</span><br><span class="line">     *     ob_sval[ob_size] &#x3D;&#x3D; 0.</span><br><span class="line">     *     ob_shash is the hash of the string or -1 if not computed yet.</span><br><span class="line">     *     ob_sstate !&#x3D; 0 iff the string object is in stringobject.c&#39;s</span><br><span class="line">     *       &#39;interned&#39; dictionary; in this case the two references</span><br><span class="line">     *       from &#39;interned&#39; to this object are *not counted* in ob_refcnt.</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>ob_shash 是该字符串的<strong>哈希值</strong>，由于 Python
的字典实现大量使用了哈希值，且字典的健多为
PyStringObject，预先计算哈希值并保存可以<strong>加速字典的运算</strong>。</li>
<li>ob_sstate 和字符串对象的 <strong>intern 机制</strong>有关</li>
</ul>
<p>追根溯源, 在<strong>object.h</strong> 中可以
看到PyObject_VAR_HEAD、PyObject_HEAD 、 _PyObject_HEAD_EXTRA 和
_object的定义
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PyObject_VAR_HEAD               \</span><br><span class="line">    PyObject_HEAD                       \</span><br><span class="line">    Py_ssize_t ob_size; &#x2F;* Number of items in variable part *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* PyObject_HEAD defines the initial segment of every PyObject. *&#x2F;</span><br><span class="line">#define PyObject_HEAD                   \</span><br><span class="line">    _PyObject_HEAD_EXTRA                \</span><br><span class="line">    Py_ssize_t ob_refcnt;               \</span><br><span class="line">    struct _typeobject *ob_type;</span><br><span class="line"></span><br><span class="line">&#x2F;* Define pointers to support a doubly-linked list of all live heap objects. 双向链表 *&#x2F;</span><br><span class="line">#define _PyObject_HEAD_EXTRA            \</span><br><span class="line">    struct _object *_ob_next;           \</span><br><span class="line">    struct _object *_ob_prev;</span><br><span class="line"></span><br><span class="line">typedef struct _object &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure></p>
<p>因此，PyStringObject对象结构如下图所示
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml MicroService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PyStringObject &#123;</span><br><span class="line">    -struct _object *_ob_next</span><br><span class="line">    -struct _object *_ob_prev</span><br><span class="line">    -- _PyObject_HEAD_EXTRA↑ --</span><br><span class="line">    +Py_ssize_t ob_refcnt对象引用数</span><br><span class="line">    +struct _typeobject *ob_type</span><br><span class="line">    -- PyObject_HEAD↑  --</span><br><span class="line">    +Py_ssize_t ob_size对象大小</span><br><span class="line">    &#x3D;&#x3D; PyObject_VAR_HEAD↑ &#x3D;&#x3D;</span><br><span class="line">    +long ob_shash</span><br><span class="line">    +int ob_sstate</span><br><span class="line">    +char ob_sval[1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></p>
<h4><span id="1-2-pystring-type-dui-xiang">1.2 PyString_Type对象</span><a href="#1-2-pystring-type-dui-xiang" class="header-anchor">#</a></h4>
<p>在 <strong>stringobject.c</strong>
中的3816~3858行可以找到<strong>PyString_Type</strong>的定义:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyString_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;str&quot;,</span><br><span class="line">    PyStringObject_SIZE,</span><br><span class="line">    sizeof(char),</span><br><span class="line">    string_dealloc,                             &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line">    (printfunc)string_print,                    &#x2F;* tp_print *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_getattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_compare *&#x2F;</span><br><span class="line">    string_repr,                                &#x2F;* tp_repr *&#x2F;</span><br><span class="line">    &amp;string_as_number,                          &#x2F;* tp_as_number *&#x2F;</span><br><span class="line">    &amp;string_as_sequence,                        &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    &amp;string_as_mapping,                         &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc)string_hash,                      &#x2F;* tp_hash 哈希方法*&#x2F; </span><br><span class="line">    0,                                          &#x2F;* tp_call *&#x2F;</span><br><span class="line">    string_str,                                 &#x2F;* tp_str *&#x2F;</span><br><span class="line">    PyObject_GenericGetAttr,                    &#x2F;* tp_getattro *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattro *&#x2F;</span><br><span class="line">    &amp;string_as_buffer,                          &#x2F;* tp_as_buffer *&#x2F;</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_STRING_SUBCLASS |</span><br><span class="line">        Py_TPFLAGS_HAVE_NEWBUFFER,              &#x2F;* tp_flags *&#x2F;</span><br><span class="line">    string_doc,                                 &#x2F;* tp_doc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_traverse *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_clear *&#x2F;</span><br><span class="line">    (richcmpfunc)string_richcompare,            &#x2F;* tp_richcompare 比较方法*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_weaklistoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iter *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_iternext *&#x2F;</span><br><span class="line">    string_methods,                             &#x2F;* tp_methods 包含了join、split、lower、endwith、replace等方法的定义*&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_members *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_getset *&#x2F;</span><br><span class="line">    &amp;PyBaseString_Type,                         &#x2F;* tp_base *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dict *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_get *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_descr_set *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_dictoffset *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_init *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_alloc *&#x2F;</span><br><span class="line">    string_new,                                 &#x2F;* tp_new *&#x2F;</span><br><span class="line">    PyObject_Del,                               &#x2F;* tp_free *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4><span id="1-3-pystring-fromstring-fang-fa">1.3 PyString_FromString方法</span><a href="#1-3-pystring-fromstring-fang-fa" class="header-anchor">#</a></h4>
<p>最底层的生成字符串的函数方法为 <strong>PyString_FromString</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; stringobject.c</span><br><span class="line">PyObject *</span><br><span class="line">PyString_FromString(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    size &#x3D; strlen(str);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;* Inline PyObject_NewVar *&#x2F;</span><br><span class="line">    op &#x3D; (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size);</span><br><span class="line">    if (op &#x3D;&#x3D; NULL)</span><br><span class="line">        return PyErr_NoMemory();</span><br><span class="line">    (void)PyObject_INIT_VAR(op, &amp;PyString_Type, size);</span><br><span class="line">    op-&gt;ob_shash &#x3D; -1;                    # 暂不计算哈希值(使用时才计算 lazy_init)</span><br><span class="line">    op-&gt;ob_sstate &#x3D; SSTATE_NOT_INTERNED;  # 暂不使用intern 机制</span><br><span class="line">    Py_MEMCPY(op-&gt;ob_sval, str, size+1);  &#x2F;&#x2F; 将**原始C字串**拷贝给 ob_sval字段</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该函数根据原始的 C 语言const char *str生成对应的
PyStringObject。原始字符串被复制到 ob_sval 中。</p>
<h4><span id="1-4-intern-ji-zhi">1.4 intern 机制</span><a href="#1-4-intern-ji-zhi" class="header-anchor">#</a></h4>
<p>str的intern 机制 类似于
小整数对象池，即若<strong>两个str对象的原始字符串</strong>相同，那么其
<strong>ob_sval 共享同一份内存</strong>。若程序中出现了 100 次 hello,
world，那么在内存中只会保存一份。</p>
<p>intern 机制的核心在于字典 interned。该字典为 Python
的内建数据结构，可以简单等价于 C++ 的
map&lt;T,R&gt;。该字典的健值都为字符串本身 pystring:pystring，所有需
intern 的字符串会缓存到该 interned 字典中，当在程序中再遇到相同的字符串
pystring，便可通过字典在 O(1) 时间内检索出。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; stringobject.c</span><br><span class="line">PyObject *</span><br><span class="line">PyString_FromString(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;* share short strings *&#x2F;</span><br><span class="line">    if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        PyObject *t &#x3D; (PyObject *)op;</span><br><span class="line">        PyString_InternInPlace(&amp;t);</span><br><span class="line">        op &#x3D; (PyStringObject *)t;</span><br><span class="line">        nullstring &#x3D; op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125; else if (size &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        PyObject *t &#x3D; (PyObject *)op;</span><br><span class="line">        PyString_InternInPlace(&amp;t);</span><br><span class="line">        op &#x3D; (PyStringObject *)t;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] &#x3D; op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="zi-fu-chuan-pin-jie">字符串拼接</span><a href="#zi-fu-chuan-pin-jie" class="header-anchor">#</a></h4>
<p>字符串虽然是<strong>变长对象</strong>，但<strong>并不是可变对象</strong>，创建之后，ob_sval
数组的长度无法再改变。在拼接两个字符串 s1, s2 时，必须重新生成一个
PyStringObject 对象来放置 s1-&gt;ob_sval + s2-&gt;sval。如果要连接 N 个
PyStringObject 对象，那么就必须进行 N-1
次的内存申请及内存搬运的工作。毫无疑问，这将严重影响 Python
的执行效率。</p>
<p>所以官方推荐的做法是使用 join
函数，该函数一次性分配好所有内存，然后统一搬运。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;-&quot;</span><br><span class="line">seq &#x3D; (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">print s.join( seq )</span><br></pre></td></tr></table></figure></p>
<h2><span id="2-unicode">2.Unicode</span><a href="#2-unicode" class="header-anchor">#</a></h2>
<h4><span id="2-1-pyunicodeobject">2.1 PyUnicodeObject</span><a href="#2-1-pyunicodeobject" class="header-anchor">#</a></h4>
<p>在 unicodeobject.h 中的 415~423行可以看到PyUnicodeObject定义如下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t length;          &#x2F;* Length of raw Unicode data in buffer *&#x2F;</span><br><span class="line">    Py_UNICODE *str;            &#x2F;* Raw Unicode buffer *&#x2F;</span><br><span class="line">    long hash;                  &#x2F;* Hash value; -1 if not set *&#x2F;</span><br><span class="line">    PyObject *defenc;           &#x2F;* (Default) Encoded version as Python</span><br><span class="line">                                   string, or NULL; this is used for</span><br><span class="line">                                   implementing the buffer protocol *&#x2F;</span><br><span class="line">&#125; PyUnicodeObject;</span><br></pre></td></tr></table></figure></p>
<p>照葫芦画瓢，PyUnicodeObject结构如下图所示
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml MicroService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PyUnicodeObject &#123;</span><br><span class="line">    -struct _object *_ob_next</span><br><span class="line">    -struct _object *_ob_prev</span><br><span class="line">    -- _PyObject_HEAD_EXTRA↑ --</span><br><span class="line">    +Py_ssize_t ob_refcnt对象引用数</span><br><span class="line">    +struct _typeobject *ob_type</span><br><span class="line">    &#x3D;&#x3D; PyObject_HEAD↑  &#x3D;&#x3D;</span><br><span class="line">    +Py_ssize_t length    &#x2F;* Length of raw Unicode data in buffer *&#x2F;</span><br><span class="line">    +Py_UNICODE *str      &#x2F;* Raw Unicode buffer *&#x2F;</span><br><span class="line">    +long hash           &#x2F;* Hash value; -1 if not set *&#x2F;</span><br><span class="line">    +PyObject *defenc   &#x2F;*编码后的对象指针, 可能是assci、utf-8、latin-1 or mbcs格式, 默认为assci*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@enduml</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4><span id="2-2-pyunicode-type">2.2 PyUnicode_Type</span><a href="#2-2-pyunicode-type" class="header-anchor">#</a></h4>
<p>在 <strong>unicodeobject.c</strong>
中的8902~8904行可以找到<strong>PyUnicode_Type</strong>的定义:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyUnicode_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;unicode&quot;,              &#x2F;* tp_name *&#x2F;</span><br><span class="line">    sizeof(PyUnicodeObject),        &#x2F;* tp_size *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    &#x2F;* Slots *&#x2F;</span><br><span class="line">    (destructor)unicode_dealloc,    &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_print *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_getattr *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_setattr *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_compare *&#x2F;</span><br><span class="line">    unicode_repr,           &#x2F;* tp_repr *&#x2F;</span><br><span class="line">    &amp;unicode_as_number,         &#x2F;* tp_as_number *&#x2F;</span><br><span class="line">    &amp;unicode_as_sequence,       &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    &amp;unicode_as_mapping,        &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line">    (hashfunc) unicode_hash,        &#x2F;* tp_hash哈希方法*&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_call*&#x2F;</span><br><span class="line">    (reprfunc) unicode_str,     &#x2F;* tp_str 转换为str的方法*&#x2F;</span><br><span class="line">    PyObject_GenericGetAttr,        &#x2F;* tp_getattro *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_setattro *&#x2F;</span><br><span class="line">    &amp;unicode_as_buffer,         &#x2F;* tp_as_buffer *&#x2F;</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |</span><br><span class="line">    Py_TPFLAGS_BASETYPE | Py_TPFLAGS_UNICODE_SUBCLASS,  &#x2F;* tp_flags *&#x2F;</span><br><span class="line">    unicode_doc,            &#x2F;* tp_doc *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_traverse *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_clear *&#x2F;</span><br><span class="line">    PyUnicode_RichCompare,      &#x2F;* tp_richcompare *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_weaklistoffset *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_iter *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_iternext *&#x2F;</span><br><span class="line">    unicode_methods,            &#x2F;* tp_methods 包含了encode、split、join、endwith、replace等方法的定义*&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_members *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_getset *&#x2F;</span><br><span class="line">    &amp;PyBaseString_Type,         &#x2F;* tp_base *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_dict *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_descr_get *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_descr_set *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_dictoffset *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_init *&#x2F;</span><br><span class="line">    0,                  &#x2F;* tp_alloc *&#x2F;</span><br><span class="line">    unicode_new,            &#x2F;* tp_new *&#x2F;</span><br><span class="line">    PyObject_Del,           &#x2F;* tp_free *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://www.lyyyuna.com/2017/12/28/python-internal3-string-object/">Python
2.7 源码 - 字符串对象</a></li>
</ol>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] random模块解析</title>
    <url>/2021/08/17/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-random%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>本文将从random seed 入手，分析python中如何实现random的 <a id="more"></a>
## 1、 random seed种子 ### 1.1、示例代码 先看一段代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.seed(10)</span><br><span class="line">a &#x3D; set([random.random() for i in range(1000)])</span><br><span class="line"></span><br><span class="line">random.seed(10)</span><br><span class="line">b &#x3D; set([random.random() for i in range(1000)])</span><br><span class="line"></span><br><span class="line">print len(a), len(b), a&#x3D;&#x3D;b</span><br></pre></td></tr></table></figure>
输出为
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 1000 True</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出,
random其实产生的是<strong>伪随机序列</strong>。当<strong>seed种子一样时,输出将会一模一样</strong></p>
<h3><span id="1-2-random-py-wen-jian-zhong-de-seed">1.2、 random.py文件中的seed</span><a href="#1-2-random-py-wen-jian-zhong-de-seed" class="header-anchor">#</a></h3>
我们来看下random.py文件的seed 方法
<div style="width:100%;margin:auto">
<img src="/2021/08/17/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-random%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/random_py.png" class title="random_py图">
</div>
<p>我们可以看到 - 用户可以自定以a; - 若没有自定义a，则尝试调用
**_urandom<strong>(16)生成a - 若调用失败,使用</strong>time.time()** *
256 生成</p>
<h3><span id="1-3-randommodule-yuan-ma">1.3、 _randommodule源码</span><a href="#1-3-randommodule-yuan-ma" class="header-anchor">#</a></h3>
<p>接下来, 将a传入<strong>Random父类的seed。</strong>
_random.Random是什么呢？ 我们在cpython源码
**Modules/_randommodule.c<strong>能找到答案
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyMethodDef random_methods[] &#x3D; &#123;</span><br><span class="line">    _RANDOM_RANDOM_RANDOM_METHODDEF</span><br><span class="line">    _RANDOM_RANDOM_SEED_METHODDEF</span><br><span class="line">    _RANDOM_RANDOM_GETSTATE_METHODDEF</span><br><span class="line">    _RANDOM_RANDOM_SETSTATE_METHODDEF</span><br><span class="line">    _RANDOM_RANDOM_GETRANDBITS_METHODDEF</span><br><span class="line">    &#123;NULL,              NULL&#125;           &#x2F;* sentinel *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
以</strong>_RANDOM_RANDOM_RANDOM_METHODDEF**为例，找出其定义如下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _RANDOM_RANDOM_RANDOM_METHODDEF    \</span><br><span class="line">    &#123;&quot;random&quot;, (PyCFunction)_random_Random_random, METH_NOARGS, _random_Random_random__doc__&#125;,</span><br></pre></td></tr></table></figure>
照葫芦画瓢, 将上面的宏逐一替换：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyMethodDef random_methods[] &#x3D; &#123;</span><br><span class="line">    &#123;&quot;random&quot;, (PyCFunction)_random_Random_random, METH_NOARGS, _random_Random_random__doc__&#125;,</span><br><span class="line">    &#123;&quot;seed&quot;, (PyCFunction)(void(*)(void))_random_Random_seed, METH_FASTCALL, _random_Random_seed__doc__&#125;,</span><br><span class="line">    &#123;&quot;getstate&quot;, (PyCFunction)_random_Random_getstate, METH_NOARGS, _random_Random_getstate__doc__&#125;,</span><br><span class="line">    &#123;&quot;setstate&quot;, (PyCFunction)_random_Random_setstate, METH_O, _random_Random_setstate__doc__&#125;,</span><br><span class="line">    &#123;&quot;getrandbits&quot;, (PyCFunction)_random_Random_getrandbits, METH_O, _random_Random_getrandbits__doc__&#125;,</span><br><span class="line">    &#123;NULL,              NULL&#125;           &#x2F;* sentinel *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
random c语言</p>
<h3><span id="1-4-randomobject">1.4、 RandomObject</span><a href="#1-4-randomobject" class="header-anchor">#</a></h3>
<p>首先我们来了解下RandomObject对象
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define N 624</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int index; </span><br><span class="line">    uint32_t state[N]; </span><br><span class="line">&#125; RandomObject;</span><br></pre></td></tr></table></figure>
RandomObject由三部分构成： - PyObject_HEAD： 公共头部 - index：
存储当前对应的state索引 - 大小为624的uint32_t数组,
调用random.seed就会初始化一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">_random_Random_seed(RandomObject *self, PyObject *const *args, Py_ssize_t nargs)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *return_value &#x3D; NULL;</span><br><span class="line">    PyObject *n &#x3D; Py_None;</span><br><span class="line"></span><br><span class="line">    if (!_PyArg_CheckPositional(&quot;seed&quot;, nargs, 0, 1)) &#123;</span><br><span class="line">        goto exit;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nargs &lt; 1) &#123;</span><br><span class="line">        goto skip_optional;</span><br><span class="line">    &#125;</span><br><span class="line">    n &#x3D; args[0];</span><br><span class="line">skip_optional:</span><br><span class="line">    return_value &#x3D; _random_Random_seed_impl(self, n); &#x2F;&#x2F;调用_random_Random_seed_impl</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">    return return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上_random_Random_seed做一些校验后，会调用
**_random_Random_seed_impl**(self, n)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">_random_Random_seed_impl(RandomObject *self, PyObject *n)</span><br><span class="line">&#x2F;*[clinic end generated code: output&#x3D;0fad1e16ba883681 input&#x3D;78d6ef0d52532a54]*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    return random_seed(self, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>顺藤摸瓜, 看一下random_seed
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">random_seed(RandomObject *self, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result &#x3D; NULL;            &#x2F;* guilty until proved innocent *&#x2F;</span><br><span class="line">    PyObject *n &#x3D; NULL;</span><br><span class="line">    uint32_t *key &#x3D; NULL;</span><br><span class="line">    size_t bits, keyused;</span><br><span class="line">    int res;</span><br><span class="line"></span><br><span class="line">    if (arg &#x3D;&#x3D; NULL || arg &#x3D;&#x3D; Py_None) &#123;</span><br><span class="line">       if (random_seed_urandom(self) &lt; 0) &#123;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line"></span><br><span class="line">            &#x2F;* Reading system entropy failed, fall back on the worst entropy:</span><br><span class="line">               use the current time and process identifier. *&#x2F;</span><br><span class="line">            random_seed_time_pid(self);</span><br><span class="line">        &#125;</span><br><span class="line">        Py_RETURN_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* This algorithm relies on the number being unsigned.</span><br><span class="line">     * So: if the arg is a PyLong, use its absolute value.</span><br><span class="line">     * Otherwise use its hash value, cast to unsigned.</span><br><span class="line">     * 对传入的seed值进行处理，取绝对值 or hash值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (PyLong_CheckExact(arg)) &#123;</span><br><span class="line">        n &#x3D; PyNumber_Absolute(arg);</span><br><span class="line">    &#125; else if (PyLong_Check(arg)) &#123;</span><br><span class="line">        &#x2F;* Calling int.__abs__() prevents calling arg.__abs__(), which might</span><br><span class="line">           return an invalid value. See issue #31478. *&#x2F;</span><br><span class="line">        n &#x3D; PyObject_CallOneArg(_randomstate_global-&gt;Long___abs__, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Py_hash_t hash &#x3D; PyObject_Hash(arg);</span><br><span class="line">        if (hash &#x3D;&#x3D; -1)</span><br><span class="line">            goto Done;</span><br><span class="line">        n &#x3D; PyLong_FromSize_t((size_t)hash);</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; NULL)</span><br><span class="line">        goto Done;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Now split n into 32-bit chunks, from the right. *&#x2F;</span><br><span class="line">    bits &#x3D; _PyLong_NumBits(n);</span><br><span class="line">    if (bits &#x3D;&#x3D; (size_t)-1 &amp;&amp; PyErr_Occurred())</span><br><span class="line">        goto Done;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Figure out how many 32-bit chunks this gives us. *&#x2F;</span><br><span class="line">    keyused &#x3D; bits &#x3D;&#x3D; 0 ? 1 : (bits - 1) &#x2F; 32 + 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Convert seed to byte sequence. seed转换为字节流*&#x2F;</span><br><span class="line">    key &#x3D; (uint32_t *)PyMem_Malloc((size_t)4 * keyused);</span><br><span class="line">    if (key &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        goto Done;</span><br><span class="line">    &#125;</span><br><span class="line">    res &#x3D; _PyLong_AsByteArray((PyLongObject *)n,</span><br><span class="line">                              (unsigned char *)key, keyused * 4,</span><br><span class="line">                              PY_LITTLE_ENDIAN,</span><br><span class="line">                              0); &#x2F;* unsigned *&#x2F;</span><br><span class="line">    if (res &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        goto Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if PY_BIG_ENDIAN</span><br><span class="line">    &#123;</span><br><span class="line">        size_t i, j;</span><br><span class="line">        &#x2F;* Reverse an array. *&#x2F;</span><br><span class="line">        for (i &#x3D; 0, j &#x3D; keyused - 1; i &lt; j; i++, j--) &#123;</span><br><span class="line">            uint32_t tmp &#x3D; key[i];</span><br><span class="line">            key[i] &#x3D; key[j];</span><br><span class="line">            key[j] &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    init_by_array(self, key, keyused); &#x2F;&#x2F; 设置seed到self对象中</span><br><span class="line"></span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    result &#x3D; Py_None;</span><br><span class="line"></span><br><span class="line">Done:</span><br><span class="line">    Py_XDECREF(n);</span><br><span class="line">    PyMem_Free(key);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面一大堆校验和计算，最后将传入的<strong>seed参数arg</strong>
会被转换为
<strong>key(字节流形式)</strong>，然后传入<strong>init_by_array</strong>函数中。继续看下init_by_array函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">init_by_array(RandomObject *self, uint32_t init_key[], size_t key_length)</span><br><span class="line">&#123;</span><br><span class="line">    size_t i, j, k;       &#x2F;* was signed in the original code. RDH 12&#x2F;16&#x2F;2002 *&#x2F;</span><br><span class="line">    uint32_t *mt;</span><br><span class="line"></span><br><span class="line">    mt &#x3D; self-&gt;state;</span><br><span class="line">    init_genrand(self, 19650218U);</span><br><span class="line">    i&#x3D;1; j&#x3D;0;</span><br><span class="line">    k &#x3D; (N&gt;key_length ? N : key_length);</span><br><span class="line">    &#x2F;&#x2F; 根据传入的init_key数组, 初始化self-&gt;state</span><br><span class="line">    for (; k; k--) &#123;</span><br><span class="line">        mt[i] &#x3D; (mt[i] ^ ((mt[i-1] ^ (mt[i-1] &gt;&gt; 30)) * 1664525U))</span><br><span class="line">                 + init_key[j] + (uint32_t)j; &#x2F;* non linear *&#x2F;</span><br><span class="line">        i++; j++;</span><br><span class="line">        if (i&gt;&#x3D;N) &#123; mt[0] &#x3D; mt[N-1]; i&#x3D;1; &#125;</span><br><span class="line">        if (j&gt;&#x3D;key_length) j&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (k&#x3D;N-1; k; k--) &#123;</span><br><span class="line">        mt[i] &#x3D; (mt[i] ^ ((mt[i-1] ^ (mt[i-1] &gt;&gt; 30)) * 1566083941U))</span><br><span class="line">                 - (uint32_t)i; &#x2F;* non linear *&#x2F;</span><br><span class="line">        i++;</span><br><span class="line">        if (i&gt;&#x3D;N) &#123; mt[0] &#x3D; mt[N-1]; i&#x3D;1; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mt[0] &#x3D; 0x80000000U; &#x2F;* MSB is 1; assuring non-zero initial array *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到,
该函数根据传入的init_key数组，设置RandomObject的state数组（大小为N =
624）。 阅读至此，我们可以得出如下结论： -
RandomObject对象由公共头部、index 和
state(大小为624的uint32_t)数组组成。 - 调用py文件中的random.seed(xxx),
经过一系列的校验和计算，最终<strong>设置state数组</strong>，这个数组<strong>使random实现伪随机</strong>
-
传入<strong>同样的seed,state数组一致</strong>，随机的<strong>结果也会一致</strong>
-
不传默认参数时，通过time.time等机制实现对seed的随机，从而实现state数组不一致。
-
seed的参数，必须为<strong>Long型</strong>或<strong>可哈希</strong>类型</p>
<h2><span id="2-random-random">2. random.random</span><a href="#2-random-random" class="header-anchor">#</a></h2>
<p>趁热打铁，我们看一波random.random的原理
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">_random_Random_random(RandomObject *self, PyObject *Py_UNUSED(ignored))</span><br><span class="line">&#123;</span><br><span class="line">    return _random_Random_random_impl(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
继续追击_random_Random_random_impl
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">_random_Random_random_impl(RandomObject *self)</span><br><span class="line">&#x2F;*[clinic end generated code: output&#x3D;117ff99ee53d755c input&#x3D;afb2a59cbbb00349]*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t a&#x3D;genrand_uint32(self)&gt;&gt;5, b&#x3D;genrand_uint32(self)&gt;&gt;6;</span><br><span class="line">    return PyFloat_FromDouble((a*67108864.0+b)*(1.0&#x2F;9007199254740992.0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
具体算法就不细究了,这里生成a,b两个数，使用了一个关键的函数<strong>genrand_uint32</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Period parameters -- These are all magic.  Don&#39;t change. *&#x2F;</span><br><span class="line">#define N 624</span><br><span class="line">#define M 397</span><br><span class="line">#define MATRIX_A 0x9908b0dfU    &#x2F;* constant vector a *&#x2F;</span><br><span class="line">#define UPPER_MASK 0x80000000U  &#x2F;* most significant w-r bits *&#x2F;</span><br><span class="line">#define LOWER_MASK 0x7fffffffU  &#x2F;* least significant r bits *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* generates a random number on [0,0xffffffff]-interval *&#x2F;</span><br><span class="line">static uint32_t</span><br><span class="line">genrand_uint32(RandomObject *self)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t y;</span><br><span class="line">    static const uint32_t mag01[2] &#x3D; &#123;0x0U, MATRIX_A&#125;;</span><br><span class="line">    &#x2F;* mag01[x] &#x3D; x * MATRIX_A  for x&#x3D;0,1 *&#x2F;</span><br><span class="line">    uint32_t *mt;</span><br><span class="line"></span><br><span class="line">    mt &#x3D; self-&gt;state;、</span><br><span class="line">    &#x2F;&#x2F; 越界了，重新计算state数组</span><br><span class="line">    if (self-&gt;index &gt;&#x3D; N) &#123; &#x2F;* generate N words at one time *&#x2F;</span><br><span class="line">        int kk;</span><br><span class="line"></span><br><span class="line">        for (kk&#x3D;0;kk&lt;N-M;kk++) &#123;</span><br><span class="line">            y &#x3D; (mt[kk]&amp;UPPER_MASK)|(mt[kk+1]&amp;LOWER_MASK);</span><br><span class="line">            mt[kk] &#x3D; mt[kk+M] ^ (y &gt;&gt; 1) ^ mag01[y &amp; 0x1U];</span><br><span class="line">        &#125;</span><br><span class="line">        for (;kk&lt;N-1;kk++) &#123;</span><br><span class="line">            y &#x3D; (mt[kk]&amp;UPPER_MASK)|(mt[kk+1]&amp;LOWER_MASK);</span><br><span class="line">            mt[kk] &#x3D; mt[kk+(M-N)] ^ (y &gt;&gt; 1) ^ mag01[y &amp; 0x1U];</span><br><span class="line">        &#125;</span><br><span class="line">        y &#x3D; (mt[N-1]&amp;UPPER_MASK)|(mt[0]&amp;LOWER_MASK);</span><br><span class="line">        mt[N-1] &#x3D; mt[M-1] ^ (y &gt;&gt; 1) ^ mag01[y &amp; 0x1U];</span><br><span class="line">        &#x2F;&#x2F;初始化index</span><br><span class="line">        self-&gt;index &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y &#x3D; mt[self-&gt;index++]; </span><br><span class="line">    y ^&#x3D; (y &gt;&gt; 11);</span><br><span class="line">    y ^&#x3D; (y &lt;&lt; 7) &amp; 0x9d2c5680U;</span><br><span class="line">    y ^&#x3D; (y &lt;&lt; 15) &amp; 0xefc60000U;</span><br><span class="line">    y ^&#x3D; (y &gt;&gt; 18);</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面函数可以总结为： - 取完state[index]的值后, index 加 1,
并经过一系列固定步骤的计算得到返回值 -
若index大于N时，使用一系列复杂的算法重新计算state数组，并将index置为0</p>
<h2><span id="3-pai-keng">3. 排坑</span><a href="#3-pai-keng" class="header-anchor">#</a></h2>
<p>如下是一个可指定rand的函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_rand(seed&#x3D;None):</span><br><span class="line">    random.seed(seed)</span><br><span class="line">    return random.random()</span><br></pre></td></tr></table></figure>
结合上面的seed函数分析, random其实都是<strong>伪随机算法</strong> -
若不同时间多次调用, 传入一样的seed时, state数组就会一致, 且index从0开始,
导致<strong>随机输出</strong>很可能就会<strong>一致</strong> -
对于强随机算法，这个就会出bug。而且random在一个进程中只存在一个object，这样会<strong>影响全局的随机概率</strong>。</p>
<p><strong>修复思路</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_rand(seed&#x3D;None):</span><br><span class="line">    random.seed(seed)</span><br><span class="line">    result &#x3D; random.random()</span><br><span class="line">    random.seed()  &#x2F;&#x2F;重新随机seed一波</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[ssh] 多个ssh密钥,如何指定?</title>
    <url>/2021/04/07/ssh-%E5%A4%9A%E4%B8%AAssh%E5%AF%86%E9%92%A5-%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A/</url>
    <content><![CDATA[<h2><span id="ru-he-sheng-cheng-mi-yao">如何生成密钥？</span><a href="#ru-he-sheng-cheng-mi-yao" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ssh-keygen -t rsa -C ‘xxxxx@company.com’ -f ~&#x2F;.ssh&#x2F;id_rsa_gitlab</span><br></pre></td></tr></table></figure>
<p><strong>-f</strong> : 指定生成密钥的位置 和 命名(可选)
<strong>-t</strong> ：指定密钥生成的算法(可选) <strong>-C</strong> :
指定账号(可选)</p>
<h2><span id="duo-ge-ssh-mi-yao-ru-he-zhi-ding">多个ssh密钥,如何指定</span><a href="#duo-ge-ssh-mi-yao-ru-he-zhi-ding" class="header-anchor">#</a></h2>
<p>windows下ssh密钥文件在 Users.ssh, 系统默认会取
<strong>id_rsa</strong> 作为密钥文件。</p>
<p>对<strong>不同ip or 网址</strong>,如果需要指定使用
哪个密钥文件,只需要修改 **Users.ssh*, 如：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host 192.168.xx.xx</span><br><span class="line">  HostName 192.168.xx.xx</span><br><span class="line">  User leo</span><br><span class="line">  Port 4000</span><br><span class="line">  IdentityFile &quot;C:\Users\liuwen03\.ssh\id_rsa_liuwen03&quot;</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User liuwen</span><br><span class="line">  IdentityFile &quot;C:\Users\liuwen03\.ssh\id_rsa_github&quot;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>[python源码分析] 装饰器</title>
    <url>/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p>要了解装饰器，首先我们来看看嵌套函数 ## 嵌套函数
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def adder(n):</span><br><span class="line">    def handler(x):</span><br><span class="line">        return n+x</span><br><span class="line">    return handler    #返回的是一个函数的引用</span><br></pre></td></tr></table></figure>
像 adder 函数和 handler
这样，在一个函数的函数体内定义另一个函数，就构成了 嵌套函数
。adder-handler 这段简单的代码包含了 3 个不同的作用域：</p>
<div style="width:80%;margin:auto">
<img src="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/wrapper_func.jpg" class title="wrapper_func图">
</div>
<p>作用域是一个 <strong>静态概念</strong>，由 Python
代码语法决定，与编译后产生的 代码对象
一一对应。作用域规定了能够被某个代码块访问的变量有哪些，但对变量具体的值则一概不关心。</p>
<p>一旦 Python 程序开始运行，<strong>虚拟机</strong>需要为
<strong>作用域中的变量</strong> 分配一定的
<strong>存储空间</strong>，这就是 <strong>名字空间</strong>
。名字空间依照作用域规则实现，它
<strong>决定了某个变量在运行时的取值</strong>，可以看做是
<strong>作用域在运行时的动态表现</strong>方式。</p>
<p>当 <strong>adder 函数执行</strong>时，作用域 A 在虚拟机中表现为 全局
名字空间，作用域 B 表现为 局部 名字空间：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">globals: adder</span><br><span class="line">locals: n, handler</span><br></pre></td></tr></table></figure>
当 <strong>handler 函数执行</strong>时，例如调用 adder(10) 时，作用域 A
在虚拟机中表现为 <strong>全局 名字空间</strong>，作用域 B 表现为
<strong>闭包 名字空间</strong>：作用域 C 表现为 <strong>局部
名字空间</strong>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">globals: adder</span><br><span class="line">locals: x</span><br><span class="line">enclosure: n</span><br></pre></td></tr></table></figure></p>
<h2><span id="bi-bao">闭包</span><a href="#bi-bao" class="header-anchor">#</a></h2>
<h3><span id="shi-me-shi-bi-bao-ni">什么是闭包呢？</span><a href="#shi-me-shi-bi-bao-ni" class="header-anchor">#</a></h3>
<p><strong>闭包 ( closure )</strong> 是 <strong>词法闭包 ( Lexical
Closure )</strong> 的简称，指
<strong>延伸了作用域的函数</strong>，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。简单来说就是
<strong>嵌套函数引用了外层函数的变量</strong>。这些被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p>
<p>首先我们来看看adder(10)示例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add10 &#x3D; adder(10)</span><br><span class="line">&gt;&gt;&gt; add10(10)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; add10(15)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
观察上面的例子，当函数 adder 返回，<strong>局部变量 n
应该就被回收了</strong>，为什么 <strong>handler
函数还能访问到它呢</strong>？这正是由于
<strong>闭包空间</strong>的存在。</p>
<p>以 adder(10) 为例，它是一个 handler 函数对象，闭包变量 n 值总是 10
。那么，内层函数是如何访问闭包作用域的呢？我们对函数代码对象进行反汇编，从中可以看出端倪：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add10 &#x3D; adder(10)</span><br><span class="line">&gt;&gt;&gt; add10</span><br><span class="line">&lt;function adder.&lt;locals&gt;.handler at 0x10dc2b6a8&gt;</span><br><span class="line">&gt;&gt;&gt; add10.__code__</span><br><span class="line">&lt;code object handler at 0x10dbe5150, file &quot;&lt;stdin&gt;&quot;, line 2&gt;</span><br><span class="line">&gt;&gt;&gt; dis.dis(add10.__code__)</span><br><span class="line">  3           0 LOAD_DEREF               0 (n)      # 执行了闭包变量(藏于 PyFrameObject)查找工作</span><br><span class="line">              2 LOAD_FAST                0 (x)      # 局部变量(栈帧对象中)查找</span><br><span class="line">              4 BINARY_ADD</span><br><span class="line">              6 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>PyFrameObject 结构体最后部分是不固定的，依次存放着
<strong>静态局部名字空间、闭包名字空间以及临时栈</strong>。以 add10(1)
为例，函数运行时 PyFrameObject 状态如下如下：</p>
<div style="width:80%;margin:auto">
<img src="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/add10%E5%AE%9E%E4%BE%8B.jpg" class title="add10实例图">
</div>
<p>由于函数 <strong>局部变量、闭包变量个数</strong> 在
<strong>编译阶段</strong> 就能
<strong>确定</strong>，<strong>运行时并不会增减</strong>，因此
<strong>无须用 dict 对象来保存</strong>。相反，将这些变量依次排列
<strong>保存在数组</strong>中，然后通过数组下标来访问即可。这就是所谓的
<strong>静态名字空间</strong>。</p>
<p>对于局部变量 n ，数组对应的槽位保存着整数对象 1 的地址，表示 n 与 1
绑定。而闭包变量 x 则略有差别，槽位 <strong>不直接保存整数对象</strong>
10 ，而是通过一个 <strong>PyCellObject 间接</strong>与整数对象 10
绑定。</p>
<h3><span id="bi-bao-bian-liang-ru-he-chu-shi-hua">闭包变量如何初始化</span><a href="#bi-bao-bian-liang-ru-he-chu-shi-hua" class="header-anchor">#</a></h3>
<p>函数对象 <strong>PyFunctionObject</strong> 中有一个字段
<strong>func_closure</strong> ，保存着函数
<strong>所有闭包变量</strong>。我们可以通过名字
<strong><strong>closure</strong></strong> 可以 <strong>访问</strong>
到这个底层结构体字段：</p>
<blockquote>
<blockquote>
<blockquote>
<p>add10.__closure__ (&lt;cell at 0x10dc09e28: int object at
0x10da161a0&gt;,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>这是一个由 *<strong>PyCellObject</strong> 组成的
<strong>元组</strong>，PyCellObject 则
<strong>保存着闭包变量的值</strong>。当函数调用发生时，Python 虚拟机创建
<strong>PyFrameObject 对象</strong>，并从
<strong>函数对象取出该元组，依次填充相关静态槽位</strong>。</p>
<div style="width:80%;margin:auto">
<img src="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%B8%A7.jpg" class title="闭包与运行帧图">
</div>
<h3><span id="wei-shi-me-bi-bao-bian-liang-yao-tong-guo-pycellobject-jian-jie-yin-yong">为什么闭包变量要通过
PyCellObject 间接引用?</span><a href="#wei-shi-me-bi-bao-bian-liang-yao-tong-guo-pycellobject-jian-jie-yin-yong" class="header-anchor">#</a></h3>
<p>最新的 Python(3.7+) 提供了 <strong>nonlocal</strong> 关键字，支持
<strong>修改闭包变量</strong>。如果没有 PyCellObject ，函数在运行时
<strong>直接修改 PyFrameObject</strong>
，<strong>函数返回就被回收了</strong>。借助 PyCellObject
，<strong>函数在运行时修改的是 ob_ref</strong>
。这样一来，<strong>就算函数返回，修改还是随函数而存在</strong>。</p>
<h3><span id="shi-li-li-jie">示例理解</span><a href="#shi-li-li-jie" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; []</span><br><span class="line">for i in arange(5):</span><br><span class="line">  def f ():</span><br><span class="line">    print (i)</span><br><span class="line">  print (f)</span><br><span class="line">  lst.append(f)</span><br><span class="line"></span><br><span class="line">for f in lst:</span><br><span class="line">  f()  </span><br></pre></td></tr></table></figure>
<p>输出为
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;function f at 0x000001E36692FE58&gt;  &#x2F;&#x2F;函数对象是动态生成的</span><br><span class="line">&lt;function f at 0x000001E366949048&gt;</span><br><span class="line">&lt;function f at 0x000001E36694E798&gt;</span><br><span class="line">&lt;function f at 0x000001E36694E4C8&gt;</span><br><span class="line">&lt;function f at 0x000001E36694E708&gt;</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
这是因为 <strong>闭包变量</strong>是通过 <strong>PyCellObject
间接引用</strong>，PyCellObject中的
ob_ref指针指向了i这个对象，而i最后变成了4。</p>
<p>若要正常输出0，1，2，3，4，应该怎么修改呢？
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; []</span><br><span class="line">for i in arange(5):</span><br><span class="line">  def f (i &#x3D; i):</span><br><span class="line">    print (i)</span><br><span class="line">  lst.append(f)</span><br><span class="line"></span><br><span class="line">for f in lst:</span><br><span class="line">  f()  </span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>这里的i是局部变量</p>
<h2><span id="zhuang-shi-qi">装饰器</span><a href="#zhuang-shi-qi" class="header-anchor">#</a></h2>
<p>前面我们了解了 <strong>嵌套函数和闭包</strong>，我们可以
<strong>让函数具备搭积木的魔法</strong>，例如：打印函数的执行时间。</p>
<p>事不宜迟，我们来实践一下，实现 timer 函数：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def timer(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        start &#x3D; time.time()</span><br><span class="line">        func(*args, **kwargs) #此处拿到了被装饰的函数func</span><br><span class="line">        time.sleep(2)#模拟耗时操作</span><br><span class="line">        long &#x3D; time.time() - start</span><br><span class="line">        print(f&#39;共耗时&#123;long&#125;秒。&#39;)</span><br><span class="line">    return wrapper          #返回内层函数的引用</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def add(a, b):</span><br><span class="line">    print(a+b)</span><br><span class="line"></span><br><span class="line">add(1, 2) #正常调用add</span><br></pre></td></tr></table></figure>
timer被我们改造成了
<strong>装饰器</strong>，它接受被装饰函数为入参，返回内部
<strong>嵌套函数的引用</strong>（注意：<strong>此处并未执行函数</strong>），内部嵌套函数
<strong>wrapper持有被装饰函数的引用即func</strong>。</p>
<p>“@”是Python的语法糖，它的作用类似于：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add &#x3D; timer(add) #此处返回的是timer.&lt;locals&gt;.wrapper函数引用</span><br><span class="line">add(1, 2)</span><br></pre></td></tr></table></figure></p>
<div style="width:80%;margin:auto">
<img src="/2020/11/19/python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%A3%85%E9%A5%B0%E5%99%A8/timer%E5%87%BD%E6%95%B0.jpg" class title="timer函数图">
</div>
]]></content>
      <categories>
        <category>python源码分析</category>
      </categories>
      <tags>
        <tag>python源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>[svn]常用命令行</title>
    <url>/2020/11/18/svn-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h2><span id="xia-zai-wen-jian-dao-ben-di-mu-lu">下载文件到本地目录</span><a href="#xia-zai-wen-jian-dao-ben-di-mu-lu" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn checkout path（path是服务器 上的目录）</span><br><span class="line">例如：svn checkout svn:&#x2F;&#x2F;192.168.1.1&#x2F;pro&#x2F;domain</span><br><span class="line">简写：svn co</span><br></pre></td></tr></table></figure>
<h2><span id="cha-kan-dang-qian-dang-qian-xiang-mu-di-zhi">查看当前当前项目地址</span><a href="#cha-kan-dang-qian-dang-qian-xiang-mu-di-zhi" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn info （这里返回的是root路径）</span><br><span class="line"></span><br><span class="line">svn info filename （返回的时特定文件filename的路径）</span><br></pre></td></tr></table></figure>
<h2><span id="qie-huan-fen-zhi-svn-sw">切换分支（svn sw）</span><a href="#qie-huan-fen-zhi-svn-sw" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn sw &lt;branch_full_url&gt;</span><br><span class="line"></span><br><span class="line">sample：</span><br><span class="line">svn sw https:&#x2F;&#x2F;mysvn.cn&#x2F;svn&#x2F;repo&#x2F;project&#x2F;branches&#x2F;version-xxx</span><br></pre></td></tr></table></figure>
<h2><span id="cha-kan-ri-zhi">查看日志</span><a href="#cha-kan-ri-zhi" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn log path</span><br><span class="line">sample：svn log test.php  （显示这个文件的所有修改记录，及其版本号的变化）</span><br></pre></td></tr></table></figure>
<h2><span id="bi-jiao-chai-yi">比较差异</span><a href="#bi-jiao-chai-yi" class="header-anchor">#</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn diff path(将修改的文件与基础版本比较)</span><br><span class="line">sample：svn diff test.php</span><br><span class="line"></span><br><span class="line">svn diff -r m:n path(对版本m和版本n比较差异)</span><br><span class="line">sample：svn diff -r 200:201 test.php</span><br><span class="line"></span><br><span class="line">简写：svn di</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>[unity shader] 2.GPU渲染管线</title>
    <url>/2020/08/18/unity-shader-2-GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<h1><span id="gpu-xuan-ran-guan-xian">GPU渲染管线</span><a href="#gpu-xuan-ran-guan-xian" class="header-anchor">#</a></h1>
<p>当GPU从CPU得到渲染命令后，就会进行一系列流水线操作，最终把图元渲染到屏幕上。</p>
<p>对于<strong>几何阶段和光栅化阶段</strong>，开发者无法拥有绝对的控制权，其实现的载体是GPU。GPU通过<strong>实现流水线化，大大加快了渲染速度</strong>。</p>
<p>几何阶段和光栅化阶段<strong>可以分成若干更小的流水线阶段</strong>，这些流水线阶段由GPU实现，每个阶段GPU提供了不同的可配置性或可编程性。</p>
<div style="width:100%;margin:auto">
<img src="/2020/08/18/unity-shader-2-GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.png" class title="GPU渲染管线图">
</div>
<p>从图中可以看出，GPU的渲染流水线接收顶点数据作为输入。这些顶点数据是由应用阶段加载到显存中，再由DrawCall指定的。这些数据随后被传递给顶点着色器。</p>
<h3><span id="1-ding-dian-zhao-se-qi-vertex-shader-wan-quan-ke-bian-cheng">1.顶点着色器（Vertex
Shader）：完全可编程</span><a href="#1-ding-dian-zhao-se-qi-vertex-shader-wan-quan-ke-bian-cheng" class="header-anchor">#</a></h3>
<p>通常用于实现顶点的空间变换、顶点着色等功能。</p>
<p>顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身并不会创建或者销毁顶点，而且无法得到顶点与顶点之间的关系。</p>
<p>例如：我们无法得知两个顶点是否属于一个三角网格。正因为这样的相互独立性，GPU可以利用本身的特性并行化处理每一个顶点。</p>
<p>顶点着色器需要完成的工作主要有：坐标变换和顶点光照。当然还可以输出后续阶段所需的数据。</p>
<h3><span id="2-cai-jian-clipping-ke-pei-zhi">2.裁剪（Clipping）：可配置</span><a href="#2-cai-jian-clipping-ke-pei-zhi" class="header-anchor">#</a></h3>
<p>这一阶段的目的是将那些不再摄像机视野内的顶点裁减掉，并剔除某些三角图元的面片。</p>
<p>目的：处理不在摄像机视野范围内的物体。</p>
<p>一个图元和摄像机视野有三种关系：完全在视野内、部分在视野内、完全在视野外。完全在视野内的图元即系传递给下一个流水线阶段，完全在视野外的图元就不会向下传递，因为不需要被渲染。而那些部分在视野内的图元就需要进行一个处理，那就是裁剪。</p>
<p>和顶点着色器不同，这一步是不可编程的。无法通过编程来控制裁剪的过程，是硬件上的固定操作</p>
<p>但是可以自定义一个剪裁操作来对这一步进行配置</p>
<h3><span id="3-ping-mu-ying-she-screen-mapping-bu-ke-pei-zhi-he-bian-cheng-de">3.屏幕映射（Screen
Mapping）：不可配置和编程的</span><a href="#3-ping-mu-ying-she-screen-mapping-bu-ke-pei-zhi-he-bian-cheng-de" class="header-anchor">#</a></h3>
<p>这一步输入的坐标仍然是三维坐标系下的坐标。</p>
<p>负责把每个图元的坐标转换到屏幕坐标系中。</p>
<h3><span id="4-san-jiao-xing-she-zhi-triangle-setup-he-san-jiao-xing-bian-liang-triangle-traversal-jie-duan-du-shi-gu-ding-han-shu-fixed-function-de-jie-duan">4.三角形设置（Triangle
Setup）和三角形变量（Triangle
Traversal）阶段都是固定函数（Fixed-Function）的阶段</span><a href="#4-san-jiao-xing-she-zhi-triangle-setup-he-san-jiao-xing-bian-liang-triangle-traversal-jie-duan-du-shi-gu-ding-han-shu-fixed-function-de-jie-duan" class="header-anchor">#</a></h3>
<p>这一阶段开始进入光栅化阶段。从上一个阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的额外信息，如：深度值（Z）、法线方向、视角方向等。</p>
<p>光栅化阶段有两个重要的目标：计算每个图元的覆盖了哪些像素，以及为这些像素计算颜色。</p>
<p>三角形设置：计算光栅化一个三角网格所需的信息。具体来讲，上一个阶段输出的都是三角网格的顶点，即我们得到的是三角网格每条边的两个顶点。但是如果要得到整个三角形网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个计算三角形网格表示数据的过程叫做三角形设置。</p>
<p>三角形遍历：检查每个像素是否被一个三角网格所覆盖。如果覆盖的话，就会生成一个片段（fragment）。这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换（Scan
Conversion）。</p>
<p>片段并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。</p>
<h3><span id="5-pian-duan-zhao-se-qi-fragment-shader-wan-quan-ke-bian-cheng">5.片段着色器（Fragment
Shader）：完全可编程</span><a href="#5-pian-duan-zhao-se-qi-fragment-shader-wan-quan-ke-bian-cheng" class="header-anchor">#</a></h3>
<p>用于实现逐片元（Per-Fragment）的着色操作。</p>
<p>片段着色器的输入是上一个阶段对顶点信息插值得到的结果，更具体来说，是根据那些从顶点着色器中输出的数据插值得到的。输出的是一个或者多个颜色值。</p>
<p>这一个阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样。为了在片段着色器中进行纹理采样，通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理进行插值后，就可以得到其覆盖的片段的纹理坐标了。</p>
<h3><span id="6-zhu-pian-yuan-cao-zuo-per-fragment-operations-bu-ke-bian-cheng-dan-ju-you-hen-gao-de-ke-pei-zhi-xing">6.逐片元操作（Per-Fragment
Operations）：不可编程，但具有很高的可配置性</span><a href="#6-zhu-pian-yuan-cao-zuo-per-fragment-operations-bu-ke-bian-cheng-dan-ju-you-hen-gao-de-ke-pei-zhi-xing" class="header-anchor">#</a></h3>
<p>负责执行很多重要的操作，例如：修改颜色、深度缓冲、进行混合等。</p>
<p>这一阶段OpenGL-逐片元操作 DirectX-输出合并阶段</p>
<p>这一阶段有几个重要的任务：</p>
<p>（1）
决定每个片元的可见性：这涉及了很多测试工作，例如：深度测试、模板测试</p>
<p>（2）
如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经储存在颜色缓冲区中的颜色进行合并，混合</p>
]]></content>
      <tags>
        <tag>shader</tag>
      </tags>
  </entry>
  <entry>
    <title>[unity shader] 1.概述</title>
    <url>/2020/08/18/unity-shader-graph-1-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1><span id="1-gai-shu">1. 概述</span><a href="#1-gai-shu" class="header-anchor">#</a></h1>
<div style="width:70%;margin:auto">
<img src="/2020/08/18/unity-shader-graph-1-%E6%A6%82%E8%BF%B0/Shader_sum_up.png" class title="shader概述图">
</div>
<h2><span id="1-1-shader-chong-lei">1.1 shader种类</span><a href="#1-1-shader-chong-lei" class="header-anchor">#</a></h2>
<p>shader主要有：<strong>固定管线着色器，顶点片元着色器，表面着色器</strong></p>
<ul>
<li>固定管线着色器（逐渐淘汰）</li>
<li>顶点shader：干预<strong>模型形态的shader（顶点变换）</strong></li>
<li>像素shader：干预<strong>像素着色的shader(不同纹理贴图）</strong></li>
</ul>
<h2><span id="1-2-gpu-bian-cheng-yu-yan">1.2 GPU编程语言</span><a href="#1-2-gpu-bian-cheng-yu-yan" class="header-anchor">#</a></h2>
<ol type="1">
<li><strong>Dirext3D-----微软（windows）</strong></li>
<li><strong>OpenGL-----Linux（Android）</strong></li>
</ol>
<p>目前面向GPU的编程有三种高级图像语言：<strong>HLSL语言，GLSL语言，Cg语言</strong>。</p>
<ol type="1">
<li><p>HLSL语言：High Level Shading
Language，由<strong>Microsoft公司提供，通过Direct3D图形软件库</strong>来编写的着色器语言。</p></li>
<li><p>GLSL语言：<strong>OpenGL Shading
Language，由OpenGL安委会提供</strong>，在OpenGL中进行着色器编程的语言。</p></li>
<li><p>Cg语言：C for
Graphics，由<strong>NVIDIA公司和Microsoft公司合作提供</strong>，有自己的一套关键字和函数库，独立于三维编程接口，<strong>在Direct3D和OpenGL上都可工作</strong>。</p></li>
</ol>
<h1><span id="2-shader-lab-ji-chu-yu-fa">2. shader lab基础语法</span><a href="#2-shader-lab-ji-chu-yu-fa" class="header-anchor">#</a></h1>
<h2><span id="2-1-shaderlab-jian-jie">2.1 ShaderLab简介</span><a href="#2-1-shaderlab-jian-jie" class="header-anchor">#</a></h2>
<p>ShaderLab: <strong>Unity
自己又封装了一层CG/HLSL/GLSL的接口</strong>，但为了实现跨平台，Unity<strong>重点支持Cg着色器语言</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Shader &quot;主色器名称&quot;&#123;</span><br><span class="line">    Properties&#123;&#125; &#x2F;&#x2F;属性定义</span><br><span class="line">    SubShader&#123;&#125; &#x2F;&#x2F;子主色器</span><br><span class="line">    SubShader&#123;&#125; &#x2F;&#x2F;子主色器2</span><br><span class="line">    …………</span><br><span class="line">    FallBack &quot;备用着色器名称&quot; &#x2F;&#x2F;如果所有子着色器不能运行，则使用备用着色器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的shader示例：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; colored vertex lighting</span><br><span class="line">Shader &quot;Simple colored lighting&quot;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; a single color property</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Main Color&quot;, Color) &#x3D; (1,.5,.5,1)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; define one subshader</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; a single pass in our subshader</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; use fixed function per-vertex lighting</span><br><span class="line">            Material</span><br><span class="line">            &#123;</span><br><span class="line">                Diffuse [_Color]</span><br><span class="line">            &#125;</span><br><span class="line">            Lighting On</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Shader "name"{ }定义了一个名字为“name”的shader。</p>
<h3><span id="2-1-1-properties-shu-xing-ding-yi">2.1.1 properties属性定义</span><a href="#2-1-1-properties-shu-xing-ding-yi" class="header-anchor">#</a></h3>
<p>用来定义<strong>主色器中使用的贴图资源或者数值参数</strong>等。这些属性<strong>会在inspector视图的材质界面中显示</strong>，可以方便的进行设置和修改。</p>
<h3><span id="2-1-2-subshader-shu-xing-ding-yi">2.1.2 SubShader属性定义</span><a href="#2-1-2-subshader-shu-xing-ding-yi" class="header-anchor">#</a></h3>
<p>一个着色器<strong>包含一个或者多个子着色器</strong>。当Unity使用着色器渲染的时，会<strong>从上到下遍历子着色器，找到第一个被用户设备支持的子着色器</strong>，并<strong>使用该子着色器进行渲染</strong>。如果<strong>没有子着色器可以使用，则使用备用着色器</strong>。</p>
<h3><span id="2-1-3-fallback-shu-xing-ding-yi">2.1.3 Fallback属性定义</span><a href="#2-1-3-fallback-shu-xing-ding-yi" class="header-anchor">#</a></h3>
<p>备用着色器一般<strong>会指定一个对硬件要求最低的shader</strong>。当所有子着色器不能运行的时候，unity会启用备用着色器来进行渲染。</p>
<h2><span id="2-2-properties-shu-xing">2.2 Properties属性</span><a href="#2-2-properties-shu-xing" class="header-anchor">#</a></h2>
<p>properties一般定义<strong>在着色器的起始部分</strong>，我们可以在Shader书写的时候定义多种多样的属性，而使用Shader的时候可以直接在材质检视面板(Material
Inspector)里编辑这些属性，<strong>取不同的值或者纹理</strong>。这可以说是Unity贴心&amp;可见即所得的又一体现吧。</p>
<p>定义了一些属性参数，可在Unity编辑器的“Inspector”面板中编辑和调整。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_Name(&quot;Display Name&quot;, type) &#x3D; defaultValue[&#123;options&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Properties &#123;</span><br><span class="line">        _Color是变量名 (&quot;Main Color&quot;是在“Inspector”中的名字, Color是变量类型) &#x3D; (1,.5,.5,1)是默认值　 　　　　　　　　</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="2-2-1-properties-lei-xing">2.2.1 Properties 类型</span><a href="#2-2-1-properties-lei-xing" class="header-anchor">#</a></h3>
<p>类型|说明 -:-|-:- Range（min,max）| 在（min，max）范围内的浮点数
Float |浮点数 Int |整型 Color |颜色 RGBA Vector |四维向量 2D |2D纹理 3D
|3D纹理 Cube |立方体贴图纹理 Rect |矩形纹理</p>
<ul>
<li>**_Name**
属性的名字，简单说就是变量名，在之后<strong>整个Shader代码中将使用这个名字来获取该属性的内容</strong>。Unity中用下划线开始_Name</li>
<li><strong>Display Name</strong> -
这个字符串<strong>将显示在Unity的材质编辑器中作为Shader的使用者可读的内容</strong></li>
<li><strong>type</strong> -
这个属性的类型，可能的type所表示的内容有以下几种：
<ul>
<li>Color - 一种颜色，由RGBA（红绿蓝和透明度）四个量来定义；</li>
<li>2D -
一张2的阶数大小（256，512之类）的贴图。这张贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终被显示出来；</li>
<li>Rect - 一个非2阶数大小的贴图；</li>
<li>Cube - 即Cube map
texture（立方体纹理），简单说就是6张有联系的2D贴图的组合，主要用来做反射效果（比如天空盒和动态反射），也会被转换为对应点的采样；</li>
<li>Range(min, max) -
一个介于最小值和最大值之间的浮点数，一般用来当作调整Shader某些特性的参数（比如透明度渲染的截止值可以是从0至1的值等）；</li>
<li>Float - 任意一个浮点数；</li>
<li>Vector - 一个四维数；</li>
</ul></li>
<li><strong>defaultValue</strong>
定义了这个属性的默认值，通过输入一个符合格式的默认值来指定对应属性的初始值（某些效果可能需要某些特定的参数值来达到需要的效果，虽然这些值可以在之后在进行调整，但是如果默认就指定为想要的值的话就省去了一个个调整的时间，方便很多）。
<ul>
<li>Color - 以0～1定义的rgba颜色，比如(1,1,1,1)；</li>
<li>2D/Rect/Cube -
对于贴图来说，默认值可以为一个代表默认tint颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump”中的一个</li>
<li>Float，Range - 某个指定的浮点数</li>
<li>Vector - 一个4维数，写为 (x,y,z,w)</li>
</ul></li>
<li>另外还有一个{option}，它只对2D，Rect或者Cube贴图有关，在写输入时我们最少要在贴图之后写一对什么都不含的空白的{}，当我们需要打开特定选项时可以把其写在这对花括号内。如果需要同时打开多个选项，可以使用空白分隔。可能的选择有ObjectLinear,
EyeLinear, SphereMap, CubeReflect,
CubeNormal中的一个，这些都是OpenGL中TexGen的模式，</li>
</ul>
<h2><span id="2-3-subshader">2.3 SubShader</span><a href="#2-3-subshader" class="header-anchor">#</a></h2>
<h3><span id="2-3-1-ding-yi-yu-fa">2.3.1 定义语法</span><a href="#2-3-1-ding-yi-yu-fa" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subshader &#123; </span><br><span class="line"> [Tags] </span><br><span class="line">   [CommonState] </span><br><span class="line">    Passdef [Passdef ...] &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-biao-qian-tags">2.3.2 标签（Tags）</span><a href="#2-3-2-biao-qian-tags" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;写在SubShader的第一句</span><br><span class="line">Tags &#123; &quot;TagName1&quot; &#x3D; &quot;Value1&quot; &quot;TagName2&quot; &#x3D; &quot;Value2&quot; &#125;</span><br><span class="line">&#x2F;&#x2F;比如</span><br><span class="line">Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125;</span><br></pre></td></tr></table></figure>
<h4><span id="zuo-yong">作用</span><a href="#zuo-yong" class="header-anchor">#</a></h4>
<p><strong>SubShaders使用标签来告诉引擎如何以及何时将其渲染。</strong></p>
<p><strong>Unity识别的以下标记必须在SubShader节内，而不是Pass！</strong></p>
<ol type="1">
<li><strong>“Queue”标签</strong>。定义<strong>渲染顺序</strong>-队列标签。预制的值为
（1）”Background”。值为1000。比如用于天空盒。
（2）”Geometry”。值为2000。大部分物体在这个队列。不透明的物体也在这里。这个队列内部的物体的渲染顺序会有进一步的优化（应该是从近到远，early-z
test可以剔除不需经过FS处理的片元）。其他队列的物体都是按空间位置的从远到近进行渲染。
（3）”AlphaTest”。值为2450。已进行AlphaTest的物体在这个队列。
（4）”Transparent”。值为3000。透明物体。
（5）”Overlay”。值为4000。比如镜头光晕。
（6）用户可以定义任意值，比如”Queue”=”Geometry+10”</li>
<li><strong>“RenderType”标签</strong>。Unity可以运行时<strong>替换符合特定RenderType的所有Shader</strong>。<strong>Camera.RenderWithShader或者Camera.SetReplacementShader配合使用</strong>。Unity内置的RenderType包括：
（1）”Opaque”：绝大部分<strong>不透明的物体都使用这个</strong>；
（2）”Transparent”：<strong>绝大部分透明的物体、包括粒子特效都使用这个</strong>；
（3）”Background”：<strong>天空盒都使用这个</strong>；
（4）”Overlay”：<strong>GUI、镜头光晕</strong>都使用这个；
（5）还有其他可参考Rendering with Replaced
Shaders；用户也可以定义任意自己的RenderType字符串。</li>
<li><strong>”ForceNoShadowCasting”，值为”true”时，表示不接受阴影</strong>。</li>
<li><strong>”IgnoreProjector”</strong>，值为”true”时，表示<strong>不接受Projector组件的投影</strong>。</li>
</ol>
<h3><span id="2-3-3-pass-tong-dao-cha-ru-dao-xuan-ran-liu-shui-xian-de-ding-yi-yu-fa">2.3.3
Pass(通道：插入到渲染流水线)的定义语法</span><a href="#2-3-3-pass-tong-dao-cha-ru-dao-xuan-ran-liu-shui-xian-de-ding-yi-yu-fa" class="header-anchor">#</a></h3>
<p><strong>subshader包装了一个渲染方案，这些方案由一个个通道（pass）来执行的，subshader可以包含很多通道块，每个Pass都能使几何体渲染一次</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line"> [Name and Tags名称和标签]</span><br><span class="line">  [Render Setup 渲染设置]</span><br><span class="line">   [Texture setup 纹理设置]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例代码</span><br><span class="line">Shader &quot;Custom&#x2F;Shader_01&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Name &quot;ONE&quot;</span><br><span class="line">            Material&#123;</span><br><span class="line">                Diffuse(1,0.7,0.4,1)</span><br><span class="line">                Ambient(1,0.7,0.4,1)</span><br><span class="line">            &#125;</span><br><span class="line">            Lighting On</span><br><span class="line">            SetTexture[_]&#123; combine primary &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="2-3-4-pass-ming-cheng-he-biao-qian-name-and-tags">2.3.4 pass名称和标签（Name and
tags）</span><a href="#2-3-4-pass-ming-cheng-he-biao-qian-name-and-tags" class="header-anchor">#</a></h3>
<p>可以定义<strong>Pass的名字以及任意数量的标签</strong>。为Pass命名后，可以在<strong>别的着色器中通过Pass名称来引用它，减少重复操作</strong>。Name<strong>命名必须大写</strong></p>
<h3><span id="2-3-5-pass-xuan-ran-she-zhi-render-setup">2.3.5 pass渲染设置（Render
Setup）</span><a href="#2-3-5-pass-xuan-ran-she-zhi-render-setup" class="header-anchor">#</a></h3>
<p>pass里可以<strong>设置图形硬件的各种状态</strong>，例如<strong>开启Alpha混合，开启雾效</strong>等。</p>
<h4><span id="regularpass-xuan-ran-she-zhi">RegularPass渲染设置</span><a href="#regularpass-xuan-ran-she-zhi" class="header-anchor">#</a></h4>
<p>命令 |说明 -:-|-:- Meterial{} |材质，定义一个使用顶点光照管线的材质
Lighting |光照，设置光照，取值为off或on Cull
|裁剪，设置裁剪模式，模式包括：back、Front、off ZTest
|深度测试，设置深度测试，包括：Less、Greater、LEqual、GEqual、Equal、NotEqual、Always。
ZWrite |深度缓存写入，设置深度缓存写入的开关，取值为Off或On Fog{}
|雾效，设置雾效参数 AlphaTest
|<strong>Alpha测试</strong>，设置Alpha测试，包括：Less、Greater、LEqual、GEqual、Equal、NotEqual、Always。
Blend |Alpha混合，设置Alpha混合模式 Stencil|
蒙版，用蒙版来实现像素的取舍操作，选项有：keep、Zero、Replace、Incrsat、DecrSat、Invert、Incrwrap和DecrWrap
Color |颜色，是指顶点光照关闭时使用的颜色值 ColorMask
|颜色遮罩，设置<strong>颜色遮罩</strong>，当值为0时关闭所有的颜色通道的渲染，取值为RGB
offset |深度偏移，设置深度偏移 SeparateSpecular
|高光颜色。开启或关闭顶点光照的独立高光颜色，取值为On或Off ColorMaterial
|颜色集，当计算顶点光照时使用每个顶点的颜色。</p>
<h4><span id="te-shu-tong-dao">特殊通道</span><a href="#te-shu-tong-dao" class="header-anchor">#</a></h4>
<ol type="1">
<li><p><strong>UsePass 命令 使用 来自另一个着色器的命名通道</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**UsePass &quot;Shader&#x2F;Name&quot;**</span><br></pre></td></tr></table></figure>
插入<strong>所有来自给定着色器中的给定名字的通道</strong>。Shader/Name包含了<strong>通过斜杠字符分割的着色器的名字和通道的名字</strong>
某些着色器重用其他着色器中已存在的通道，减少重复的代码。例如，在许多像素光照着色器中，阴影色或顶点光照通道在在相应的顶点光照着色器中是相同的。UsePass命令只是包含了另一个着色器的给定通道。例如当如下的命令可以使用内置的高光着色器中的名叫"Base"的通道：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UsePass &quot;Specular&#x2F;BASE&quot;</span><br></pre></td></tr></table></figure>
为了让UsePass能正常工作，必须给希望使用的通道命名。通道中的Name命令将提供这个名字：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name &quot;MyPassName&quot;</span><br></pre></td></tr></table></figure>
注意，所有通道名字都是大写开头，因此<strong>UsePass必须使用大写开头的名字来书写索引</strong>。</p></li>
<li><p>GrabPass是一种特殊的通道类型 -
<strong>捕获物体所在位置的屏幕的内容并写入到一个纹理中</strong>。这个纹理能<strong>被用于后续的通道中完成一些高级图像特效。</strong>
有两种方式将GrabPass放入一个 subshader中：</p></li>
</ol>
<ul>
<li>GrabPass {}
能<strong>捕获当前屏幕的内容到一个纹理中</strong>。纹理能在后续通道中通过
_GrabTexture
进行访问。注意：这种形式的捕获通道将在每一个使用该通道的对象渲染过程中执行昂贵的屏幕捕获操作</li>
<li>GrabPass { "TextureName" }
能捕获屏幕内容到一个纹理中，但只会在每帧中处理第一个使用给定纹理名的纹理的对象的渲染过程中产生捕获操作。纹理在未来的通道中可以通过给定的纹理名访问。当你在一个场景中拥有多个使用GrabPass的对象时将提高性能。</li>
</ul>
<p>GrabPass能使用<strong>Name 和 Tags命令。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shader &quot;GrabPassInvert&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        &#x2F;&#x2F; Draw ourselves after all opaque geometry </span><br><span class="line">        &#x2F;&#x2F; 在所有不透明几何体之后自画</span><br><span class="line">        Tags &#123; &quot;Queue&quot; &#x3D; &quot;Transparent&quot; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Grab the screen behind the object into _GrabTexture</span><br><span class="line">        &#x2F;&#x2F; 捕获对象后的屏幕到_GrabTexture</span><br><span class="line">        GrabPass &#123; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Render the object with the texture generated above, and invert it&#39;s colors</span><br><span class="line">        &#x2F;&#x2F; 用前面捕获的纹理渲染对象，并反相它的颜色</span><br><span class="line">        Pass &#123;</span><br><span class="line">            SetTexture [_GrabTexture] &#123; combine one-texture &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-6-pass-wen-li-she-zhi-texture-setup">2.3.6 pass纹理设置（Texture
Setup）</span><a href="#2-3-6-pass-wen-li-she-zhi-texture-setup" class="header-anchor">#</a></h3>
<p>纹理设置语法：<strong>setTexture 纹理属性{[命令选项}</strong>
纹理设置用于<strong>固定功能管线</strong>，如果<strong>使用表面着色器或者自定义的顶点或者片段着色器，那么纹理设置将会被忽略</strong>。
setTexture的命令选项包括三种： 1.
<strong>Conbine</strong>:将两个颜色源混合，混合源可以是previous（上一次setTexture的结果）、constant（常量颜色值）、primary（顶点颜色）和texture（纹理颜色中的一种）
2. <strong>ConstantColor设置一个颜色常量</strong> 3.
<strong>matrix:设置矩阵对纹理坐标进行变换</strong></p>
<h2><span id="2-4-fallback-bei-yong-zhao-se-qi">2.4 Fallback备用着色器</span><a href="#2-4-fallback-bei-yong-zhao-se-qi" class="header-anchor">#</a></h2>
<h3><span id="yu-fa">语法：</span><a href="#yu-fa" class="header-anchor">#</a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）Fallback “备用着色器名称”</span><br><span class="line">（2）Fallback off</span><br></pre></td></tr></table></figure>
<h2><span id="2-5-unity-nei-zhi-surface-shader-guan-zhao-xiao-guo-ji-suan-de-xing-neng-kai-xiao-pai-xu">2.5
unity内置Surface shader关照效果计算的性能开销排序</span><a href="#2-5-unity-nei-zhi-surface-shader-guan-zhao-xiao-guo-ji-suan-de-xing-neng-kai-xiao-pai-xu" class="header-anchor">#</a></h2>
<ol type="1">
<li>Unlit:仅适用<strong>纹理颜色，不受光照影响</strong></li>
<li>VertexLit:顶点光照</li>
<li>Diffuse：漫反射</li>
<li>Specular：在满反射的基础上增加了高光计算</li>
<li>Normal Mapped：法线贴图，增加了一张法线贴图和几个着色器指令</li>
<li>Normal Mapped Specular：<strong>带高光的法线贴图</strong></li>
<li>Parallax Normal
Mapped：<strong>视差法线贴图</strong>，增加了视察贴图的计算开销。</li>
<li>Parallax Normal Mapped
Specular：<strong>带高光的视差法线贴图</strong></li>
</ol>
]]></content>
      <categories>
        <category>shader</category>
      </categories>
      <tags>
        <tag>shader</tag>
      </tags>
  </entry>
  <entry>
    <title>[vscode]markdown+plantuml画图</title>
    <url>/2022/11/05/vscode-markdown-plantuml%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<p>markdown支持用plantuml画uml图，极为方便且美观 <a id="more"></a></p>
<h2><span id="mu-lu">目录</span><a href="#mu-lu" class="header-anchor">#</a></h2>
<p><a href="#需要">需要</a></p>
<p><a href="#安装">安装</a></p>
<p><a href="#使用">使用</a></p>
<h2><span id="xu-yao">需要</span><a href="#xu-yao" class="header-anchor">#</a></h2>
<ol type="1">
<li>Java环境（PlantUML需要java环境）</li>
<li>VSCode （不必多说）</li>
<li>VSCode插件</li>
<li>Graphviz软件(PlantUML的图形预览)</li>
</ol>
<h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h2>
<ol type="1">
<li>安装<a href="https://www.java.com/zh-TW/download/">java</a></li>
<li>VSCode商店安装如下插件:
<ul>
<li>Markdown Preview Enhanced</li>
<li>Markdown All In One</li>
<li>PlantUml</li>
</ul></li>
<li>安装Graphviz软件
<ul>
<li>下载<a href="https://www.graphviz.org/download/">Graphviz
windows版</a></li>
<li>安装时注意选中 Add Graphviz to the system PATH for all
users，若未选中自己配置下<a href="https://www.pianshen.com/article/7200139623/">环境变量</a></li>
</ul></li>
</ol>
<h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor">#</a></h2>
<p><a href="https://plantuml.com/zh/">plantuml官网</a>有详细教程</p>
<p>示例
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Alice -&gt; Bob: Authentication Request</span><br><span class="line">Bob --&gt; Alice: Authentication Response</span><br><span class="line"></span><br><span class="line">Alice -&gt; Bob: Another authentication Request</span><br><span class="line">Alice &lt;-- Bob: Another authentication Response</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></p>
<img src="http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuNBCoKnELT2rKt3AJx9IS2mjoKZDAybCJYp9pCzJ24ejB4qjBk42oYde0jM05MDHLLoGdrUSoeLkM5u-K5sHGY9sGo6ARNHr2QY66kwGcfS2T300">
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>[数学基础] 1.Bayes&#39; theorem</title>
    <url>/2021/03/18/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-1-Bayes-theorem/</url>
    <content><![CDATA[<h2><span id="what-is-bayes-theorem">what is Bayes' theorem</span><a href="#what-is-bayes-theorem" class="header-anchor">#</a></h2>
<p>贝叶斯推断（<a href="https://en.wikipedia.org/wiki/Bayesian_inference">Bayesian
inference</a>）是一种统计学方法，用来估计统计量的某种性质。</p>
<p>它是 <strong>贝叶斯定理（<a href="https://en.wikipedia.org/wiki/Bayes%27_theorem">Bayes'
theorem</a>）</strong>的应用。英国数学家<strong>托马斯·贝叶斯（Thomas
Bayes）</strong>在1763年发表的一篇论文中，首先提出了这个定理。</p>
<p>Bayesian inference
与其他统计学推断方法<strong>截然不同</strong>。它建立在<strong>主观判断</strong>的基础上，也就是说，你可以不需要客观证据，<strong>先估计一个值，然后根据实际结果不断修正</strong>。正是因为它的主观性太强，曾经遭到许多统计学家的诟病。</p>
<p>贝叶斯推断需要
<strong>大量的计算</strong>，因此历史上很长一段时间，无法得到广泛应用。只有<strong>计算机诞生以后</strong>，它才获得真正的重视。人们发现，许多统计量是<strong>无法事先进行客观判断的</strong>，而互联网时代出现的大型数据集，再加上高速运算能力，为验证这些统计量提供了方便，也为应用贝叶斯推断创造了条件，它的威力正在日益显现。</p>
<h2><span id="bei-xie-si-ding-li">贝叶斯定理</span><a href="#bei-xie-si-ding-li" class="header-anchor">#</a></h2>
<p>贝叶斯定理, 实际上就是计算 <strong>条件概率</strong>的公式。</p>
所谓"条件概率"（Conditional
probability），就是指在<strong>事件B发生的情况下，事件A发生的概率</strong>，用<span class="math inline">\(P(A|B)\)</span>来表示。
<div style="width:100%;margin:auto">
<img src="/2021/03/18/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-1-Bayes-theorem/bayers1.jpg" class title="bayers1图">
</div>
<p>根据文氏图，可以很清楚地看到 <span class="math inline">\(P(A|B)\)</span> 就是 <span class="math inline">\(P(A \cap B)\)</span>除以<span class="math inline">\(P(B)\)</span>。 <span class="math display">\[P(A|B) = \frac {P(A \cap B)} {P(B)}\]</span> 即:
<span class="math display">\[P(A \cap B) = P(A|B) P(B)\]</span> 同理:
<span class="math display">\[P(A \cap B) = P(B|A) P(A)\]</span> 因此:
<span class="math display">\[P(A|B) = \frac {P(B|A) P(A)}
{P(B)}\]</span></p>
<p>我们把 <span class="math inline">\(P(A)\)</span>称为<strong>先验概率（Prior
probability）</strong>，即在B事件发生之前，我们<strong>对A事件概率的一个判断</strong>。<span class="math inline">\(P(A|B)\)</span>称为<strong>后验概率</strong>（Posterior
probability），即<strong>在B事件发生之后，对A事件概率的重新评估</strong>。<span class="math inline">\(\frac{P(B|A)}{P(B)}\)</span>
称为<strong>似然函数</strong>（<strong>Likelyhood</strong>），这是一个<strong>调整因子</strong>，使得<strong>预估概率更接近真实概率</strong>。</p>
<p>所以，条件概率可以理解成下面的式子：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后验概率　＝　先验概率 ｘ 调整因子</span><br></pre></td></tr></table></figure>
我们先预估一个<strong>先验概率</strong>，然后加入实验结果，看这个实验到底是<strong>增强还是削弱</strong>了"先验概率"(<strong>取决于Likelyhood</strong>)，由此得到更接近事实的
"后验概率"。</p>
<h2><span id="when-to-use-bayes-theorem">when to use Bayes' theorem</span><a href="#when-to-use-bayes-theorem" class="header-anchor">#</a></h2>
<p>我们先看看简单的例子： - 事实 <strong>Evidence</strong>:
Robin个性安静,喜欢阅读。</p>
<p>需要猜测 Robin<strong>是图书管理员</strong> 还是
<strong>农民</strong>。大多数人也许会认为Robin是图书管理员。 - 假设
hypothesis： Robin是图书管理员</p>
<p>接下里我们验证一下这个概率，其中目前数据显示： - 人群中:
图书管理员/农民 = <span class="math inline">\(\frac{1}{20}\)</span> -
图书管理员符合Evidence的概率为 <span class="math inline">\(\frac{4}{10}\)</span> - 农民符合Evidence的概率为
<span class="math inline">\(\frac{1}{20}\)</span></p>
<p>我们需要求出: P(H|E) - P(H|E) --&gt; P(hypothesis given
evidence)：<strong>后验概率</strong>，指Evidence条件下，hypothesis成立的概率。通俗的讲，<span class="math inline">\(P(H|E) = \frac{H中符合E的概率}{符合E的总概率} =
\frac{P(E|H) P(H)}{P(E)}\)</span></p>
<ul>
<li><p><span class="math inline">\(P(E|H) = \frac{4}{10}\)</span>
：P(evidence given hypothesis) <strong>Likehood 似然</strong>,这里指
图书管理员 中 符合Evidence 的概率。</p></li>
<li><p><span class="math inline">\(P(H) = \frac{1}{1+20} =
\frac{1}{21}\)</span> 。<span class="math inline">\(P(H)\)</span>也叫
<strong>先验</strong>,这里指图书管理员的概率。</p></li>
<li><p><span class="math inline">\(P(E) = \frac{4}{10} + \frac{1}{20} =
\frac{9}{20}\)</span></p></li>
</ul>
<p>所以 $P(H|E) = {P(E)} = {} $</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<p>1.<a href="https://en.wikipedia.org/wiki/Bayesian_inference">Bayesian
inference</a> 2.<a href="https://en.wikipedia.org/wiki/Bayes%27_theorem">Bayes' theorem</a>
3.<a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html">贝叶斯推断及其互联网应用（一）：定理简介</a></p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>数学基础</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据库] Mysql为什么用B+树</title>
    <url>/2020/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91/</url>
    <content><![CDATA[<h2><span id="why-not-ha-xi-suo-yin">why not 哈希索引？</span><a href="#why-not-ha-xi-suo-yin" class="header-anchor">#</a></h2>
<ol type="1">
<li><p>哈希值是无序的值，既然无序，就
<strong>不能进行范围查找</strong>，而数据库需要很多大于小于的查找。</p></li>
<li><p>如果要进行
<strong>排序操作</strong>，也不能使用哈希值的哈希索引进行排序(例如不能用uuid做索引，只能做唯一标识，因为也是哈希无序的)。</p></li>
<li><p>有些值的 <strong>哈希索引是一样的</strong>，如果要进行查找，要
<strong>逐一比对</strong>，相当于全盘扫描。</p></li>
</ol>
<h2><span id="why-not-ping-heng-er-cha-shu">why not 平衡二叉树？</span><a href="#why-not-ping-heng-er-cha-shu" class="header-anchor">#</a></h2>
<p>平衡二叉树是采用
<strong>二分法</strong>思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据
<strong>减少无关数据的检索</strong>，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下特定：</p>
<ol type="1">
<li>平衡二叉树是一种 <strong>二叉查找树</strong></li>
<li>每个结点的左子树的高度减去右子树的
<strong>高度的绝对值不超过1</strong></li>
<li>空树和左右子树都是平衡二叉树</li>
<li>相比红黑树，平衡二叉树比较
<strong>适用于没有删除的情况</strong></li>
</ol>
<div style="width:95%;margin:auto">
<img src="/2020/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91/avl.png" class title="avl图">
</div>
<p>为什么不能用平衡二叉树： 1. 由于每个子节点最大数量为2，导致
<strong>平衡二叉树高度较高，查找次数相对较多。</strong> 2.
范围查找时，需要
<strong>向上回旋查找</strong>（例如查找&gt;=56的数，先找到56，然后向上回旋，找出65和87）</p>
<h2><span id="why-not-b-shu">why not B树？</span><a href="#why-not-b-shu" class="header-anchor">#</a></h2>
<p>B 树又叫 <strong>平衡多路查找树</strong>。一棵m阶的B 树
(注：切勿简单的认为一棵m阶的B树是m叉树，虽然存在四叉树，八叉树，KD树，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同)的特性如下：
1. 树中每个结点 <strong>最多含有m个孩子（m&gt;=2）</strong>； 2.
除根结点和叶子结点外，其它每个结点 <strong>至少有[ceil(m /
2)]个孩子</strong>（其中ceil(x)是一个取上限的函数）； 3. 若
<strong>根结点</strong>不是叶子结点，则
<strong>至少有2个孩子</strong>（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；
4. 所有 <strong>叶子结点都出现在同一层</strong>，叶子结点
<strong>不包含任何关键字信息</strong>(可以看做是
<strong>外部接点或查询失败的接点</strong>，叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。）。
5. 每个非终端结点中包含有n个关键字信息：
(n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中： a) Ki
(i=1...n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 b)
Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。
c) 关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</p>
<div style="width:95%;margin:auto">
<img src="/2020/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91/b_tree.jpg" class title="b_tree图">
</div>
<p>为什么不能用B树： 查找深度明显比平衡二叉树要低，但是范围查找仍然需要
<strong>向上回旋查找</strong></p>
<h2><span id="why-choose-b-shu">why choose B+树？</span><a href="#why-choose-b-shu" class="header-anchor">#</a></h2>
<p>B+树是B树的一个升级版，相对于B树来说B+树更
<strong>充分的利用了节点的空间</strong>，让查询速度更加稳定，其速度
<strong>完全接近于二分法查找</strong>。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p>
<h3><span id="b-shu-he-b-shu">B树和B+树</span><a href="#b-shu-he-b-shu" class="header-anchor">#</a></h3>
<ol type="1">
<li>B+跟B树不同，B+树的
<strong>非叶子节点不保存关键字记录的指针</strong>，只进行<strong>数据索引</strong>，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li>
<li>B+树
<strong>叶子节点保存了父节点的所有关键字记录的指针</strong>，<strong>所有数据地址必须要到叶子节点才能获取到</strong>。所以
<strong>每次数据查询的次数都一样</strong>；</li>
<li>B+树叶子节点的关键字
<strong>从小到大有序</strong>排列，左边结尾数据都会保存右边节点开始数据的指针。</li>
<li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料
这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的。Mysql
的B+树是用第一种方式实现）;
<div style="width:110%;margin:auto">
<img src="/2020/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91/b+tree.png" class title="b+tree图">
</div></li>
</ol>
<p>因此，B+树的
<strong>查找次数少</strong>(树的高度低)，<strong>范围查找也快</strong>（叶子节点通过指针连接）</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://blog.csdn.net/chai471793/article/details/99563704" title="彻底搞懂系列B-树、B+树、B-树、B*树">彻底搞懂系列B-树、B+树、B-树、B*树</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构]1.树状数组 Binary Indexed Tree</title>
    <url>/2021/03/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2><span id="1-what-can-binary-indexed-tree-do">1.what can Binary Indexed Tree
do？</span><a href="#1-what-can-binary-indexed-tree-do" class="header-anchor">#</a></h2>
<p>树状数组，也称作“二叉索引树”（<a href="https://www.topcoder.com/community/competitive-programming/tutorials/binary-indexed-trees/">Binary
Indexed Trees</a>）或 <a href="https://cp-algorithms.com/data_structures/fenwick.html">Fenwick
Tree</a>。 它可以高效地实现如下两个操作： 1. 数组<strong>前缀和（prefix
sum)的查询</strong> 2. 单点更新(update)</p>
<h2><span id="2-why-choose-binary-indexed-tree">2.why choose Binary Indexed
Tree?</span><a href="#2-why-choose-binary-indexed-tree" class="header-anchor">#</a></h2>
<p>假设有个n维数组： [2,3,5,-1,6] query(2,4)
求从第二个元素到第四个元素的和: 3 + 5 - 1 = 7 update(4, 2):
更新第四个元素加2</p>
<ul>
<li><p>普通遍历法： query: O(n) update: O(1)</p></li>
<li><p>dp 方法 建立prefix sums数组(前i个元素的和) 耗时: O(n); query:
O(1) 如果有个元素需要更新,则需要更新所有涉及的 prefix
sums数组元素:O(n)</p></li>
<li><p>树状数组 每个结点仅 <strong>存储部分元素的和</strong> query:
O(log(n)) update: O(log(n))</p></li>
</ul>
<h2><span id="3-basic-idea-of-binary-indexed-tree">3.Basic idea of Binary
Indexed Tree</span><a href="#3-basic-idea-of-binary-indexed-tree" class="header-anchor">#</a></h2>
<p>Binary Indexed Tree的 每个结点仅
<strong>存储部分区间元素的和</strong>. 我们以长度为16的数组为例</p>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
</colgroup>
<thead>
<tr>
<th>--</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>A数组</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>4</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>C数组</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>8</td>
<td>8</td>
<td>12</td>
<td>14</td>
<td>19</td>
<td>21</td>
<td>23</td>
<td>26</td>
<td>27</td>
<td>27</td>
<td>29</td>
</tr>
<tr>
<td>tree node include range</td>
<td>1</td>
<td>1~2</td>
<td>3</td>
<td>1~4</td>
<td>5</td>
<td>5~6</td>
<td>7</td>
<td>1~8</td>
<td>9</td>
<td>9~10</td>
<td>11</td>
<td>9~12</td>
<td>13</td>
<td>13~14</td>
<td>15</td>
<td>1~16</td>
</tr>
</tbody>
</table>
<div style="width:102%;margin:auto">
<img src="/2021/03/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/BinaryIndexedTree_update.png" class title="update图">
</div>
<ul>
<li>A数组是 <strong>原值</strong>, C数组是
<strong>根据某一规则存的是A数组若干项的和</strong>。</li>
<li>从上图来看，C数组似乎是呈对称的形态，比如C[8]表示A[1] ~
A[8]的和，而C[4]表示A[1] ~ A[4]的和，所以C[8]又可以表示C[4] + [6] +
C[7]。<strong>一个C数组的元素</strong>只有<strong>一个父结点</strong>，但却<strong>有好多子节点</strong>，可以形象地理解为一个C数组元素管着一片区域，怎么去知道一个元素到底在管着哪些A数组的元素呢？
下面是C[1] ~ c[8]值计算方式：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C[1] &#x3D; A[1];</span><br><span class="line">C[2] &#x3D; A[1] + A[2];</span><br><span class="line">C[3] &#x3D; A[3];</span><br><span class="line">C[4] &#x3D; A[1] + A[2] + A[3] + A[4];</span><br><span class="line">C[5] &#x3D; A[5];</span><br><span class="line">C[6] &#x3D; A[5] + A[6];</span><br><span class="line">C[7] &#x3D; A[7];</span><br><span class="line">C[8] &#x3D; A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];</span><br></pre></td></tr></table></figure>
我们把上面索引的十进制，全部换成二进制，如下：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C[1] &#x3D; C[0001] &#x3D; A[0001];</span><br><span class="line">C[2] &#x3D; C[0010] &#x3D; A[0001]+A[0010];</span><br><span class="line">C[3] &#x3D; C[0011] &#x3D; A[0011];</span><br><span class="line">C[4] &#x3D; C[0100] &#x3D; A[0001]+A[0010]+A[0011]+A[0100];</span><br><span class="line">C[5] &#x3D; C[0101] &#x3D; A[0101];</span><br><span class="line">C[6] &#x3D; C[0110] &#x3D; A[0101]+A[0110];</span><br><span class="line">C[7] &#x3D; C[0111] &#x3D; A[0111];</span><br><span class="line">C[8] &#x3D; C[1000] &#x3D; A[0001]+A[0010]+A[0011]+A[0100]+A[0101]+A[0110]+A[0111]+A[1000];</span><br></pre></td></tr></table></figure>
仔细观察上面的二进制表示，我们可以发现，<span class="math inline">\(C[i]\)</span>管的范围就是 <span class="math inline">\(i\)</span> 的二进制表示数
<strong>从低位到高位第一个为1</strong>的位置，(<strong>高位保持不变</strong>)和其<strong>所有低位二进制元素之和</strong>。</li>
</ul>
<h3><span id="3-1-lowbit">3.1 lowbit</span><a href="#3-1-lowbit" class="header-anchor">#</a></h3>
<p>那么怎么知道从低位起第一个为1的数怎么表示？这个操作有个名字叫做lowbit，计算方式为:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lowbit(i) &#x3D; i &amp; (-i) </span><br></pre></td></tr></table></figure>
计算该数的二进制从右往左第一个非0位所表示的10进制数，如下所示：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* (二进制)保留最低位的1及其后面的0，高位的1全部变为0，</span><br><span class="line">* 即得到该数的二进制从右往左第一个非0位所表示的10进制数。</span><br><span class="line">* 例如：</span><br><span class="line">* &lt;pre&gt;</span><br><span class="line">*  原值 0000 0110</span><br><span class="line">*  取反 1111 1001</span><br><span class="line">*  +1  1111 1010</span><br><span class="line">*  &amp; 0000 0010</span><br><span class="line">* &lt;&#x2F;pre&gt;</span><br><span class="line">*</span><br><span class="line">* @param k 待处理的十进制数</span><br><span class="line">* @return 处理后的十进制数</span><br><span class="line">*&#x2F;</span><br><span class="line">private static int lowBit(int k) &#123;</span><br><span class="line">    return k &amp; -k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再从图片宏观来看，我们发现整个结构似乎有点
<strong>二分的味道</strong>，具有某种<strong>对称性</strong>。 -
如果数组位置是奇数，那么<span class="math inline">\(C[i] =
A[i]\)</span>； - 如果是偶数，可以形象地看作二分：<span class="math inline">\(C[i] = C[i / 2] + A[i - (i / 2) + 1] + .... +
A[i]\)</span>。 而<span class="math inline">\(C[i /
2]\)</span>又可以利用上面的二分继续继续进行分割，直至不可分割。上面可以推导出如下公式：<span class="math inline">\(C[i]=A[i−2k+1]+A[i−2k+2]+…+A[i]\)</span>
，其中k为i的二进制中从最低位到高位连续零的长度。其中这个2k就是上面提到的<span class="math inline">\(lowbit(i)\)</span>。所以我们就知道即C[i]数组中保存的就是数组A的区间<span class="math inline">\([i-lowbit(i)+1,
i]\)</span>中所有数的和，公式如下：</p>
<p><span class="math display">\[ C[i] = \sum_{n=i-lowbit(i)+1}^i
A[i]\]</span></p>
<p>除此之外，还有一些规律：</p>
<ul>
<li><span class="math inline">\(C[i]\)</span>保存的是以它为根的子树中所有叶节点的和。</li>
<li><span class="math inline">\(C[i]\)</span>的子节点数量<span class="math inline">\(lowbit(i)\)</span></li>
<li><span class="math inline">\(C[i]\)</span>的父节点为<span class="math inline">\(C[i+lowbit(i)]\)</span></li>
</ul>
<h2><span id="4-update-dan-dian-geng-xin">4.update 单点更新</span><a href="#4-update-dan-dian-geng-xin" class="header-anchor">#</a></h2>
<p>在实际编码中，是<strong>没有<span class="math inline">\(A\)</span>数组</strong>的，<strong>只有<span class="math inline">\(C\)</span>数组</strong>，数据是保存在<span class="math inline">\(C\)</span>数组的，但逻辑上的操作是针对A数组，比如获取和更新某个索引位置的元素。</p>
<p>我们知道,<span class="math inline">\(C\)</span>数组中,父节点是所有子节点的和。当子节点更新时,需要从下至上更新所有关联结点。在更新过程中，也就是需要找到所有父节点。已知
<span class="math inline">\(C[i]\)</span>的父节点为<span class="math inline">\(C[i+lowbit(i)]\)</span>，所以每次向上寻找，只需在索引
<span class="math inline">\(i\)</span> 加上 <span class="math inline">\(lowbit(i)\)</span>：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (i &lt;&#x3D; length) &#123;</span><br><span class="line">  tree[i] +&#x3D; value;</span><br><span class="line">  i +&#x3D; lowBit(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="5-prefix-sum-shu-zu-qian-zhui-he">5.prefix sum 数组前缀和</span><a href="#5-prefix-sum-shu-zu-qian-zhui-he" class="header-anchor">#</a></h2>
<p>查找和的路径有点像单点更新的 <strong>逆过程</strong>。前i个数的和
<span class="math inline">\(Sum(i)\)</span>用<span class="math inline">\(C\)</span>数组可以表示为：</p>
<p><span class="math display">\[ Sum(i) = Sum(i-lowbit(i)) + C[i]
\]</span></p>
<p>代码可以写为：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">while (i &gt; 0) &#123;</span><br><span class="line">  sum +&#x3D; tree[i];</span><br><span class="line">  i -&#x3D; lowBit(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://cp-algorithms.com/data_structures/fenwick.html">Fenwick
Tree</a></li>
<li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/binary-indexed-trees/">Binary
Indexed Trees</a></li>
<li><a href="https://mingshan.fun/2019/11/29/binary-indexed-tree/">树状数组BinaryIndexedTree</a></li>
<li><a href="https://www.acwing.com/blog/content/80/">树状数组学习笔记</a></li>
<li><a href="https://oi-wiki.org/ds/fenwick/">树状数组</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[深入理解linux] 1.what is inode</title>
    <url>/2021/02/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-1-what-is-inode/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Inode">inode</a>是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础</p>
<h2><span id="1-what-is-inode">1. what is inode?</span><a href="#1-what-is-inode" class="header-anchor">#</a></h2>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th>linux文件相关</th>
<th>size</th>
<th>属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>扇区(Sector)</td>
<td>512bytes(0.5KB)</td>
<td>硬盘的最小存储单位</td>
</tr>
<tr>
<td>块(block)</td>
<td>通常4KB</td>
<td>文件存取的最小单位(操作系统读取硬盘,一次性读取一个块，提高效率)</td>
</tr>
<tr>
<td>inode</td>
<td>一般是128字节或256字节</td>
<td>储存文件的元信息(如创建者、创建日期、大小等)</td>
</tr>
</tbody>
</table>
<p>inode, 中文译名为"索引节点",包含了与该
<strong>文件有关的一些信息</strong>。</p>
<h2><span id="2-the-content-of-inode">2. the content of inode</span><a href="#2-the-content-of-inode" class="header-anchor">#</a></h2>
<p>use <strong>stat</strong> to check the content of inode:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ stat mssh_ip.sh</span><br><span class="line"></span><br><span class="line">  File: ‘mssh_ip.sh’</span><br><span class="line">  Size: 183             Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fe21h&#x2F;65057d    Inode: 7120498     Links: 1</span><br><span class="line">Access: (0644&#x2F;-rw-r--r--)  Uid: ( 7857&#x2F;liuwen03)   Gid: ( 7857&#x2F;liuwen03)</span><br><span class="line">Access: 2021-01-28 14:13:04.213991000 +0800</span><br><span class="line">Modify: 2021-01-28 14:13:04.213991000 +0800</span><br><span class="line">Change: 2021-02-04 11:37:19.457991000 +0800</span><br></pre></td></tr></table></figure></p>
<p>由此可以看出, inode包含文件的元信息，具体来说有以下内容：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　* 文件的字节数</span><br><span class="line">　　* 文件拥有者的User ID</span><br><span class="line">　　* 文件的Group ID</span><br><span class="line">　　* 文件的读、写、执行权限</span><br><span class="line">　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class="line">　　* 链接数，即有多少文件名指向这个inode</span><br><span class="line">　　* 文件数据block的位置</span><br></pre></td></tr></table></figure></p>
<h2><span id="3-what-is-inode-number">3. what is inode number?</span><a href="#3-what-is-inode-number" class="header-anchor">#</a></h2>
<p>inode是<a href="http://www.nongnu.org/ext2-doc/ext2.html#INODE-TABLE">inode
table</a>中的一个item。Linux扩展文件系统 (如ext2/ext3)
维护了一个inode的数组：inode table。inode
table包含该文件系统中所有文件的列表。inode table中的各个inode项具有
<strong>唯一的编号</strong> (该文件系统唯一)，即<strong>inode
number</strong>。</p>
<p>使用ls -i命令，可以看到文件名对应的inode number：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -li mssh_ip.sh</span><br><span class="line">7120498 -rw-r--r-- 1 liuwen03 liuwen03 183 Jan 28 14:13 mssh_ip.sh</span><br></pre></td></tr></table></figure>
## 4. the size and the number of inode
inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是
<strong>数据区</strong>，存放<strong>文件数据</strong>；另一个是inode区（<strong>inode
table</strong>），存放<strong>inode所包含的信息</strong>。
每个inode节点的size，一般是
<strong>128或256字节</strong>。inode节点的总数，在<strong>格式化时就给定</strong>，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode
table的大小就会达到128MB，占整块硬盘的12.8%。</p>
<p><strong>df -i</strong>显示文件系统inode的使用信息
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ df -i</span><br><span class="line">Filesystem        Inodes  IUsed     IFree IUse% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0        8134656 127239   8007417    2% &#x2F;</span><br><span class="line">udev             2056585    353   2056232    1% &#x2F;dev</span><br><span class="line">tmpfs            2058885    487   2058398    1% &#x2F;run</span><br><span class="line">tmpfs            2058885      4   2058881    1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs            2058885      4   2058881    1% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs            2058885     13   2058872    1% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vdc1      209713152 344897 209368255    1% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;vda1          62248    328     61920    1% &#x2F;boot</span><br></pre></td></tr></table></figure></p>
<h2><span id="5-mu-lu-de-inode-jie-gou">5. 目录的inode结构</span><a href="#5-mu-lu-de-inode-jie-gou" class="header-anchor">#</a></h2>
<p>Linux中的 <strong>目录</strong>
也被视<strong>为文件</strong>。目录是<strong>将文件名映射到其inode
number的特殊文件</strong>
(此映射称为dentry)。因此，当我们说某个目录包含文件和其他目录时，我们的意思是该目录将这些文件和目录映射到它们的inode
number。这就是目录无法容纳两个具有相同名称的文件的原因，因为它<strong>无法使用两个不同的inode
number映射一个名称</strong>。</p>
<p>每个目录项，由两部分组成：所包含文件的<strong>文件名</strong>，以及该文件名<strong>对应的inode号码</strong>。</p>
<p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以
<strong>如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中</strong>，而
<strong>读取inode节点内的信息需要目录文件的执行权限（x）</strong>。</p>
<h2><span id="6-inode-de-te-shu-zuo-yong">6、inode的特殊作用</span><a href="#6-inode-de-te-shu-zuo-yong" class="header-anchor">#</a></h2>
<p>由于<strong>inode号码与文件名</strong>分离，这种机制导致了一些Unix/Linux系统特有的现象。</p>
<ul>
<li><p>有时，文件名包含特殊字符，无法正常删除。这时，<strong>直接删除inode节点，就能起到删除文件的作用</strong>。</p></li>
<li><p>移动文件或重命名文件，<strong>只是改变文件名，不影响inode号码</strong>。</p></li>
<li><p>打开一个文件以后，系统就
<strong>以inode号码来识别</strong>这个文件，不再考虑文件名。因此，通常来说，<strong>系统无法从inode号码得知文件名</strong>。</p></li>
</ul>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<p>1.<a href="https://www.ruanyifeng.com/blog/2011/12/inode.html" title="理解inode">理解inode</a> 2.<a href="https://www.jianshu.com/p/0520d6b76318" title="详解Linux Inode">详解Linux Inode</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>深入理解linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构]2.字典树 Trie</title>
    <url>/2021/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E5%AD%97%E5%85%B8%E6%A0%91-Trie/</url>
    <content><![CDATA[<h2><span id="trie-jian-jie">Trie简介</span><a href="#trie-jian-jie" class="header-anchor">#</a></h2>
<p>Trie又称字典树，用于<strong>压缩存储字符串</strong>。</p>
<a id="more"></a>
<hr>
<p>下面是存储了字符串"apple", "append", "file" 的 Trie</p>
<pre class="mermaid">graph TB
root((root))--> 1((a))
1((a))--> 2((p))
2((p))--> 3((p))
3((p)) --> 4((l))
4((l))--> 5((e))

3((p)) --> 6((e))
6((e)) --> 7((n))
7((n)) --> 8((d))

root((root))--> f((f))
f((f)) --> i((i))
i((i)) --> l((l))
l((l)) --> e((e))</pre>
<h3><span id="yin-ru-jie-shu-fu">引入结束符</span><a href="#yin-ru-jie-shu-fu" class="header-anchor">#</a></h3>
<p>如果两个单词，其中一个是另一个的前缀，应该如何表示？例如“Maria”和“Mariana”。
为了解决这个问题，几乎所有的Trie都引入一个特定的结束符来标记结束，例如"."</p>
<h3><span id="you-dian">优点</span><a href="#you-dian" class="header-anchor">#</a></h3>
<ul>
<li>有时<strong>空间效率高</strong>：存储大量拥有<strong>相同前缀</strong>的单词。</li>
<li><strong>高效前缀查找</strong>, 如：
<ul>
<li>统计拥有"app"前缀的单词有多少个？</li>
<li>前缀"strawber"中下一个最可能出现的字符是什么？</li>
</ul></li>
</ul>
<h3><span id="que-dian">缺点</span><a href="#que-dian" class="header-anchor">#</a></h3>
<ul>
<li>通常<strong>空间效率低下</strong>：每个ASCII字符仅需1bytes存储空间,
连接Trie各结点的是<strong>指针</strong> -- 64位系统下需要8bytes</li>
<li>不是标准库：<strong>鲜有</strong>语言<strong>实现</strong>了built-in
Trie,需要我们自己实现</li>
</ul>
<h2><span id="trie-c-yu-yan-ban-shi-xian">Trie C语言版实现</span><a href="#trie-c-yu-yan-ban-shi-xian" class="header-anchor">#</a></h2>
<p>NEED TO DO LATER</p>
<hr>
<h2><span id="radix-trees-ji-shu-shu-kong-jian-you-hua-de-trie">Radix Trees基数树 ---
空间优化的Trie</span><a href="#radix-trees-ji-shu-shu-kong-jian-you-hua-de-trie" class="header-anchor">#</a></h2>
<p>Radix Trees是<strong>空间优化的Trie</strong>,
假如树中的一个节点是父节点的唯一子节点(the only
child)的话，那么该子节点将会与父节点进行合并。 不像是一般的trie树，radix
tree的边沿(edges)可以是一个或者多个元素。</p>
<p>下面是存储了字符串"apple", "append", "file" 的 Radix Trees</p>
<pre class="mermaid">graph TB
root((root))--> 1((app))
1((app))--> 2((le))
1((app))--> 3((end))

root((root))--> file((file))</pre>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<p>1.<a href="https://www.interviewcake.com/concept/java/trie">Trie Data
Structure</a> 2.<a href="https://www.geeksforgeeks.org/trie-insert-and-search/">Trie |
(Insert and Search)</a> 3.<a href="https://ivanzz1001.github.io/records/post/data-structure/2018/11/18/ds-radix-tree">数据结构之Radix
Tree</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[深入理解linux] 3. what is /dev/dm-0</title>
    <url>/2021/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-3-what-is-dev-dm-0/</url>
    <content><![CDATA[<h2><span id="wen-ti-miao-shu">问题描述</span><a href="#wen-ti-miao-shu" class="header-anchor">#</a></h2>
<p>使用df -h 发现/dev/dm-0 已使用100% <a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx-dev:# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;dm-0       7.8G  7.8G   20K 100% &#x2F;</span><br><span class="line">udev             10M     0   10M   0% &#x2F;dev</span><br><span class="line">tmpfs           3.2G  329M  2.9G  11% &#x2F;run</span><br><span class="line">tmpfs           7.9G   72K  7.9G   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vdc1       200G   46G  155G  23% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;vda1       236M   34M  190M  15% &#x2F;boot</span><br></pre></td></tr></table></figure></p>
<h2><span id="fen-xi">分析</span><a href="#fen-xi" class="header-anchor">#</a></h2>
<ol type="1">
<li><p>dmsetup查看对应的设备
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx-dev:# dmsetup info &#x2F;dev&#x2F;dm-0</span><br><span class="line">Name:              disk1-root</span><br><span class="line">State:             ACTIVE</span><br><span class="line">Read Ahead:        256</span><br><span class="line">Tables present:    LIVE</span><br><span class="line">Open count:        1</span><br><span class="line">Event number:      0</span><br><span class="line">Major, minor:      253, 0</span><br><span class="line">Number of targets: 1</span><br><span class="line">UUID: LVM-ytdyq65oG0cO4O95LsrZ1asrcdQSqvLBzepNHp4miyl5hLFuXzisTCvSzuUQihY5</span><br></pre></td></tr></table></figure></p></li>
<li><p>lsblk查看disks树形结构
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx-dev:# lsblk</span><br><span class="line"></span><br><span class="line">NAME           MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda            254:0    0    8G  0 disk</span><br><span class="line">├─vda1         254:1    0  243M  0 part &#x2F;boot</span><br><span class="line">└─vda2         254:2    0  7.8G  0 part</span><br><span class="line">  └─disk1-root 253:0    0  7.8G  0 lvm  &#x2F;      </span><br><span class="line">vdb            254:16   0    2G  0 disk [SWAP]</span><br><span class="line">vdc            254:32   0  200G  0 disk</span><br><span class="line">└─vdc1         254:33   0  200G  0 part &#x2F;home</span><br></pre></td></tr></table></figure></p></li>
<li><p>lvdisplay显示lvm详细信息
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx-dev:# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                &#x2F;dev&#x2F;disk1&#x2F;root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                disk1</span><br><span class="line">  LV UUID                zepNHp-4miy-l5hL-FuXz-isTC-vSzu-UQihY5</span><br><span class="line">  LV Write Access        read&#x2F;write</span><br><span class="line">  LV Creation host, time debian-owncloud-opt, 2015-06-15 16:00:36 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                7.76 GiB</span><br><span class="line">  Current LE             1986</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br><span class="line"></span><br><span class="line">root@xxx-dev:# lvdisplay|awk  &#39;&#x2F;LV Name&#x2F;&#123;n&#x3D;$3&#125; &#x2F;Block device&#x2F;&#123;d&#x3D;$3; sub(&quot;.*:&quot;,&quot;dm-&quot;,d); print d,n;&#125;&#39;  (使用awk提取每个dm映射的地址)</span><br><span class="line">dm-0 root</span><br></pre></td></tr></table></figure></p></li>
<li><p>iostat查看读写性能
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx-dev:# iostat</span><br><span class="line">Linux 3.16.0-4-amd64 (xxx-dev)         06&#x2F;10&#x2F;2021      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           2.22    0.00    0.64    0.02    0.09   97.02</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read&#x2F;s    kB_wrtn&#x2F;s    kB_read    kB_wrtn</span><br><span class="line">vda               2.56         1.21        15.32   26871618  338839230</span><br><span class="line">vdb               0.14         0.21         0.71    4626304   15647968</span><br><span class="line">vdc               0.34         1.10         9.18   24298844  202995646</span><br><span class="line">dm-0              2.50         1.21        15.32   26828725  338839189</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>dm对应的设备，一般都位于 /dev/mapper下面
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx-dev:# ls -l &#x2F;dev&#x2F;mapper</span><br><span class="line">total 0</span><br><span class="line">crw------- 1 root root 10, 236 Sep 27  2020 control</span><br><span class="line">lrwxrwxrwx 1 root root       7 Sep 27  2020 disk1-root -&gt; ..&#x2F;dm-0</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://superuser.com/questions/131519/what-is-this-dm-0-device/594011">What
is this dm-0 device?</a></li>
<li><a href="https://www.linuxquestions.org/questions/linux-newbie-8/dm0-in-iostat-652771/">dm0
in iostat???</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>深入理解linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[深入理解linux] 2. soft link/hard link</title>
    <url>/2021/02/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-2-soft-link-hard-link/</url>
    <content><![CDATA[<h2><span id="what-is-soft-link-and-hard-link">What is Soft Link And Hard
Link?</span><a href="#what-is-soft-link-and-hard-link" class="header-anchor">#</a></h2>
<ul>
<li><strong>硬链接(Hard Link)</strong>
充当所选文件的<strong>副本（镜像）</strong>。它访问原始文件中的可用数据。如果删除了先前选择的文件，则指向该文件的硬链接<strong>仍将包含该文件的数据</strong>。</li>
<li><strong>软链接(Soft Link)</strong> 充当文件名的
<strong>指针或引用</strong>。它不会访问原始文件中的可用数据。如果删除了先前的文件，则软链接将
<strong>指向不再存在的文件</strong>。</li>
</ul>
<h4><span id="tu-jie-soft-link-he-hard-link">图解Soft Link 和 Hard Link</span><a href="#tu-jie-soft-link-he-hard-link" class="header-anchor">#</a></h4>
<div style="width:100%;margin:auto">
<img src="/2021/02/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-2-soft-link-hard-link/forgfgarticle-snip.png" class title="图解软链接&#x2F;硬链接">
</div>
<h2><span id="difference">Difference</span><a href="#difference" class="header-anchor">#</a></h2>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th>参数</th>
<th>Hard link</th>
<th>Soft link</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://liuw.tech/2021/02/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-1-what-is-inode/">Inode</a>
number*</td>
<td>相同</td>
<td>不同</td>
</tr>
<tr>
<td>Directories 目录</td>
<td>不能链接目录(超级用户可以链接目录)</td>
<td>可以链接目录</td>
</tr>
<tr>
<td>File system 文件系统</td>
<td>不能跨文件系统</td>
<td>可以跨文件系统</td>
</tr>
<tr>
<td>Data 数据</td>
<td>不能跨文件系统</td>
<td>可以跨文件系统</td>
</tr>
<tr>
<td>File system 文件系统</td>
<td>保留原始数据文件</td>
<td>仅指向文件名，不保留文件的数据</td>
</tr>
<tr>
<td>permissions文件权限</td>
<td>与原始文件 <strong>始终保持</strong>相同权限</td>
<td>权限不同</td>
</tr>
<tr>
<td>Original file’s deletion 原始文件的删除</td>
<td>该链接仍可访问原始文件的数据</td>
<td>该链接无法使用，因为它无法访问原始文件的数据</td>
</tr>
<tr>
<td>Speed 访问速度</td>
<td>相对快</td>
<td>相对慢</td>
</tr>
</tbody>
</table>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://www.geeksforgeeks.org/difference-between-hard-link-and-soft-link/" title="Difference between Hard link and Soft link">Difference between
Hard link and Soft link</a></li>
<li><a href="https://ostechnix.com/explaining-soft-link-and-hard-link-in-linux-with-examples/">Explaining
Soft Link And Hard Link In Linux With Examples</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>深入理解linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[游戏编程模式] 2.3设计模式之观察者模式</title>
    <url>/2020/08/12/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-2-3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id="guan-cha-zhe-mo-shi">观察者模式</span><a href="#guan-cha-zhe-mo-shi" class="header-anchor">#</a></h2>
<p><strong>Model-View-Controller架构就是观察者模式的例子，C#中的Event委托也是使用的观察者模式</strong></p>
<table style="width:7%;">
<colgroup>
<col style="width: 6%">
</colgroup>
<tbody>
<tr>
<td>##### 进度条更新初阶版本</td>
</tr>
<tr>
<td><strong>下面样例产生了编译时的依赖（违背了抽象依赖细节）应该依赖抽象基类（MainForm与ProgressBar之间产生了依赖）</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FileSplitter</span><br><span class="line">&#123;</span><br><span class="line">    string m_filePath;</span><br><span class="line">    int m_fileNumber;</span><br><span class="line">    ProgressBar* m_progressBar;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    FileSplitter(const string&amp; filePath, int fileNumber, ProgressBar* progressBar) :</span><br><span class="line">        m_filePath(filePath), </span><br><span class="line">        m_fileNumber(fileNumber),</span><br><span class="line">        m_progressBar(progressBar)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void split()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.读取大文件</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.分批次向小文件中写入</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;...</span><br><span class="line">            float progressValue &#x3D; m_fileNumber;</span><br><span class="line">            progressValue &#x3D; (i + 1) &#x2F; progressValue;</span><br><span class="line">            &#x2F;&#x2F;更新进度条</span><br><span class="line">            &#x2F;&#x2F;不能依赖实现细节</span><br><span class="line">            m_progressBar-&gt;setValue(progressValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MainForm : public Form</span><br><span class="line">&#123;</span><br><span class="line">    TextBox* txtFilePath;</span><br><span class="line">    TextBox* txtFileNumber;</span><br><span class="line">    &#x2F;&#x2F;依赖ProgressBar</span><br><span class="line">    ProgressBar* progressBar;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void Button1_Click()&#123;</span><br><span class="line"></span><br><span class="line">        string filePath &#x3D; txtFilePath-&gt;getText();</span><br><span class="line">        int number &#x3D; atoi(txtFileNumber-&gt;getText().c_str());</span><br><span class="line"></span><br><span class="line">        FileSplitter splitter(filePath, number, progressBar);</span><br><span class="line"></span><br><span class="line">        splitter.split();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></td>
</tr>
</tbody>
</table>
<h5><span id="wen-jian-du-qu-jin-du-tiao-geng-xin-guan-cha-zhe-mo-shi-gai-jin-ban-ben">文件读取进度条更新观察者模式改进版本</span><a href="#wen-jian-du-qu-jin-du-tiao-geng-xin-guan-cha-zhe-mo-shi-gai-jin-ban-ben" class="header-anchor">#</a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改后，将progressbar抽象成接口，紧耦合变成松耦合，编译就不依赖progress</span><br><span class="line">&#x2F;&#x2F;变成了良好的耦合，符合依赖倒置原则</span><br><span class="line">&#x2F;&#x2F;iprogress接口</span><br><span class="line">class IProgress&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void DoProgress(float value)&#x3D;0;</span><br><span class="line">    virtual ~IProgress()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;被观察对象拥有一个观察者对象的集合（相当于subject）</span><br><span class="line">class FileSplitter</span><br><span class="line">&#123;</span><br><span class="line">    string m_filePath;</span><br><span class="line">    int m_fileNumber;</span><br><span class="line">    &#x2F;&#x2F;改良：使支持多个观察者，加入vector 或者list等</span><br><span class="line">    List&lt;IProgress*&gt;  m_iprogressList; &#x2F;&#x2F; 抽象通知机制，支持多个观察者</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    FileSplitter(const string&amp; filePath, int fileNumber) :</span><br><span class="line">        m_filePath(filePath), </span><br><span class="line">        m_fileNumber(fileNumber)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void split()&#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取大文件</span><br><span class="line">        &#x2F;&#x2F;2.分批次向小文件中写入</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;...</span><br><span class="line">            float progressValue &#x3D; m_fileNumber;</span><br><span class="line">            progressValue &#x3D; (i + 1) &#x2F; progressValue;</span><br><span class="line">            onProgress(progressValue);&#x2F;&#x2F;发送通知</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;原本列表初始化已经不适用，添加add和remove操作函数</span><br><span class="line">    void addIProgress(IProgress* iprogress)&#123;</span><br><span class="line">        m_iprogressList.push_back(iprogress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void removeIProgress(IProgress* iprogress)&#123;</span><br><span class="line">        m_iprogressList.remove(iprogress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;继续优化，protected下写onProgress，层次更清晰</span><br><span class="line">protected:</span><br><span class="line">    &#x2F;&#x2F;对于onprogress也需要改变</span><br><span class="line">    virtual void onProgress(float value)&#123;</span><br><span class="line">        List&lt;IProgress*&gt;::iterator itor&#x3D;m_iprogressList.begin();</span><br><span class="line">        while (itor !&#x3D; m_iprogressList.end() )</span><br><span class="line">            (*itor)-&gt;DoProgress(value); &#x2F;&#x2F;更新进度条</span><br><span class="line">            itor++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ConsoleNotifier : public IProgress &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void DoProgress(float value)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainForm : public Form, public IProgress</span><br><span class="line">&#123;</span><br><span class="line">    TextBox* txtFilePath;</span><br><span class="line">    TextBox* txtFileNumber;</span><br><span class="line"></span><br><span class="line">    ProgressBar* progressBar;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void Button1_Click()&#123;</span><br><span class="line"></span><br><span class="line">        string filePath &#x3D; txtFilePath-&gt;getText();</span><br><span class="line">        int number &#x3D; atoi(txtFileNumber-&gt;getText().c_str());</span><br><span class="line"></span><br><span class="line">        ConsoleNotifier cn;</span><br><span class="line"></span><br><span class="line">        FileSplitter splitter(filePath, number);</span><br><span class="line">        &#x2F;&#x2F;添加监听</span><br><span class="line">        splitter.addIProgress(this); &#x2F;&#x2F;订阅通知</span><br><span class="line">        splitter.addIProgress(&amp;cn)； &#x2F;&#x2F;订阅通知</span><br><span class="line"></span><br><span class="line">        splitter.split();</span><br><span class="line"></span><br><span class="line">        splitter.removeIProgress(this);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重写DoProgress</span><br><span class="line">    virtual void DoProgress(float value)&#123;</span><br><span class="line">        progressBar-&gt;setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div style="width:80%;margin:auto">
<img src="/2020/08/12/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-2-3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/sum_up.png" class title="观察者模式要点总结">
</div>
]]></content>
      <tags>
        <tag>游戏编程模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[游戏编程模式]1.架构、性能和游戏</title>
    <url>/2020/08/10/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-1-%E6%9E%B6%E6%9E%84%E3%80%81%E6%80%A7%E8%83%BD%E5%92%8C%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h3><span id="ruan-jian-jia-gou">软件架构</span><a href="#ruan-jian-jia-gou" class="header-anchor">#</a></h3>
<ol type="1">
<li>衡量一个设计的好坏的方法就是
<strong>看它应对变化的灵活性</strong></li>
<li>许多模式让代码更灵活，但它依赖于虚函数派发，接口，指针，消息以及其它一些至少有一些运行成本的机制。</li>
<li>保持代码的灵活性，直到设计稳定下来，然后去除一些抽象，提高游戏性能。</li>
</ol>
<p><strong>开发中的考虑因素</strong> 1. 良好的框架，更容易理解代码 2.
快速的运行时性能 3. 快速完成今天的功能</p>
]]></content>
      <tags>
        <tag>游戏编程模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[游戏编程模式]2.1设计模式之命令模式</title>
    <url>/2020/08/10/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-2-1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id="ming-ling-mo-shi">命令模式</span><a href="#ming-ling-mo-shi" class="header-anchor">#</a></h2>
<p><strong>命令就是面向对象化的回调。</strong></p>
<p>示例代码
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基类</span><br><span class="line">class Command</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void execute() &#x3D; 0;</span><br><span class="line">    virtual ~Command()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteCommand1 : public Command</span><br><span class="line">&#123;</span><br><span class="line">    string arg;</span><br><span class="line">public:</span><br><span class="line">    ConcreteCommand1(const string &amp; a) : arg(a) &#123;&#125;</span><br><span class="line">    void execute() override</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; &quot;#1 process...&quot;&lt;&lt;arg&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteCommand2 : public Command</span><br><span class="line">&#123;</span><br><span class="line">    string arg;</span><br><span class="line">public:</span><br><span class="line">    ConcreteCommand2(const string &amp; a) : arg(a) &#123;&#125;</span><br><span class="line">    void execute() override</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; &quot;#2 process...&quot;&lt;&lt;arg&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class MacroCommand : public Command</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Command*&gt; commands;</span><br><span class="line">public:</span><br><span class="line">    void addCommand(Command *c) &#123; commands.push_back(c); &#125;</span><br><span class="line">    void execute() override</span><br><span class="line">    &#123;</span><br><span class="line">        for (auto &amp;c : commands)</span><br><span class="line">        &#123;</span><br><span class="line">            c-&gt;execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ConcreteCommand1 command1(receiver, &quot;Arg ###&quot;);</span><br><span class="line">    ConcreteCommand2 command2(receiver, &quot;Arg $$$&quot;);</span><br><span class="line"></span><br><span class="line">    MacroCommand macro;</span><br><span class="line">    macro.addCommand(&amp;command1);</span><br><span class="line">    macro.addCommand(&amp;command2);</span><br><span class="line">    </span><br><span class="line">    macro.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>命令模式很容易实现撤销和重做</strong></p>
]]></content>
      <tags>
        <tag>游戏编程模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[游戏编程模式]2.2设计模式之享元模式</title>
    <url>/2020/08/11/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-2-2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id="xiang-yuan-mo-shi">享元模式</span><a href="#xiang-yuan-mo-shi" class="header-anchor">#</a></h2>
<p><strong>内存池，对象池的实现</strong>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基本类</span><br><span class="line">class Font &#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;&#x2F;unique object key</span><br><span class="line">    string key;</span><br><span class="line">    &#x2F;&#x2F;object state</span><br><span class="line">    &#x2F;&#x2F;....</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Font(const string&amp; key)&#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ß</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;建立一个工厂</span><br><span class="line">class FontFactory&#123;</span><br><span class="line">private:</span><br><span class="line">    map&lt;string,Font* &gt; fontPool;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Font* GetFont(const string&amp; key)&#123;</span><br><span class="line"></span><br><span class="line">        map&lt;string,Font*&gt;::iterator item&#x3D;fontPool.find(key);</span><br><span class="line">        </span><br><span class="line">        if(item!&#x3D;footPool.end())&#123;</span><br><span class="line">            return fontPool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            Font* font &#x3D; new Font(key);</span><br><span class="line">            fontPool[key]&#x3D; font;</span><br><span class="line">            return font;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void clear()&#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>游戏编程模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[计网]http之GET和POST区别</title>
    <url>/2020/12/02/%E8%AE%A1%E7%BD%91-http%E4%B9%8BGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1><span id="liu-lan-qi-de-get-he-post">浏览器的GET和POST</span><a href="#liu-lan-qi-de-get-he-post" class="header-anchor">#</a></h1>
<p>这里特指浏览器中 <strong>非Ajax的HTTP请求</strong>，即从
<strong>HTML和浏览器</strong>诞生就一直使用的HTTP协议中的GET/POST。浏览器用
<strong>GET请求来获取一个html页面/图片/css/js等资源</strong>；用
<strong>POST来提交一个&lt; form&gt;表单</strong>，并
<strong>得到一个结果的网页</strong>。</p>
<h2><span id="get">GET</span><a href="#get" class="header-anchor">#</a></h2>
<p><strong>“读取“一个资源</strong>。比如Get到一个html文件。
<strong>反复读取不应该对访问的数据有副作用</strong>。比如”GET一下，用户就下单了，返回订单已受理“，这是不可接受的。没有副作用被称为
<strong>“幂等“（Idempotent)</strong>。因为
<strong>GET是读取</strong>，就可以
<strong>对GET请求的数据做缓存</strong>。这个缓存可以做到浏览器本身上（彻底
<strong>避免浏览器发请求</strong>），也可以做到代理上（如
<strong>nginx</strong>），或者
<strong>做到server端</strong>（用Etag，至少可以减少带宽消耗）</p>
<h2><span id="post">POST</span><a href="#post" class="header-anchor">#</a></h2>
<p>在页面里 <strong>&lt; form&gt; 标签</strong>会定义
<strong>一个表单</strong>。点击其中的
<strong>submit元素</strong>会发出一个
<strong>POST请求让服务器做一件事</strong>。这件事往往是
<strong>有副作用的，不幂等的</strong>。不幂等也就意味着
<strong>不能随意多次执行</strong>。因此也就
<strong>不能缓存</strong>。比如通过POST下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。试想一下，如果POST请求被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的“下单成功界面”，却又没有真的在服务器下单。那是一件多么滑稽的事情。因为POST可能有副作用，所以浏览器实现为
<strong>不能把POST请求保存为书签</strong>。想想，如果点一下书签就下一个单，是不是很恐怖？。此外如果尝试重新执行POST请求，浏览器也会弹一个框提示下这个刷新可能会有副作用，询问要不要继续。</p>
<h2><span id="gai-zao-get-he-post">改造GET和POST</span><a href="#gai-zao-get-he-post" class="header-anchor">#</a></h2>
<p>当然，服务器的
<strong>开发者完全可以把GET实现为有副作用；把POST实现为没有副作用</strong>。只不过这和浏览器的预期不符。把GET实现为有副作用是个很可怕的事情。
我依稀记得很久之前百度贴吧有一个因为
<strong>使用GET请求可以修改管理员的权限而造成的安全漏洞</strong>。反过来，把没有副作用的请求用POST实现，浏览器该弹框还是会弹框，对用户体验好处改善不大。但是后边可以看到，将HTTP
POST作为接口的形式使用时，就没有这种弹框了。于是
<strong>把一个POST请求实现为幂等就有实际的意义</strong>。
<strong>POST幂等能让很多业务的前后端交互更顺畅</strong>，以及避免一些因为前端bug，触控失误等带来的重复提交。将一个有副作用的操作实现为幂等必须得从业务上能定义出怎么就算是“重复”。如提交数据中增加一个dedupKey在一个交易会话中有效，或者
<strong>利用提交的数据里可以天然当dedupKey的字段</strong>。这样万一用户强行重复提交，服务器端可以做一次防护。</p>
<h2><span id="get-he-post-shu-ju-de-ge-shi-qu-bie">GET和POST数据的格式区别</span><a href="#get-he-post-shu-ju-de-ge-shi-qu-bie" class="header-anchor">#</a></h2>
<p>GET和POST <strong>携带数据的格式也有区别</strong>。
当浏览器发出一个GET请求时，就意味着
<strong>要么是用户自己在浏览器的地址栏输入</strong>，要不就是
<strong>点击了html里a标签的href中的url</strong>。所以其实
<strong>并不是GET只能用url</strong>，而是
<strong>浏览器直接发出的GET只能由一个url触发</strong>。GET上要在url之外带一些参数就
<strong>只能依靠url上附带querystring</strong>。请求参数和对应的值附加在URL后面，利用一个
<strong>"?"代表URL的结尾与请求参数的开始</strong>，多个 <strong>参数用
"&amp;"连接</strong>。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;server&#x2F;action?id&#x3D;a&amp;id&#x3D;b </span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;server&#x2F;action&#x2F;?info\&#x3D;&#39;&#39;\&amp;abc\&#x3D;c6cebb78a7be\&amp;server\&#x3D;52300 (这里加了转义字符&#39;\&#39;，待验证是否必要)</span><br></pre></td></tr></table></figure></p>
<p>但是HTTP协议本身并没有这个限制。浏览器的POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是
<strong>application/x-www-form-urlencoded用来传输简单的数据</strong>，大概就是"key1=value1&amp;key2=value2"这样的格式。另外一种是
<strong>传文件，会采用multipart/form-data格式</strong>。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。浏览器在POST一个表单时，<strong>url上也可以带参数</strong>，只要&lt;
form action="url"
&gt;里的url带querystring就行。只不过表单里面的那些用&lt; input&gt;
等标签经过用户操作产生的数据都在会在body里。因此我们一般会泛泛的说“GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中“。但这种情况仅限于浏览器发请求的场景。</p>
<p>参考 <a href="https://www.zybuluo.com/JunQiu/note/1291674" title="四种常见的 POST 提交数据方式？">四种常见的 POST
提交数据方式</a></p>
<h1><span id="jie-kou-zhong-de-get-he-post">接口中的GET和POST</span><a href="#jie-kou-zhong-de-get-he-post" class="header-anchor">#</a></h1>
<p>这里是指通过浏览器的Ajax api，或者iOS/Android的App的http
client，java的commons-httpclient/okhttp或者是curl，postman之类的工具
<strong>发出来的GET和POST请求</strong>。此时GET/POST不光能用在
<strong>前端和后端的交互</strong>中，还能用在
<strong>后端各个子服务的调用</strong>中（即当一种
<strong>RPC协议</strong>使用）。尽管RPC有很多协议，比如thrift，grpc，但是http本身
<strong>已经有大量的现成的支持工具</strong>可以使用，并且对人类很友好，容易debug。HTTP协议在
<strong>微服务中的使用是相当普遍</strong>的。当用
<strong>HTTP实现接口</strong>发送请求时，就
<strong>没有浏览器中那么多限制了，只要是
</strong>符合HTTP格式的就可以发<strong>。HTTP请求的格式，大概是这样的一个字符串：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;METHOD&gt; &lt;URL&gt; HTTP&#x2F;1.1\r\n</span><br><span class="line">&lt;Header1&gt;: &lt;HeaderValue1&gt;\r\n</span><br><span class="line">&lt;Header2&gt;: &lt;HeaderValue2&gt;\r\n</span><br><span class="line">...</span><br><span class="line">&lt;HeaderN&gt;: &lt;HeaderValueN&gt;\r\n</span><br><span class="line">\r\n</span><br><span class="line">&lt;Body Data....&gt;</span><br></pre></td></tr></table></figure>
其中的“<method>"可以 是 </method></strong>GET或POST<strong>，或者其他的HTTP
Method，如 </strong>PUT、DELETE、OPTION……<strong>。HTTP是
</strong>基于TCP/IP的<strong>关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是
</strong>TCP/IP<strong>，也就是说，</strong>GET/POST都是TCP链接<strong>。GET和POST能做的事情是一样的。因此从协议本身看，并
</strong>没有什么限制说GET一定不能没有body<strong>，</strong>POST就一定不能把参放到<url>的querystring上<strong>。因此其实
</strong>可以更加自由的去利用格式<strong>。比如Elastic Search的_search
api就 </strong>用了带body的GET<strong>；也可以自己开发接口
</strong>让POST一半的参数放在url的querystring里<strong>，</strong>另外一半放body里**；你甚至还可以让所有的参数都放Header里——可以做各种各样的定制，只要请求的客户端和服务器端能够约定好。</url></p>
<p>当然，太自由也带来了另一种麻烦，开发人员不得不每次讨论确定参数是
<strong>放url的path里，querystring里，body里，header里</strong>这种问题。于是就有了
<strong>一些列接口规范/风格</strong>。其中名气最大的当属
<strong>REST</strong>。REST充分运用
<strong>GET、POST、PUT和DELETE，约定了这4个接口分别获取、创建、替换和删除“资源”</strong>，REST最佳实践还推荐在
<strong>请求体使用json格式</strong>。这样仅仅通过看HTTP的method就可以明白接口是什么意思，并且解析格式也得到了统一。</p>
<h3><span id="get-he-post-huan-you-yi-ge-chong-da-qu-bie">GET和POST还有一个重大区别：</span><a href="#get-he-post-huan-you-yi-ge-chong-da-qu-bie" class="header-anchor">#</a></h3>
<p><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></p>
<p>对于GET方式的请求，浏览器会把 <strong>http
header和data一并发送出</strong>去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器 <strong>先发送header，服务器响应100
continue，浏览器再发送data，服务器响应200 ok</strong>（返回数据）。
<strong>注：</strong> 1. GET与POST都有自己的语义，不能随便混用。</p>
<ol start="2" type="1">
<li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li>
<li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li>
</ol>
<h3><span id="json-xiang-dui-yu-x-www-form-urlencoded-de-you-shi">json相对于x-www-form-urlencoded的优势:</span><a href="#json-xiang-dui-yu-x-www-form-urlencoded-de-you-shi" class="header-anchor">#</a></h3>
<ol type="1">
<li>可以有 <strong>嵌套结构</strong></li>
<li>可以支持
<strong>更丰富的数据类型</strong>。通过一些框架，json可以直接被服务器代码映射为业务实体。用起来十分方便。但是
<strong>如果是写一个接口支持上传文件</strong>，那么还是
<strong>multipart/form-data格式更合适</strong>。</li>
</ol>
<h1><span id="an-quan-xing">安全性</span><a href="#an-quan-xing" class="header-anchor">#</a></h1>
<p>我们常听到GET不如POST安全，因为
<strong>POST用body传输数据</strong>，而
<strong>GET用url传输</strong>，更加容易看到。但是
<strong>从攻击的角度，无论是GET还是POST都不够安全</strong>，因为
<strong>HTTP本身是明文协议</strong>。每个
<strong>HTTP请求和返回的每个byte都会在网络上明文传播</strong>，不管是url，header还是body。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。为了避免传输中数据被窃取，<strong>必须做从客户端到服务器的端端加密</strong>。业界的通行做法就是
<strong>https</strong>——即
<strong>用SSL协议协商出的密钥加密明文的http数据</strong>。这个
<strong>加密的协议和HTTP协议本身相互独立</strong>。如果是利用HTTP开发公网的站点/App，要保证安全，<strong>https是最最基本的要求</strong>。当然，端端加密并不一定非得用https。比如国内金融领域都会用私有网络，也有GB的加密协议SM系列。但除了军队，金融等特殊机构之外，似乎并没有必要自己发明一套类似于ssl的协议。</p>
<p>回到HTTP本身，的确
<strong>GET请求的参数更倾向于放在url</strong>上，因此
<strong>有更多机会被泄漏</strong>。比如携带私密信息的url会展示在地址栏上，还可以分享给第三方，就非常不安全了。此外，从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的access
log通常会输出完整的url，比如nginx的默认access
log就是如此。如果url上携带敏感数据，就会被记录下来。但请注意，就算私密数据在body里，也是可以被记录下来的，因此如果请求要经过不信任的公网，<strong>避免泄密的唯一手段就是https</strong>。这里说的“避免access
log泄漏“仅仅是指避免可信区域中的http代理的默认行为带来的安全隐患。</p>
<h1><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h1>
<ol type="1">
<li><a href="https://www.zhihu.com/question/28586791" title="知乎--GET 和 POST 到底有什么区别？">知乎--GET 和 POST
到底有什么区别？</a></li>
<li><a href="https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/" title="都 2019 年了，还问 GET 和 POST 的区别">都 2019 年了，还问 GET 和
POST 的区别</a></li>
<li><a href="https://www.zybuluo.com/JunQiu/note/1291674" title="四种常见的 POST 提交数据方式？">四种常见的 POST
提交数据方式</a></li>
</ol>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>[计网]socket缓冲区</title>
    <url>/2022/03/01/%E8%AE%A1%E7%BD%91-socket%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h3><span id="yi-jian-jie">一. 简介</span><a href="#yi-jian-jie" class="header-anchor">#</a></h3>
<p>每个socket被创建后，无论使用的是TCP协议还是UDP协议，都会创建自己的接收缓冲区和发送缓冲区。当我们调用write()/send()
向网络发送数据时，系统并不会
马上向网络传输数据，而是<strong>首先将数据拷贝到发送缓冲区，由系统负责择时发送数据</strong>。根据我们选用的网络协议以及阻塞模式，系统会有不同的处理。
<a id="more"></a></p>
<p>这些socket缓冲区特性可整理如下：</p>
<ul>
<li>socket缓冲区在每个套接字中单独存在；</li>
<li>socket缓冲区在创建套接字时自动生成；</li>
<li>即使关闭套接字也会继续传送发送缓冲区中遗留的数据；</li>
<li>关闭套接字将丢失接收缓冲区中的数据。</li>
</ul>
<h3><span id="er-blocking-mo-ren-he-nonblock-mo-shi-xia-read-write-xing-wei-de-qu-bie">二.
blocking（默认）和nonblock模式下read/write行为的区别：</span><a href="#er-blocking-mo-ren-he-nonblock-mo-shi-xia-read-write-xing-wei-de-qu-bie" class="header-anchor">#</a></h3>
<p>将socket
fd设置为nonblock（非阻塞）是在服务器编程中常见的做法，采用blocking
IO并为每一个client创建一个线程的模式开销巨大且可扩展性不佳（带来大量的切换开销），更为通用的做法是采用线程池+Nonblock
I/O+Multiplexing（select/poll，以及Linux上特有的epoll）。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置一个文件描述符为nonblock</span><br><span class="line">int set_nonblocking(int fd)</span><br><span class="line">&#123;</span><br><span class="line">    int flags;</span><br><span class="line">    if ((flags &#x3D; fcntl(fd, F_GETFL, 0)) &#x3D;&#x3D; -1)</span><br><span class="line">        flags &#x3D; 0;</span><br><span class="line">    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th>-</th>
<th>read/recv(有数据时立即返回)</th>
<th>write/send</th>
</tr>
</thead>
<tbody>
<tr>
<td>blocking</td>
<td>receive buffer为空时<strong>等待</strong></td>
<td>在缓冲区足以放下整个buffer时才返回</td>
</tr>
<tr>
<td>non-blocking</td>
<td>当receive buffer为空时, <strong>立即返回-1</strong>(errno =
EAGAIN或EWOULDBLOCK)</td>
<td>返回能够放下的字节数，之后调用则返回-1(errno =
EAGAIN或EWOULDBLOCK)</td>
</tr>
</tbody>
</table>
<h3><span id="san-wen-ti-si-kao">三. 问题思考</span><a href="#san-wen-ti-si-kao" class="header-anchor">#</a></h3>
<h4><span id="wen-ti-1">问题1</span><a href="#wen-ti-1" class="header-anchor">#</a></h4>
<p>Client 创建一个 TCP 的 socket，并通过 SO_SNDBUF
选项设置它的发送缓冲区大小为 <strong>4096 字节</strong>，连接到 Server
后，每 1 秒发送一个 TCP 数据段长度为 1024 的报文。Server 端不调用
recv(), 会发生什么?</p>
<ul>
<li>Phase 1: Server 端的 socket
<strong>接收缓冲区</strong>未满，所以尽管 Server 不会 recv()，但依然能对
Client 发出的报文<strong>回复 ACK</strong>;</li>
<li>Phase 2: Server 端的 socket <strong>接收缓冲区被填满了</strong>，向
Client 端通告<strong>零窗口(Zero Window)</strong>。Client
端待发送的数据开始<strong>累积在 socket 的发送缓冲区</strong>;</li>
<li>Phase 3: Client 端的 socket
的<strong>发送缓冲区满了</strong>，用户进程<strong>阻塞在
send()</strong> 上。</li>
</ul>
<h4><span id="wen-ti-2">问题2</span><a href="#wen-ti-2" class="header-anchor">#</a></h4>
<p>write返回大于0时, 这部分数据是否发送成功？ - 不一定,
write返回大于0仅表示写到了<strong>socket发送缓冲区成功</strong>,
若此时网络异常tcp断开了或者对方close了fd, 发送失败。 -
因此write成功无法说明对方已经收到数据。可以用<strong>应用程序级的ACK来解决这个问题</strong></p>
<h3><span id="si-netstat-cha-kan-socket">四. netstat查看socket</span><a href="#si-netstat-cha-kan-socket" class="header-anchor">#</a></h3>
<h4><span id="cha-kan-linux-socket-fa-song-huan-chong-qu-da-yu-1-de-socket">查看linux
socket发送缓冲区大于1的socket</span><a href="#cha-kan-linux-socket-fa-song-huan-chong-qu-da-yu-1-de-socket" class="header-anchor">#</a></h4>
<p>netstat -nt<strong>查看tcp端口</strong>, 发送缓冲区大于0的连接
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -nt|awk &#39;&#123;if($3&gt;&#x3D;1)print $0&#125;&#39;</span><br><span class="line">Active Internet connections (w&#x2F;o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      1 xxx.xxx.xxx.29:51064     xxx.xxx.xxx:8999    SYN_SENT</span><br><span class="line">tcp        0      1 xxx.xxx.xxx.29:51981     xxx.xxx.xxx:8999    SYN_SENT</span><br><span class="line">tcp        0    112 xxx.xxx.xxx.29:32200     xxx.xxx.xxx:58208     ESTABLISHED</span><br><span class="line">tcp        0      1 xxx.xxx.xxx.29:50507     xxx.xxx.xxx:443        SYN_SENT</span><br></pre></td></tr></table></figure>
各字段说明
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Recv-Q: 接受缓冲区待处理数据 The count of bytes not copied by the user program connected to this socket.</span><br><span class="line">- Send-Q: 发送缓冲区待处理数据 The count of bytes not acknowledged by the remote host.</span><br><span class="line">- Address: 本地端口 Address  and port number of the local end of the socket</span><br><span class="line">- Foreign Address: 远端端口 Address and port number of the remote end of the socket.</span><br><span class="line">- State: 连接状态</span><br></pre></td></tr></table></figure></p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://segmentfault.com/a/1190000021488755">一个 TCP
发送缓冲区问题的解析</a></li>
<li><a href="https://blog.csdn.net/pythontide/article/details/109199547">查看并修改socket接收和发送缓冲区大小</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/71799852">深刻理解socket编程中的read&amp;&amp;write</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/372798949">谈谈socket缓冲区</a></li>
<li><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">TCP
Sliding Window Acknowledgment System For Data Transport, Reliability and
Flow Control</a></li>
<li><a href="http://www.cs.uni.edu/~diesburg/courses/cs3470_fa14/sessions/s29/s29.pdf">TCP
Sliding Window</a></li>
<li><a href="https://fasionchan.com/network/tcp/sliding-window/">滑动窗口，TCP的流量控制机制</a></li>
</ol>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>[计网]基于gunicorn的简单web服务器</title>
    <url>/2021/10/15/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E4%BA%8Egunicorn%E7%9A%84%E7%AE%80%E5%8D%95web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2><span id="1-what-is-gunicorn">1. what is gunicorn</span><a href="#1-what-is-gunicorn" class="header-anchor">#</a></h2>
<h4><span id="1-1-definition">1.1 definition</span><a href="#1-1-definition" class="header-anchor">#</a></h4>
<p><a href="https://gunicorn.org/">Gunicorn</a> 'Green Unicorn' is a
<strong>Python <a href="https://zhuanlan.zhihu.com/p/95942024">WSGI</a>
HTTP Server</strong> for <strong>UNIX</strong>. It's a <strong><a href="https://stackoverflow.com/questions/25834333/what-exactly-is-a-pre-fork-web-server-model">pre-fork</a></strong>
worker model. The Gunicorn server is broadly <strong>compatible</strong>
with various web frameworks, <strong>simply</strong> implemented,
<strong>light</strong> on server resources, and fairly
<strong>speedy</strong>. <a id="more"></a></p>
<h4><span id="1-2-characteristics">1.2 characteristics</span><a href="#1-2-characteristics" class="header-anchor">#</a></h4>
<ul>
<li>Gunicorn是基于prefork模式的Python wsgi应用服务器，支持 Unix
like的系统</li>
<li>采用epoll (Linux下) 非阻塞网络I/O 模型</li>
<li>多种Worker类型可以选择 同步的，基于事件的（gevent
tornado等），基于多线程的</li>
<li>高性能，比之uwsgi不相上下</li>
<li>配置使用非常简单</li>
<li>支持 Python 2.x &gt;= 2.6 or Python 3.x &gt;= 3.2</li>
</ul>
<h2><span id="2-how-to-use">2. how to use</span><a href="#2-how-to-use" class="header-anchor">#</a></h2>
<h4><span id="2-1-install">2.1 install</span><a href="#2-1-install" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure>
<h4><span id="2-2-start">2.2 start</span><a href="#2-2-start" class="header-anchor">#</a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gunicorn [options] module_name:variable_name</span><br></pre></td></tr></table></figure>
<p>module_name对应python文件，variable_name对应web应用实例</p>
<h4><span id="2-3-ji-chu-example">2.3 基础example</span><a href="#2-3-ji-chu-example" class="header-anchor">#</a></h4>
<p>编写简单的myapp.py:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def app(version, start_response):</span><br><span class="line">    logging.info(&quot;version: %s&quot; % version)</span><br><span class="line">    data &#x3D; b&quot;hello, world! \n&quot;</span><br><span class="line">    start_response(&quot;200 OK&quot;, [</span><br><span class="line">        (&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;),</span><br><span class="line">        (&quot;Content-Length&quot;, str(len(data)))</span><br><span class="line">        ])</span><br><span class="line">    return iter([data])</span><br></pre></td></tr></table></figure></p>
<p>启动gunicorn
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn myapp:app -b localhost:8080</span><br></pre></td></tr></table></figure></p>
<p>使用curl访问8080端口
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8080</span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure></p>
<h4><span id="2-4-shi-yong-flask-da-jian-jian-dan-de-web-fu-wu-qi">2.4
使用flask搭建简单的web服务器</span><a href="#2-4-shi-yong-flask-da-jian-jian-dan-de-web-fu-wu-qi" class="header-anchor">#</a></h4>
<p>编写myflask.py
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;demo&#39;, methods&#x3D;[&#39;GET&#39;])</span><br><span class="line">def demo():</span><br><span class="line">    return &quot;gunicorn and flask demo.\n&quot;</span><br></pre></td></tr></table></figure>
本地简单的文件组织结构如下:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -lh</span><br><span class="line">total 4.0K</span><br><span class="line">drwxr-xr-x 2 xxx xxx  92 Oct 18 15:12 log</span><br><span class="line">drwxr-xr-x 2 xxx xxx 120 Oct 18 17:41 script</span><br><span class="line">-rw-r--r-- 1 xxx xxx 657 Oct 18 14:16 start.sh</span><br></pre></td></tr></table></figure></p>
<p>为了启动方便, 写个简单的start.sh启动脚本如下
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -i :$2|grep gunicorn|awk &#39;&#123;print $2&#125;&#39;|xargs kill -9   # kill掉原来该端口上 gunicorn进程</span><br><span class="line"></span><br><span class="line">cd script </span><br><span class="line">if [ -z &quot;$3&quot; ]; then    </span><br><span class="line">    nohup gunicorn --workers&#x3D;1 $1:app -b localhost:$2 1&gt;..&#x2F;log&#x2F;log.$&#123;2&#125;_$&#123;1&#125; 2&gt;&amp;1 &amp;     # 未指定进程数</span><br><span class="line">else</span><br><span class="line">    nohup gunicorn --workers&#x3D;$3 $1:app -b localhost:$2 1&gt;..&#x2F;log&#x2F;log.$&#123;2&#125;_$&#123;1&#125; 2&gt;&amp;1 &amp;    </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">sleep 1.5s</span><br><span class="line"></span><br><span class="line">info&#x3D;&#96;lsof -i :$2|grep gunicorn&#96;</span><br><span class="line"># echo $&#123;info&#125;</span><br><span class="line">if [ -z &quot;$info&quot; ]; then</span><br><span class="line">    echo &quot;Something wrong~ Fail to start gunicorn!&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;succeed starting gunicorn which port is $2 and which script&#39;s name is $1&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
启动2个gunicorn进程, 监听8090端口
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sh start.sh myflask 8090 2</span><br><span class="line"></span><br><span class="line">succeed starting gunicorn which port is 8090 and which script&#39;s name is myflask</span><br></pre></td></tr></table></figure></p>
<p>测试下是否ok
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8090&#x2F;demo</span><br><span class="line">gunicorn and flask demo.</span><br></pre></td></tr></table></figure>
至此，一个基于flask和gunicorn的简单web server就搭建完成了.</p>
<h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2>
<ol type="1">
<li><a href="https://gunicorn.org/">gunicorn</a></li>
<li><a href="https://docs.gunicorn.org/en/stable/design.html">gunicorn
design</a></li>
<li><a href="https://stackoverflow.com/questions/25834333/what-exactly-is-a-pre-fork-web-server-model">what-exactly-is-a-pre-fork-web-server-model</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/95942024">WSGI是什么?from
zhihu</a></li>
<li><a href="https://www.jianshu.com/p/52d8e3deaa16">gunicorn学习介绍</a></li>
</ol>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
</search>
